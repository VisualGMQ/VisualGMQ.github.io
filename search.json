[{"categories":null,"content":"本文述说了动态反射库Ponder中的组织结构。\nValue 所有的动态反射库中，总是有一种能够存储任意类型的类（用来对标std::any）。meta中就叫any，而Ponder中是Value。\n这种any类最简单的实现通常包含两个数据：\n1 2 3 4 5 6 7 class any { public: ... private: void* data;\t// 用于存储擦除了类型的数据 TypeInfo typeinfo; // 用于存储此数据对应的类型信息 }; 而在Ponder中的实现则更加复杂：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // include/ponder/value.hpp 72 class PONDER_API Value { public: ... 一些操作函数，不是重点，忽略 static const Value nothing; private: typedef mapbox::util::variant\u003c NoType, bool, long, double, ponder::String, EnumObject, UserObject \u003e Variant; Variant m_value; // Stored value ValueKind m_type; // Ponder type of the value }; Variant是对标std::variant的类型，存储了Value所有可能的类型\nValueKind则是一个枚举，用来告知m_value目前代表什么类型：\n1 2 3 4 5 6 7 8 9 10 11 12 // include/ponder/type.hpp 65 enum class ValueKind { None, ///\u003c No type has been defined yet Boolean, ///\u003c Boolean type (`bool`) Integer, ///\u003c Integer types (`unsigned`,`signed` `char` `short` `int` `long`) Real, ///\u003c Real types (`float`, `double`) String, ///\u003c String types (`char*`, `ponder::String`) Enum, ///\u003c Enumerated types Array, ///\u003c Array types (`T[]`, `std::vector`, `std::list`) User ///\u003c User-defined classes }; 各种类型的定义 注意到Value中Variant\u003c...\u003e的模板参数，除了布尔，整数（统一用long存储），浮点数（统一用double存储）之外，还有三种自定义类型：\nponder::String：用于存储字符串类型，其具体类型由用户通过定义宏自己选择（std::string或string_view），具体实现见include/ponder/detail/idtraits.hpp。这里的string_view是作者自己实现的，因为Ponder的标准是C++14。 EnumObject：对枚举类型特化的类，用于存储枚举值 UserObject：对类类型特化的类，用于存储类对象 EnumObject与Enum EnumObject是很简单的结构，用于存储枚举值和其名称，可以获得其值和名称：\n1 2 3 4 5 6 7 8 9 10 11 12 // include/ponder/enumobject.hpp class PONDER_API EnumObject { public: ... 一些操作，不细说了 private: long m_value; /// 此枚举量的值 const Enum* m_enum; ///\u003c 此枚举值对应的枚举类型信息 }; Enum则是存储一个枚举类型信息的类，主要成员为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // include/ponder/enum.hpp class PONDER_API Enum : public Type { PONDER__NON_COPYABLE(Enum);\t// 这个宏指定此类不可被拷贝，其实是禁用了类的拷贝\u0026复制运算符 typedef long EnumValue; // 要存储的枚举值的类型 ... 一些操作，不细说了 private: Enum(IdRef name);\t// 构造函数，给入这个枚举类型的名称 typedef detail::Dictionary\u003cId, IdRef, EnumValue\u003e EnumTable; Id m_name; ///\u003c 枚举类型的名称 EnumTable m_enums; ///\u003c 此枚举类型里面的枚举值们 }; 所有的枚举值使用EnumTable存储，这是作者自己造的一个哈希表，文档中说对Cache更友好。里面存储着枚举值的名称（默认是字符串，也是可以通过宏更改）和枚举值。\nUserObject与Class UserObject的结构也很简单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // include/ponder/userobject.hpp class PONDER_API UserObject { public: ... 一些接口，不细说了 private: friend class Property; // 将一个值设置给类的属性 void set(const Property\u0026 property, const Value\u0026 value) const; UserObject(const Class* cls, detail::AbstractObjectHolder* h) : m_class(cls) , m_holder(h) {} /// 类的类型信息 const Class* m_class; /// 类对象的存储类 std::shared_ptr\u003cdetail::AbstractObjectHolder\u003e m_holder; }; 这里Class存储类的类型信息。detaul::AbstractObjectHolder则是抽象类，用于存储一个类对象。\nClass的定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // include/ponder/class.hpp class PONDER_API Class : public Type { PONDER__NON_COPYABLE(Class); // Structure holding informations about a base metaclass struct BaseInfo { const Class* base; int offset; }; // These are shared_ptr as the objects can be inherited. When this happens the // pointers are copied. typedef std::shared_ptr\u003cConstructor\u003e ConstructorPtr; typedef std::shared_ptr\u003cProperty\u003e PropertyPtr; typedef std::shared_ptr\u003cFunction\u003e FunctionPtr; typedef std::vector\u003cBaseInfo\u003e BaseList; typedef std::vector\u003cConstructorPtr\u003e ConstructorList; typedef detail::Dictionary\u003cId, IdRef, PropertyPtr\u003e PropertyTable; typedef detail::Dictionary\u003cId, IdRef, FunctionPtr\u003e FunctionTable; typedef void (*Destructor)(const UserObject\u0026, bool); typedef UserObject (*UserObjectCreator)(void*); std::size_t m_sizeof; // Size of the class in bytes. Id m_id; // Name of the metaclass FunctionTable m_functions; // Table of metafunctions indexed by ID PropertyTable m_properties; // Table of metaproperties indexed by ID BaseList m_bases; // List of base metaclasses ConstructorList m_constructors; // List of metaconstructors Destructor m_destructor; // Destructor (function able to delete an abstract object) UserObjectCreator m_userObjectCreator; // Convert pointer of class instance to UserObject ... 一些操作，不细说了 }; Class中存储着：\nm_sizeof：此类的大小 m_id：此类的ID（一般是字符串，也就是此类的名称） m_functions：此类中的函数，使用作者自制的哈希表存储 m_properties：此类中的成员变量，使用作者自制的哈希表存储 m_bases：父类信息 m_constructors：构造函数信息 m_destructor：析构函数信息 m_userObjectCreator： Property信息 Property是存储类中成员变量信息的类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class PONDER_API Property : public Type { PONDER__NON_COPYABLE(Property); public: virtual ~Property(); IdReturn name() const; ValueKind kind() const; virtual bool isReadable() const; virtual bool isWritable() const; Value get(const UserObject\u0026 object) const; void set(const UserObject\u0026 object, const Value\u0026 value) const; virtual void accept(ClassVisitor\u0026 visitor) const; protected: template \u003ctypename T\u003e friend class ClassBuilder; friend class UserObject; Property(IdRef name, ValueKind type); virtual Value getValue(const UserObject\u0026 object) const = 0; virtual void setValue(const UserObject\u0026 object, const Value\u0026 value) const = 0; private: Id m_name; // Name of the property ValueKind m_type; // Type of the property }; 存储的是成员变量的名称和类型。我特意将set()和get()函数的声明留下，这说明这个类是可以设置/获得成员变量值的类型的。但是他本身是没有存储变量名称的，所以有一些函数\n","description":"","tags":["cpp"],"title":"【模板元编程和反射】：Ponder中的组织结构","uri":"/posts/%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E5%92%8C%E5%8F%8D%E5%B0%84ponder%E4%B8%AD%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/"},{"categories":null,"content":"本文述说了基于约束的物理求解器，这是很多游戏物理引擎的核心。\n理解约束 **约束(constraints)**是游戏物理引擎中的核心概念。\n当物体在做曲线运动时，设定曲线的方程为$C(x, y)$，当物体在曲线上时满足$C(x,y)=0$\n这叫做位置约束，物体在运动时要满足这个约束方程才行。\n物理引擎中的约束求解器不能求解位置约束，但可以求解速度约束。求$C(x,y)$的全导数可以得到速度： $$ \\dot{C}(x,y) = 0 $$\n求解纯圆周运动的约束 那么接下来通过一个具体场景来计算约束：物体被连杆连接在固定点，物体做圆周运动：\n很显然，这里的位置约束为：物体$P_1$到固定点$P_2$的距离总是连杆的长度$l$，那么有： $$ C(x, y):\\lVert P_1 - P_2 \\rVert-l = 0 $$ 这里$P_1 - P_2$在物理中是物体相对于固定点$P_2$的相对位置我们记为$P_{21}$。那么约束变为： $$ C(P_{21}):\\lVert P_{21} \\rVert -l =0 $$ 我们的约束求解器只能对速度求解，所以对$C(P_{21})$对时间求导得到速度： $$ \\dot{C}(P_{21}):(\\dot{\\lVert P_{21} \\rVert - l}) =\\dot{\\lVert P_{21} \\rVert}=\\dot{\\sqrt{P_{21} \\cdot P_{21}}}=\\frac{2P_{21}\\dot{P_{21}}}{2\\sqrt{P_{21} \\cdot P_{21}}} = 0 $$ 那么可以知道 $$ \\dot{C}(P_{21}):P_{21}\\dot{P_{21}}=(P_1 - P_2)(\\dot{P_1}-\\dot{P_2})=0 \\tag{*} $$ 由于 $$ \\dot{P_i} = v_i + \\omega_i \\times r_i $$ （$\\dot{P_i}$是位置的导数也就是速度，$v_i$是物体本身速度，$\\omega_i \\times r_i$是旋转的线速度)，所以我们得到： $$ \\dot{C}(v_1,q_1,v_2,q_2):(P_1-P_2)\\cdot(v_1 + \\omega_1 \\times r_1 - v_2 - \\omega_2 \\times r_2) = 0 $$ 把里面的东西进行移项(注：使用了混合积定律$A\\cdot (B\\times C)=C\\cdot (A\\times B)=B\\cdot (C\\times A)$)，得到： $$ (P_1 - P_2)\\cdot v_1 + (r_1 \\times (P_1 - P_2)) \\cdot \\omega_1 - (P_1 - P_2)\\cdot v_2 + (r_2 \\times (P_1 - P_2)) \\cdot \\omega_2 = \\begin{bmatrix} (P_1 - P_2) \\\\ (r_1 \\times (P_1 - P_2)) \\\\ -(P_1 - P_2) \\\\ -(r_2 \\times (P_1 - P_2)) \\end{bmatrix}^T \\begin{bmatrix} v_1 \\\\ \\omega_1 \\\\ v_2 \\\\ \\omega_2 \\end{bmatrix} = J_cv = 0 $$ 这里的$J_c$被称为Jacobian。$v$则是一个囊括了$P_1,P_2$的线速度，角速度的矩阵。$\\lambda$则被称为拉格朗日乘子( Lagrange multiplier)。因为$J_c\\cdot v =0$，所以$J_c$一定垂直于$v_1$($v_2$)，并且从$P_1$指向$P_2$($P_2$指向$P_1$)。\n这里，$*$式中的$P_1 - P_2$被称为约束轴(constraint axis)，$\\dot{P_1} - \\dot{P_2}$则是两者的相对速度。这里将相对速度投影到约束轴上来看约束轴到底能多快地被破坏。而这个方程等于0则说明我们希望最后在约束轴上的相对速度保持不变，以此来保持约束不被破坏：\n加入$\\beta$ 就算物体满足了约束$C(x, y)=0$，他也没办法将物体恢复到正确的位置上（我们仅仅是解出这个方程而已，物体的位置仍然没变）。所以需要有一个速度给物体拉回去，那么$J_c$方向上的就不应该是0。那么让我们添加一个$J_c$方向上的速度$v_2$： $$ J_c \\cdot (v +v_2) = J_c \\cdot v +J_c \\cdot v_2 = 0 $$ 这里$J_c \\cdot v_2$一定不是0，令其为$\\epsilon$，得到最后的式子： $$ J_c \\cdot (v +v_2) = J_c \\cdot v + \\epsilon = 0 $$ $\\epsilon$在这里的理解是当前速度到约束下速度之间的误差。\n那么这个$\\epsilon$在我们的连杆系统下到底是多少呢？要想将物体拉回去，物体的速度应该是： $$ v = -\\frac{\\lVert P_{12} \\rVert - l}{\\Delta t} $$ 但你不能真的使用这个速度，因为在实际编码中（下面说到的$SI$求解器中）会在一帧内使用多次这个速度。所以我们需要适当地降低这个速度。提供一个$\\beta \\in (0, 1)$来减弱$v$： $$ \\epsilon = -\\frac{\\lVert P_{12} \\rVert - l}{\\Delta t} \\beta $$ 这个方法一般被称为Baumgarte stabilization，他的通用表示和约束方程$C$有关： $$ \\epsilon = -\\frac{C}{\\Delta t} \\beta $$\n一般来说，为了之后求解方便，会将$\\epsilon$移动到等号右边去（我们下面也按照这个公式推导）： $$ J_c\\cdot v = \\epsilon \\ \\epsilon = \\frac{C}{\\Delta{t}} \\beta, \\beta \\in [0, 1] $$\n求解最后应施加的力 最后我们来求解整个约束应该施加给物体的力。\n在曲线运动下，只有一个约束力$F_c$从$P_1$指向$P_2$。巧了，我们的$J_c$也是这个方向，那么显然有一个常数$\\lambda$，使得 $$ F_c = \\lambda J_c^T \\tag{1} $$ （注：为什么是$J_c^T$？，因为$J_c$是行向量，我们这里所有的向量表示都是列向量）由牛顿第二定律，又有： $$ F = M\\dot{V}\\ F_c +F_{ext} = M\\dot{V} \\tag{2} $$ $F_{ext}$是除了约束力之外的力。$\\dot{V}$在这里是物体线速度，角速度的矩阵导数： $$ \\dot{V} = \\begin{bmatrix} v_1 \\\\ \\omega_1 \\\\ v_2 \\\\ \\omega_2 \\end{bmatrix}' $$ 注意，因为$\\dot{V}$中存在角速度$\\omega_i$，所以$F_c$和$F_{ext}$其实是表示两种力——力和力矩： $$ F = \\begin{bmatrix} F_1 \\\\ \\tau_1 \\\\ F_2 \\\\ \\tau_2 \\end{bmatrix} $$ 那么有： $$ \\lambda J_c^T = M\\dot{V} \\\\ \\lambda J_c^T + F_{ext} = M\\dot{V} $$ 矩阵$M$则是和线速度，角速度对应的质量矩阵： $$ M=\\begin{bmatrix} m_1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 I_1 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 m_2 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 I_2 \\end{bmatrix} $$ 其中$m_i$是质量， $I_i$是转动惯量。这四个元素分别对应$\\dot{V}$里的线速度和角速度。\n那么$\\dot{V}$如何解？假设两帧之间时间极短，那么可以用平均速度代替导数： $$ \\dot{V}=\\frac{V_{new} - V_{old}}{\\Delta t} $$ 其中$V_{new}$是下一帧应该有的速度，$V_{old}$是这一帧的速度。根据“加入$\\beta$”一节，我们知道$J_c\\cdot V_{new} = \\epsilon$，所以有： $$ \\Delta{t} \\dot{V} = V_{new} - V_{old} \\\\ J_c\\Delta{t} \\dot{V} = J_c\\cdot V_{new} - J_c\\cdot V_{old} \\\\ J_c\\cdot \\dot{V} \\Delta{t} + J_c\\cdot V_{old} = \\epsilon \\\\ \\tag{3} $$ 然后由$1$，$2$式可得$\\dot{V}$： $$ \\lambda J_c^T + F_{ext} = M\\dot{V} \\\\ \\dot{V} = M^{-1}(\\lambda J_c^T + F_{ext}) $$ 然后把这个式子带入$3$式： $$ J_c\\cdot V_{old} + J_cM^{-1}(\\lambda J_c^T + F_{ext})\\Delta{t} = \\epsilon \\\\ J_cM^{-1}J^{T}\\lambda = \\frac{\\epsilon}{\\Delta{t}}-J_c(\\frac{V_{old}}{\\Delta{t}}+M^{-1}F_{ext}) $$ 那么令： $$ A = J_cM^{-1}J^{T} \\\\ b = \\frac{\\epsilon}{\\Delta{t}}-J_c(\\frac{V_{old}}{\\Delta{t}}+M^{-1}F_{ext}) $$ 这样问题就变成了求解函数： $$ A\\lambda = b $$ 注意：实际求解的时候$M^{-1}$其实就是： $$ M^{-1} =\\begin{bmatrix} 1/m_1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 1/I_1 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 1/m_2 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1/I_2 \\end{bmatrix} $$ 不需要真的按公式计算逆矩阵（什么，你的质量是0？那给个1就行了）。\n在计算机中，解这个方程可以用Gauss–Seidel方法或者Jacobi等方法。我看的所有参考中都是用Gauss-Seidel算法解的，所以就用这个方法解吧。\nSI(Sequential-Impulse)求解器 使用上述方法求解的求解器称为SI求解器：\n首先，我们的公式是在圆周运动下推导的。而任意曲线运动在某一时刻都可以视为圆周运动，所以这个推导过程是可以在每一帧使用的。\n其次，我们在算$\\dot{V}$的时候说“在时间很小的情况下可以用近似”，所以增加物理引擎的精度的一个方法就是将一份时间拆成多段迭代计算，段数越多越准。\n具体做法是：\n将所有非约束力全部应用在物体上，得到一个猜测的速度 依次计算所有$\\lambda$并将所有约束力应用在物体上，用来矫正速度 使用最后的速度来更新物体位置 上面的第二步在一帧内要一直做，直到满足当中一个条件：\n没有约束力产生或约束力特别小 达到了一定步数（避免死循环或时间过长） 约束类型 距离约束（Distance Constraint） 这种约束需要两个物体总是保持一定距离，比如我们上面举的连杆的例子。这里再稍稍拓宽一点：之前都是将$P_1$和$P_2$视为质点。这里如果加上刚体的话$P_1 - P_2$则是连杆两端的距离：\n接触约束（Contact Constraint） 这种约束是当物体产生接触时，将两个物体分离开的约束。\n其中$P_1 - P_2$被替换成接触面的法向量。那么$J_c$变为： $$ J_c = \\begin{bmatrix} -n \\\\ -(r_a \\times n) \\\\ n \\\\ (r_b \\times n) \\end{bmatrix}^T $$\n那这里的恢复向量就是： $$ v = \\frac{d}{\\Delta t}bias $$ $d$是相交深度。\n如果物体b是静态物体（无论怎样都不移动的），$J_c$可变为： $$ J_c = \\begin{bmatrix} -n \\\\ -(r_a \\times n) \\\\ 0 \\\\ 0 \\end{bmatrix}^T $$\nA的求解细节 我在看Box2D-Lite源码的时候发现了他对A的求解方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void Arbiter::PreStep(float inv_dt) { const float k_allowedPenetration = 0.01f; float k_biasFactor = World::positionCorrection ? 0.2f : 0.0f; for (int i = 0; i \u003c numContacts; ++i) { Contact* c = contacts + i; Vec2 r1 = c-\u003eposition - body1-\u003eposition; Vec2 r2 = c-\u003eposition - body2-\u003eposition; // Precompute normal mass, tangent mass, and bias. float rn1 = Dot(r1, c-\u003enormal); float rn2 = Dot(r2, c-\u003enormal); float kNormal = body1-\u003einvMass + body2-\u003einvMass;\t// kNormal就是A kNormal += body1-\u003einvI * (Dot(r1, r1) - rn1 * rn1) + body2-\u003einvI * (Dot(r2, r2) - rn2 * rn2); c-\u003emassNormal = 1.0f / kNormal; ... } 看17行，这里没有用叉乘算$r_a \\times n$，因为$r_a \\times n = \\lVert r_a \\rVert \\sin{\u003cr_a, n\u003e}$，所以他算出三角形斜边$\\lVert r_a \\rVert$和临边$r_a \\cdot n$然后用三角函数直接解出来了，没有用叉乘（代码中是Dot(r1, r1) - rn1 *rn1）。\n参考 必看！一文将所有知识点全部说完，但有些地方可能不是很容易理解，可看辅助材料：\nMTamis_ConstraintBasedPhysicsSolver.pdf (mft-spirit.nl)\n其他辅助材料：\nModeling and Solving Constraints (box2d.org)\nVideo Game Physics Tutorial - Part III: Constrained Rigid Body Simulation | Toptal®\n2017 Tutorial 3 - Constraints.pdf (ncl.ac.uk)\nPhysics - Constraints and Solvers.pdf\n","description":"","tags":["game physics"],"title":"基于约束的物理求解","uri":"/posts/%E5%9F%BA%E4%BA%8E%E7%BA%A6%E6%9D%9F%E7%9A%84%E7%89%A9%E7%90%86%E6%B1%82%E8%A7%A3/"},{"categories":null,"content":"本文简述了std::shared_ptr可以通过在父类析构函数非虚的情况下，通过父类指针正确释放子类的特点，以及一个简单实现。\n现象 今天在知乎上看到了这个问题，就记录一下：\n首先，对于两个类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Parent { public: ~Parent() { std::cout \u003c\u003c \"parent\" \u003c\u003c std::endl; } }; class Child: public Parent { public: ~Child() { std::cout \u003c\u003c \"child\" \u003c\u003c std::endl; } }; 如果父类析构函数不是虚函数，那么使用父类指针指向子类并析构不会调用子类的析构函数（因为没有虚函数表，找不到子类的析构函数）：\n1 2 3 4 Parent* p = new Child{}; delete p; // 输出 parent 但是std::shared_ptr是可以做到正确释放的：\n1 2 std::shared_ptr\u003cParent\u003e p = std::make_shared\u003cChild\u003e(new Child{}); p.reset(); 因为std::shared_ptr内部存储了子类的信息，可以正确释放。\n简单实现 我们自己要实现std::shared_ptr的话可以将指针从父类转换成子类，然后调用子类的析构函数来正确析构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 template \u003ctypename T\u003e class DestructWithBases final { public: template \u003ctypename U\u003e struct traits { static void destruct(T* ptr) { delete (static_cast\u003cU*\u003e(ptr)); } }; template \u003ctypename U\u003e DestructWithBases(U* u): value_(u), destruct_(traits\u003cU\u003e::destruct) { } ~DestructWithBases() { destruct_(value_); } T* operator-\u003e() { return value_; } private: T* value_; void(*destruct_)(T*); }; 这里traits::destruct会将父类指针转换为对应子类，然后析构。在构造函数时将对应函数记录下来即可（拷贝和移动构造也要记录，但是我懒得写了）\n","description":"","tags":["cpp"],"title":"std::shared_ptr为何能正确释放子类指针","uri":"/posts/stdshared_ptr%E4%B8%BA%E4%BD%95%E8%83%BD%E6%AD%A3%E7%A1%AE%E9%87%8A%E6%94%BE%E5%AD%90%E7%B1%BB%E6%8C%87%E9%92%88/"},{"categories":null,"content":"本文述说了基于匹配的模板以及常见模板小工具type_list。\n本章的type_list实现代码在mirrow的type_list.hpp中。可自行参考。\n基于匹配的模板 C++的模板是基于匹配的，也就是说在实例化的时候会尝试匹配所有存在的模板。直到所有模板都不匹配才会报错。\n类型萃取 类型萃取就是使用这种规则的模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // (1) template \u003ctypename T\u003e struct remove_one_pointer { using type = T; }; // (2) template \u003ctypename T\u003e struct remove_one_pointer\u003cT*\u003e { using type = T; }; template \u003ctypename T\u003e using remove_pointer_t = typename remove_one_pointer\u003cT\u003e::type; int main() { using type1 = remove_pointer_t\u003cint\u003e;\t// type -\u003e int using type2 = remove_pointer_t\u003cint*\u003e;\t// type -\u003e int using type3 = remove_pointer_t\u003cint**\u003e;\t// type -\u003e int* return 0; } “萃取”是化学中的术语，意思是将某种混合物中的东西分离出来。这里的remove_one_pointer会移除一层指针，如果类型不是指针则会保留原本类型。\n这里的type1给入的类型是int，编译器会先去匹配特化模板*(2)，发现不能将int作为其模板参数（其模板参数需要一个指针T*），于是去匹配(1)*这个非特化模板，得到类型type = int。\n而type2给入的类型是int*，匹配*(2)的时候传入一个int*，这个int*会匹配到9行的struct remove_on_pointer\u003cT*\u003e中的T*，而(2)*中的模板参数（我指typename T这个T）是T，所以T*会是int*而T变为int。这样就成功萃取出来了。\ntype3也是同理，9行的struct remove_on_pointer\u003cT*\u003e中的T*会匹配到int**，然后注意到T是去掉一层指针（如果写struct remove_on_pointer\u003cT**\u003e就是去掉两个），所以T会是int*而不是int。\n萃取有个固定写法：\n确定你需要对哪个类进行萃取，比如我们需要对一个特定的类std::list\n确定你要对他的哪个模板参数进行萃取。std::list的声明是：\n1 2 3 4 template\u003c class T, class Allocator = std::allocator\u003cT\u003e \u003e class list; 有两个模板参数T和Allocator，比如我们要得到T\n将需要萃取的类型的所有模板参数写在template \u003c\u003e声明中，并在特化部分将此类型用上，然后在结构体内用using type = XXX得到你想要的类型：\n1 2 3 4 5 6 7 8 template \u003ctypename T\u003e // 要萃取T，我们这里写一个T struct get_list_element_type;\t// 先写一个声明，声明不做任何事情 template \u003ctypename T, typename Allocator\u003e struct get_list_element_type\u003cstd::list\u003cT, Allocator\u003e\u003e { using type = T; // using allocator = Allocator;\t// 想要保存Allocator的类型？也可以 }; 使用时，直接将类型放入你写的萃取中就行了：\n1 2 3 4 5 6 7 using type = typename get_list_element_type\u003cstd::list\u003cint\u003e\u003e::type;\t// int // 一般会给一个更加方便的using来节省打字时间： template \u003ctypename T\u003e using get_list_element_type_t = typename get_list_element_type\u003cT\u003e::type; using type = get_list_element_type_t\u003cstd::list\u003cint\u003e\u003e; 当然这里只是个例子，对于std::list来说，标准库很贴心地在其内部早就存下了元素类型std::list\u003cT\u003e::value_type和内存分配器类型std::list\u003cT\u003e::allocator_type。\n将模板看做编译期的函数 上面的get_list_element_type我们可以看做是对类型操作的函数：\n1 2 3 using type = get_list_element_type_t\u003cyour-list\u003e; // 你不觉得很像： auto type = get_list_element_type_t(your-list); 模板参数作为入参，模板内的type或者value作为返回值。\n不只是萃取，你可以写其他的模板来对类型/编译期值进行操作：\n1 2 3 4 5 6 7 template \u003csize_t Idx\u003e struct inc_idx { static constexpr size_t value = Idx + 1; }; template \u003csize_t idx\u003e constexpr size_t inc_idx_v = inc_idx\u003cIdx\u003e::value; 这里inc_idx会将value+1。\n标准库也有一些类似的做法，比如std::conditional_t可以做编译时if。\ntype_list小工具 在很多反射和模板元编程框架中(Refl-Cpp，Ubp.a USRefl)都会有type_list小工具。这个工具顾名思义，是编译时存储和操作一组类型的列表。\n模板元编程在很大程度上和函数式编程有着极为密切的关系。而我们这里的type_list实现也是仿造函数式编程，尤其是Haskell中list的实现。\ntype_list的用法 首先来看一下这个工具的用途（一部分）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 using list = type_list\u003cint, char, float, double\u003e;\t// 声明一个类型列表 // list_element_t 用于从 type_list中获得第n个元素 static_assert(std::is_same_v\u003clist_element_t\u003clist, 0\u003e, int\u003e); static_assert(std::is_same_v\u003clist_element_t\u003clist, 1\u003e, char\u003e); static_assert(std::is_same_v\u003clist_element_t\u003clist, 2\u003e, float\u003e); static_assert(std::is_same_v\u003clist_element_t\u003clist, 3\u003e, double\u003e); // list_head_t 是仿照函数式编程中 head 函数，用于获得list开头的元素 static_assert(std::is_same_v\u003clist_head_t\u003clist\u003e, int\u003e); // list_size_v 用于获得list的大小 static_assert(list_size_v\u003clist\u003e == 4); // 一个谓词（谓词：函数式编程术语，即返回布尔值的函数），用于判断某个类型T是否是`int`，使用基于匹配的方法编写 template \u003ctypename T\u003e struct IsInt { static constexpr bool value = false; }; template \u003c\u003e struct IsInt\u003cint\u003e { static constexpr bool value = true; }; // disjunction_v，仿照std::disjunction，用于判断列表中是否至少有一个元素使得谓词返回true static_assert(disjunction_v\u003clist, IsInt\u003e); // conjunction_v，仿照std::conjunction，用于判断列表中是否所有元素使得谓词返回true static_assert(!conjunction_v\u003clist, IsInt\u003e); // list_filter_t，使用谓词过滤列表，所有满足谓词的元素会被保留下来 static_assert(std::is_same_v\u003clist_filter_t\u003clist, std::is_integral\u003e, type_list\u003cint, char\u003e\u003e); static_assert(std::is_same_v\u003clist_filter_t\u003ctype_list\u003c\u003e, std::is_integral\u003e, type_list\u003c\u003e\u003e); type_list的实现 type_list声明 首先是type_list的声明：\n1 2 template \u003ctypename... Ts\u003e struct type_list {}; 是一个空类，所有的类型信息全部记录在不定模板参数Ts中。\nlist_size_v的实现 接下来实现第一个函数，也是最简单的，list_size_v，用于获得type_list中元素个数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 namespace detail { // (1) template \u003ctypename\u003e struct list_size; // (2) template \u003ctemplate \u003ctypename...\u003e typename ListType, typename... Ts\u003e struct list_size\u003cListType\u003cTs...\u003e\u003e { static constexpr size_t value = sizeof...(Ts); }; }\t// namespace detail template \u003ctypename T\u003e static constexpr size_t list_size_v = detail::list_size\u003cT\u003e::value; 模板元编程中，习惯性的做法是将实现放在命名空间detail或者impl中，用户一般是不允许接触这种命名空间的（当然编译器并没有强制禁止，只是口头约定），然后在外部暴露一个便捷方法（这里是list_size_v）。\n这里的实现也很简单，依旧是基于匹配的模板方法：将要匹配到的模板类型中所有需要的类型参数（这里是type_list需要的参数，是*(2)*中的Ts）写在template \u003c\u003e中，然后在特化处struct list_size\u003c\u003e写上你需要的真正类型。\n这里其实可以写成：\n1 2 3 4 5 // (2) template \u003ctypename... Ts\u003e struct list_size\u003ctype_list\u003cTs...\u003e\u003e { static constexpr size_t value = sizeof...(Ts); }; 告诉list_size我们需要的参数是固定类型type_list。这里之所以写了模板模板参数template \u003ctypename...\u003e typename ListType是因为这样写可以匹配到std::tuple（因为tuple的模板声明也是template \u003ctypename... Ts\u003e class tuple{ ... };，通用性更好一些。如果你不需要就不用这样写。\n内部实现的话使用sizeof...对不定模板参数计数就行了。\n如果传入的类型T不可以接受不定模板参数Ts，那会匹配到*(1)*处的声明，编译器会发现类没有实现，所以会报一个类缺少实现的编译时错误。\nlist_head_t的实现 接下来实现一个复杂一点的。list_head_t通过给入一个type_list可以得到此list的第一个元素。如果type_list是空则编译无法通过。\n1 2 3 4 5 6 7 8 9 10 11 12 // (1) template \u003ctypename\u003e struct list_head; // (2) template \u003ctemplate \u003ctypename...\u003e typename ListType, typename T, typename... Remains\u003e struct list_head\u003cListType\u003cT, Remains...\u003e\u003e { using type = T; }; template \u003ctypename T\u003e using list_head_t = typename list_head\u003cT\u003e::type; *(1)处仍然是声明。(2)*处将type_list内元素拆分成两部分：第一个元素T以及剩下的所有元素Remains，然后通过匹配拿到第一个元素。\nlist_add_to_first的实现 list_add_to_first\u003cList, T\u003e会将元素T插入List的第一个位置上：\n1 2 3 4 5 6 7 8 9 10 template \u003ctypename List, typename T\u003e struct list_add_to_first; template \u003ctemplate \u003ctypename...\u003e typename ListType, typename... Ts, typename T\u003e struct list_add_to_first\u003cListType\u003cTs...\u003e, T\u003e { using type = ListType\u003cT, Ts...\u003e; }; template \u003ctypename List, typename T\u003e using list_add_to_first_t = typename list_add_to_first\u003cList, T\u003e::type; 具体实现中通过将新元素T和老元素们Ts放在一个ListType中并返回。\nlist_element_t的实现 看了上面三个例子后，对如何使用模板参数以及如何匹配想必已经有一定的了解了。接下来看一点不一样的。\nlist_element_t\u003cListType, Idx\u003e可以取得ListType中第Idx个元素：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 template \u003ctypename T, size_t Idx\u003e\t// 这里的模板参数没用到可以省略，但我还是写出来以便于下面解说 struct list_element; // (1) template \u003ctemplate \u003ctypename...\u003e typename ListType, typename T, typename... Ts, size_t N\u003e struct list_element\u003cListType\u003cT, Ts...\u003e, N\u003e : list_element\u003cListType\u003cTs...\u003e, N - 1\u003e {}; // (2) template \u003ctemplate \u003ctypename...\u003e typename ListType, typename T, typename... Ts\u003e struct list_element\u003cListType\u003cT, Ts...\u003e, 0\u003e { using type = T; }; 这里用了递归式模板：*(2)*中定义递归结束条件：当Idx==0的时候，直接返回ListType的第一个元素。\n而*(1)*中则进行递归：我们构造传入ListType的子列表作为下一次递归的开始（这个列表只是将第一个元素移除了），并将Idx - 1：\n1 2 3 4 5 6 7 8 9 10 假设有type_list: tl = int char float double 我们要拿到下标为2的元素，也就是float： Idx = 2 调用list_element_t: list_element\u003ctype_list\u003cint, char, float, double\u003e, 2\u003e 第一次递归的调用： list_element\u003ctype_list\u003cchar, float, double\u003e, 1\u003e 第二次递归的调用： list_element\u003ctype_list\u003cfloat, double\u003e 0\u003e 这时Idx == 0，匹配到(2)处的特化模板，现在list_element结构体里有T = float了。 这里*(1)处的继承并没有任何面向对象里as-is*的意思，单纯地就是将数据聚拢在一起。一般在模板元编程中，类如果都是空的话，比较趋向于使用集成将信息组合到一起。\nlist_foreach_t的实现 接下来我们要更加贯彻将模板视为编译期函数的原则。\nlist_foreach_t\u003cList, Pred\u003e通过给入一个Pred模板类，将这个类当做函数用在List的所有元素上从而创造一个新的List：\n1 2 3 4 5 6 7 8 9 10 11 template \u003ctypename List, template \u003ctypename\u003e typename F\u003e struct list_foreach { }; // (2) template \u003ctemplate \u003ctypename...\u003e typename ListType, template \u003ctypename\u003e typename F, typename... Ts\u003e struct list_foreach\u003cListType\u003cTs...\u003e, F\u003e { using type = ListType\u003ctypename F\u003cTs\u003e::type ...\u003e; }; template \u003ctypename List, template \u003ctypename\u003e typename F\u003e using list_foreach_t = typename detail::list_foreach\u003cList, F\u003e::type; *(2)*中的函数类型是template \u003ctypename\u003e typename F，表示接受一个模板参数，并且在7行的typename F\u003cTs\u003e::type也要求其内部有一个type类型作为返回值。比如：\n1 2 3 4 template \u003ctypename T\u003e struct AddPointer { using type = T*; }; 就是合法的，可以这样用：\n1 list_foreach_t\u003ctype_list\u003cint, char\u003e, AddPointer\u003e 其他 对于type_list还有很多函数可以编写，比如筛出其中某个元素，将type_list倒置等。但最基本的写法和例子都写在上面了。完整代码可去github上看一下。\n","description":"","tags":["cpp"],"title":"【模板元编程和反射】（一）：type_list","uri":"/posts/%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E5%92%8C%E5%8F%8D%E5%B0%84%E4%B8%80type_list/"},{"categories":null,"content":"本文分析了开源项目EnTT v3.12.2的原理和实现。述说了ECS中的核心数据结构storage。\nstorage storage是在sparse_set上进行封装的类，主要用于将组件(component)和实体(entity)关联起来。\n有两种storage，第一种是最通用的一种，用于关联实体和组件：\n1 2 3 //\u003e src/entt/storage.hpp 235 template\u003ctypename Type, typename Entity, typename Allocator, typename\u003e class basic_storage: public basic_sparse_set\u003cEntity, typename std::allocator_traits\u003cAllocator\u003e::template rebind_alloc\u003cEntity\u003e\u003e { ... } 回忆一下sparse set的结构，存在一个packed数组和一个sparse数组。而storage则是在其上加了一个payload数组用于存储组件：\n1 2 3 4 5 6 7 8 9 storage: payloads: _ _ _ packed : _ _ _ sparse : _ _ _ 插入实体1和组件V: payloads: V _ _ packed : 1 _ _ sparse : _ 0 _ 插入的组件会放在和实体一样下标的payloads数组中。删除实体的时候也会一并删除。也就是说，相同下标的payloads和packed数组元素是一一对应的（组件和实体一一对应）。\n理论上是这样，但为了更高效地分配/释放内存，EnTT还是使用了分页的机制去分配payload，也就是说会一次性分配一页（默认是1024个（在src/entt/config/config.hpp 34处的ENTT_PACKED_PAGE））。\n第二种是用于纯粹存储实体的storage，使用偏特化实现：\n1 2 3 //\u003e src/entt/storage.hpp 955 class basic_storage\u003cEntity, Entity, Allocator\u003e : public basic_sparse_set\u003cEntity, Allocator\u003e { ... } 里面的函数基本上都是basic_sparse_set的函数包装了一下，但是做了实体的复用操作。\n其实还有一个偏特化，是用于“当组件为空类”的特殊情况的。这个时候并没有payloads数组（因为组件是空类，没必要实例化），主要是为了节省内存。这种实现对于tag类来说很有帮助：\n1 2 3 4 5 6 // 一个tag类，只是为了标记某个entity是玩家操控的而已 struct Player {}; registry.emplace\u003cPlayer\u003e(entity); // 之后可在system中对含有Player类的entity进行特殊操作（比如按键响应等） 偏特化声明如下：\n1 2 3 //\u003e src/entt/storage.hpp 780 template\u003ctypename Type, typename Entity, typename Allocator\u003e class basic_storage\u003cType, Entity, Allocator, std::enable_if_t\u003ccomponent_traits\u003cType\u003e::page_size == 0u\u003e\u003e 注意到最后那个component_traits\u003cType\u003e::page_size == 0u就是用来判断组件类型Type是否是空类。\n细节实现 component_traits 先看一下component_traits，这个东西会决定组件分配的页大小，所有的代码都在src/entt/entity/component.hpp下：\n1 2 3 4 5 6 7 8 9 10 11 12 template\u003ctypename Type, typename = void\u003e struct component_traits { static_assert(std::is_same_v\u003cstd::decay_t\u003cType\u003e, Type\u003e, \"Unsupported type\"); /*! @brief Component type. */ using type = Type; /*! @brief Pointer stability, default is `false`. */ static constexpr bool in_place_delete = internal::in_place_delete\u003cType\u003e::value; /*! @brief Page size, default is `ENTT_PACKED_PAGE` for non-empty types. */ static constexpr std::size_t page_size = internal::page_size\u003cType\u003e::value; }; type：就是组件本身的类型\nin_place_delete：是否可以就地删除，实现是:\n1 2 template\u003ctypename Type, typename = void\u003e struct in_place_delete: std::bool_constant\u003c!(std::is_move_constructible_v\u003cType\u003e \u0026\u0026 std::is_move_assignable_v\u003cType\u003e)\u003e {}; 主要是要求组件类型必须可以移动构造和移动赋值。\npage_size：组件分配一页的大小。实现是：\n1 2 3 4 5 6 7 8 9 template\u003ctypename Type, typename = void\u003e struct page_size: std::integral_constant\u003cstd::size_t, !std::is_empty_v\u003cENTT_ETO_TYPE(Type)\u003e * ENTT_PACKED_PAGE\u003e {}; template\u003c\u003e struct page_size\u003cvoid\u003e: std::integral_constant\u003cstd::size_t, 0u\u003e {}; template\u003ctypename Type\u003e struct page_size\u003cType, std::enable_if_t\u003cstd::is_convertible_v\u003cdecltype(Type::page_size), std::size_t\u003e\u003e\u003e : std::integral_constant\u003cstd::size_t, Type::page_size\u003e {}; 对于任意非void类型，使用!std::is_empty_v\u003cENTT_ETO_TYPE(Type)\u003e * ENTT_PACKED_PAGE得到一页的大小（其实就是如果Type是空类，那么大小为0，否则为ENTT_PACKED_PAGE）\n对于void类型直接为0（在第一个全特化版本中实现）\n最后一个使用SFINEA，当组件类型Type自己指定了页大小Type::page_size的时候，使用他的大小而不是默认的ENTT_PACKED_PAGE（当然Type::page_size要能转换为size_t）。\n非空组件类型的stroage的内存分配实现 由于storage的算法原理和sparse set一样，只是加了个payloads数组，所以算法部分就不再重复。我们着重关注一下EnTT是如何高效利用内存的。\n首先还是简单看一下类型声明：\n1 2 3 4 5 6 7 8 9 template\u003ctypename Type, typename Entity, typename Allocator, typename\u003e class basic_storage: public basic_sparse_set\u003cEntity, typename std::allocator_traits\u003cAllocator\u003e::template rebind_alloc\u003cEntity\u003e\u003e { using alloc_traits = std::allocator_traits\u003cAllocator\u003e; static_assert(std::is_same_v\u003ctypename alloc_traits::value_type, Type\u003e, \"Invalid value type\"); using container_type = std::vector\u003ctypename alloc_traits::pointer, typename alloc_traits::template rebind_alloc\u003ctypename alloc_traits::pointer\u003e\u003e; using underlying_type = basic_sparse_set\u003cEntity, typename alloc_traits::template rebind_alloc\u003cEntity\u003e\u003e; using underlying_iterator = typename underlying_type::basic_iterator; static constexpr bool is_pinned_type_v = !(std::is_move_constructible_v\u003cType\u003e \u0026\u0026 std::is_move_assignable_v\u003cType\u003e); 模板参数解释如下：\nType：组件类型 Entity：实体类型 Allocator：内存分配器 最后的typename指定的类型用于SFINEA，类里面并不会用到 using部分解释如下\nalloc_traits：使用标准库的allocator_traits得到的内存分配器类型信息 container_type：payloads的类型，是一个std::vector，元素是一页组件类型（默认是1024个Type*） underlying_type：其父类类型 underlying_iterator：其父类的迭代器类型 is_pinned_type_v：描述组件类是否是固定在内存中的类（即不可移动） 接下来看一下内存分配\n首先要知道traits_type：\n1 2 //\u003e src/entt/entity/storage.hpp 404 using traits_type = component_traits\u003cvalue_type\u003e; 然后着重看一下assure_at_least，这个函数确保在创建组件的时候payloads数组能有足够空间容纳：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //\u003e src/entt/entity/storage.hpp 249 auto assure_at_least(const std::size_t pos) { const auto idx = pos / traits_type::page_size; if(!(idx \u003c payload.size())) { auto curr = payload.size(); allocator_type allocator{get_allocator()}; payload.resize(idx + 1u, nullptr); ENTT_TRY { for(const auto last = payload.size(); curr \u003c last; ++curr) { payload[curr] = alloc_traits::allocate(allocator, traits_type::page_size); } } ENTT_CATCH { payload.resize(curr); ENTT_THROW; } } return payload[idx] + fast_mod(pos, traits_type::page_size); } 由于payloads内存的是一页，所以第三行先算一下页的下标。\n然后第五行判断一下payloads内的页数是否够用，够的话21行直接算出页内元素然后返回（顺便说一句，页内元素类型是Type*也就是组件的指针类型）。\n不够的话，68行对payload大小进行扩容，然后1113行的for循环对扩容后的页进行内存分配。这里顺便说一下这里的allocate函数，第一个参数是内存分配器，第二个参数是要分配的个数。这里是分配一页的组件。\n16~17行则是对异常的处理，如果内存分配抛出异常，则将payload回滚到之前的大小，并传递异常（很细节，在可能抛出异常的地方处理掉）。\n这里我就顺便说一下EnTT对于异常的态度。几乎90%的函数都不能抛出异常（使用noexcept制约），如果能否抛出异常和用户实现有关（EnTT内有很多地方允许用户给入自定义的类型），会使用type traits进行约束（比如noexcept(std::is_nothrow_constructable_v\u003cT\u003e)这种）。剩下的就是自己内部设计中会抛出异常的地方，这种函数不会有noexcept修饰。这里强调的是使用type traits配合noexcept达到跟随用户类型异常状态而改变自身函数抛出异常状态的灵活设计。\n然后看一下真正添加组件的地方：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //\u003e src/entt/entity/storage.hpp 271 template\u003ctypename... Args\u003e auto emplace_element(const Entity entt, const bool force_back, Args \u0026\u0026...args) { const auto it = base_type::try_emplace(entt, force_back); ENTT_TRY { auto elem = assure_at_least(static_cast\u003csize_type\u003e(it.index())); entt::uninitialized_construct_using_allocator(to_address(elem), get_allocator(), std::forward\u003cArgs\u003e(args)...); } ENTT_CATCH { base_type::pop(it, it + 1u); ENTT_THROW; } return it; } 这里第7行得到elem，然后第8行对这一块内存进行初始化（Allocator创建的内存是不会初始化的，这里会调用Type的构造函数进行初始化），简单看一下：\n1 2 3 4 template\u003ctypename Type, typename Allocator, typename... Args\u003e constexpr Type *uninitialized_construct_using_allocator(Type *value, const Allocator \u0026allocator, Args \u0026\u0026...args) { return std::apply([value](auto \u0026\u0026...curr) { return new(value) Type(std::forward\u003cdecltype(curr)\u003e(curr)...); }, internal::uses_allocator_construction\u003cType\u003e::args(allocator, std::forward\u003cArgs\u003e(args)...)); } 这里本质上是使用了emplacement new方法，在原有的内存上初始化类对象。EnTT在删除的时候也不是真的删除，而是调用类的析构函数，内存还是保留的。这样就增加了内存的复用率，减少了new/delete的开销。\n存储Entity的Storage对Entity的复用 对于纯粹存储Entity的storage，他使用了对Entity的复用。因为sparse set中删除整数并不会使整数的值减少，sparse数组中的内存会越来越多：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 增加元素1 packed: 1 sparse: _ 0 增加元素2 packed: 1 2 sparse: _ 0 1 删除元素1 packed: 2 sparse: _ _ 0 增加元素3 packed: 2 3 sparse: _ _ 0 1 可以发现增加元素3之后，sparse的容量还是会增大，这和是否删除元素无关，只要元素以递增的方式插入进来，sparse就会无限增大。\n之前我们说过EnTT中对实体的定义，实体是一个整数，被分为ID部分和版本号部分。复用的秘密就在这个版本号中。\nstorage有一个单独的length变量用于存储当前所有实体的个数（正在使用的+可复用的），整个复用流程如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 length = 0 packed: sparse: 创建三次实体： 创建实体时，如果没有可复用实体，会将packed.size()的值作为实体插入。所以创建三次会插入0, 1, 2 length = 3 packed: 0 1 2 sparse: 0 1 2 删除 1 length = 2 packed: 0 2 1/1\t这里的1/1代表ID为1，版本为1的实体。删除并不会真的删掉，而是将元素移动到 length-1 处并自增版本号，同时sparse也会更改 sparse: 0 2 1 创建新实体： 这时存在可复用实体，那么直接返回length处值即可 length = 3 packed: 0 2 1/1 sparse: 0 2 1 这里对的核心点在于，删除操作时会将删除的实体版本号+1然后移动到length-1处。在创建新实体时，会判断length \u003c packed.size()，如果小于，说明存在复用实体，就直接lenghth + 1并返回packed[length - 1]就行。\n","description":"","tags":["源码阅读","EnTT"],"title":"EnTT源码分析【四】：storage","uri":"/posts/entt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9B%9B/"},{"categories":null,"content":"本文分析了开源游戏框架Raylib v4.5.0中的batch rendering实现。\nRaylib是一个非常易用的游戏框架。其中90%的代码都是调库代码，只有渲染部分，作者自己封装了一个rlgl作为OpenGL的抽象层，里面比较有技术含量的就是他的Batch Rendering部分。\n注意：Raylib对各个版本的OpenGL（gl2,gl3,gles）都做了统一封装（在src/rlgl.h中），我们只分析gl3的代码。gl2的太老了就不看了，gles和gl3差不多，原理一样也就不分析了。\n什么是Batch Rendering 直译过来是“批渲染”，就是一次性渲染一堆数据。\n假设现在有一个TileMap，他需要从一张图上取多个区域绘制在屏幕上，每一个区域是矩形。如果不使用Batch Rendering，函数的可能形式如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void RenderOneTile(const Texture\u0026 texture, const Rect\u0026 region, const Rect\u0026 dst) { // 将数据传给GPU glBindBuffer(GL_ARRAY_BUFFER, RenderContext.buffer); glBufferData(GL_ARRAY_BUFFER, CreateRectData(region, dst), GL_STATIC_DRAW); // 绑定element buffer glBindBuffer(GL_ELEMENT_BUFFER, RenderContext.index_buffer); // 绑定Texture glBindTexture(GL_TEXTURE0, texture.id); // 准备渲染 glUseProgram(RenderContext.program); // 渲染 glDrawElements(GL_TRIANGLES, 0, 6, 0); } 也就是说，每一次渲染都需要将矩形的数据传递给GPU，然后绑定Texture，进行渲染。\n这里的性能缺陷主要是：\n数据传递给GPU：如果的多个Rect使用的是同一个Texture，那么我们可以将他们的数据全部存储起来，等到最后一并传给GPU 多次的DrawCall：这里每一个Rect都需要一次DrawCall。我们可以将数据全部存储起来，然后调用一次关于Rect的DrawCall就可以绘制全部。 Raylib中的Batch Rendering 重要数据结构 raylib自定义了可以绘制的类型：\n1 2 3 4 // Primitive assembly draw modes #define RL_LINES 0x0001 // GL_LINES #define RL_TRIANGLES 0x0004 // GL_TRIANGLES #define RL_QUADS 0x0007 // GL_QUADS 有三种。在绘制的时候，raylib会自行将相关的数据存储在一起，最后进行统一绘制。\nrlglData 重要的数据结构如下：\n1 2 3 4 5 typedef struct rlglData { rlRenderBatch *currentBatch; // Current render batch rlRenderBatch defaultBatch; // Default internal render batch ... } rlglData; rlglData中存储着整个Batch Rendering需要的数据，其最后是一个全局变量：\n1 static rlglData RLGL = { 0 }; 其中对Batch Rendering的数据定义是结构体rlRenderBatch：\n1 2 3 4 5 6 7 8 9 10 // rlRenderBatch type typedef struct rlRenderBatch { int bufferCount; // Number of vertex buffers (multi-buffering support) int currentBuffer; // Current buffer tracking in case of multi-buffering rlVertexBuffer *vertexBuffer; // Dynamic buffer(s) for vertex data rlDrawCall *draws; // Draw calls array, depends on textureId int drawCounter; // Draw calls counter float currentDepth; // Current depth value for next draw } rlRenderBatch; 成员解释如下：\nvertexBuffer,bufferCount和currentBuffer：分别指定了存储顶点数据的buffer(s)，以及当前的buffer下标，和vertexBuffer中buffer的数量 draws,drawCounter：draws代表一个DrawCall，而drawCounter则存储draws中有多少个rlDrawCall currentDepth：当前的深度值。当你在绘制2D图像的时候，后绘制的图像应该在先绘制的图像后面（z值要更大）。每次绘制的时候，顶点的z值就会应用这里的currentDepth，然后currentDepth会自动变大一些以实现前面的功能。 rlVertexBuffer 然后是存储顶点数据的rlVertexBuffer：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Dynamic vertex buffers (position + texcoords + colors + indices arrays) typedef struct rlVertexBuffer { int elementCount; // Number of elements in the buffer (QUADS) float *vertices; // Vertex position (XYZ - 3 components per vertex) (shader-location = 0) float *texcoords; // Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1) unsigned char *colors; // Vertex colors (RGBA - 4 components per vertex) (shader-location = 3) #if defined(GRAPHICS_API_OPENGL_11) || defined(GRAPHICS_API_OPENGL_33) unsigned int *indices; // Vertex indices (in case vertex data comes indexed) (6 indices per quad) #endif #if defined(GRAPHICS_API_OPENGL_ES2) unsigned short *indices; // Vertex indices (in case vertex data comes indexed) (6 indices per quad) #endif unsigned int vaoId; // OpenGL Vertex Array Object id unsigned int vboId[4]; // OpenGL Vertex Buffer Objects id (4 types of vertex data) } rlVertexBuffer; 结构解释如下：\nelementCount： vertices：顶点数据，由x,y,z三个分量组成 texcoords：顶点的纹理坐标，由u,v两个分量组成 colors：顶点颜色，由r,g,b,a四个分量组成 indices：顶点的索引 vaoId：OpenGL中Vertex Attributes的ID vboId[4]：OpenGL中的Buffer的ID，分别对应vertices，texcoords，colors和indices（也就是说前三个类型是GL_ARRAY_BUFFER，最后一个是GL_ELEMENT_BUFFER） 可以看出Raylib对Vertex的各信息组织是分开的，并用四个Buffer存储，不像Learning OpenGL教程中放在一起。\nrlDrawCall 然后看一下rlDrawCall：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Draw call type // NOTE: Only texture changes register a new draw, other state-change-related elements are not // used at this moment (vaoId, shaderId, matrices), raylib just forces a batch draw call if any // of those state-change happens (this is done in core module) typedef struct rlDrawCall { int mode; // Drawing mode: LINES, TRIANGLES, QUADS int vertexCount; // Number of vertex of the draw int vertexAlignment; // Number of vertex required for index alignment (LINES, TRIANGLES) //unsigned int vaoId; // Vertex array id to be used on the draw -\u003e Using RLGL.currentBatch-\u003evertexBuffer.vaoId //unsigned int shaderId; // Shader id to be used on the draw -\u003e Using RLGL.currentShaderId unsigned int textureId; // Texture id to be used on the draw -\u003e Use to create new draw call if changes //Matrix projection; // Projection matrix for this draw -\u003e Using RLGL.projection by default //Matrix modelview; // Modelview matrix for this draw -\u003e Using RLGL.modelview by default } rlDrawCall; 各结构解释如下：\nmode：绘制的类型，就是一开始说的三种类型 vertexCount：绘制所需的顶点数目，之后会直接应用在glDrawArrays()或glDrawElements()函数中 vertexAlignment：顶点的对齐 textureId：要绘制的图像 最后绘制的时候，对于每一个rlDrawCall，都会有一个DrawCall一次性将其中的所有数据全部绘制。\n这里要说一下vertexAlignment的作用。之前说过rlVertexBuffer.vboId[4]中最后一个Buffer是索引Buffer，但是不总是能用到这个Buffer（比如你要绘制不连续的三角形，或者很多条不连续的直线时，这个Buffer就完全无用（Raylib中就是当你的mode为RL_LINES或RL_TRIANGLES时），调用glDrawArrays()就好了）。那么如果用不到，常见的做法是在将顶点数据放入rlVertexBuffer中的时候，同时置索引Buffer处的索引为一个固定值：\n1 2 3 rlVertexBuffer::vertices : (1.0, 2.0, 3.0) (5.0, 6.0, 8.0) (10.0, 11.0, 12.0, 13.0) rlVertexBuffer::indices : -1 -1 6 7 8 7 8 9 是否使用： 不使用 不使用 使用，绘制一个矩形 但是Raylib使用了另一种方法：直接将索引Buffer初始化为绘制多个矩形的Buffer：\n1 rlVertexBuffer::indices ： 0 1 2 1 2 3 4 5 6 5 6 7 8 9 10 9 10 11 ... 每六个元素代表绘制一个矩形。那么你将数据放入rlVertexBuffer::vertices/texcoords/colors中的时候，就需要和indices对齐。比如我现在要绘制一个矩形，那我直接将数据放入即可：\n1 2 3 rlVertexBuffer::vertices : v0 v1 v2 v3 rlVertexBuffer::indices : 0 1 2 1 2 3 4 5 6 5 6 7 是否使用indces:\t会使用 如果我接下来要绘制一个单独的三角形呢？依旧将数据放入：\n1 2 3 rlVertexBuffer::vertices : v0 v1 v2 v3 v4 v5 v6 rlVertexBuffer::indices : 0 1 2 1 2 3 4 5 6 5 6 7 8 9 10 9 10 11 是否使用indces:\t会使用 不会使用 那这个时候我又要绘制矩形呢？这个时候矩形应该能够利用到indices中的索引才行，所以我不能直接放入vertices末尾，如果直接放入，顶点对应的索引下标会变为7 8 9 8 9 10而不是我们要的8 9 10 9 10 11。所以这个时候就要对齐，Raylib会设置rlDrawCall::vertexAlignment为1以指定偏移量：\n1 2 3 rlVertexBuffer::vertices : v0 v1 v2 v3 v4 v5 v6 [v7] v8 v9 v10 v11 rlVertexBuffer::indices : 0 1 2 1 2 3 4 5 6 5 6 7 8 9 10 9 10 11 是否使用indces:\t会使用 不会使用 会使用 注意这里的v7（即vertices[7]）是没有数据的，只是用来占位的。\n而是否使用indices由rlDrawCall::mode来决定。是RL_QUAD就调用glDrawElements并使用索引Buffer。否则调用glDrawArray()。\nBatch Rendering的源码 初始化RLGL部分 初始化RLGL部分的代码在：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 //\u003e src/rlgl.h 2477 rlRenderBatch rlLoadRenderBatch(int numBuffers, int bufferElements) { rlRenderBatch batch = { 0 }; #if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2) // Initialize CPU (RAM) vertex buffers (position, texcoord, color data and indexes) //-------------------------------------------------------------------------------------------- batch.vertexBuffer = (rlVertexBuffer *)RL_MALLOC(numBuffers*sizeof(rlVertexBuffer)); for (int i = 0; i \u003c numBuffers; i++) { ...(1) int k = 0; // Indices can be initialized right now for (int j = 0; j \u003c (6*bufferElements); j += 6) { batch.vertexBuffer[i].indices[j] = 4*k; batch.vertexBuffer[i].indices[j + 1] = 4*k + 1; batch.vertexBuffer[i].indices[j + 2] = 4*k + 2; batch.vertexBuffer[i].indices[j + 3] = 4*k; batch.vertexBuffer[i].indices[j + 4] = 4*k + 2; batch.vertexBuffer[i].indices[j + 5] = 4*k + 3; k++; } RLGL.State.vertexCounter = 0; } ...(2) } (1)处省略的是batch中各个数组vertices, indices, texcoords, colors的内存初始化。紧接着的代码是初始化indices的部分。然后(2)处省略的是对vaoId和vboId[4]的初始化和绑定，以及对draws成员的初始化。省略的代码都是常规操作。\n这个函数在一开始初始化窗口（void InitWindow(int width, int height, const char *title)）时会调用（InitGraphicsDevice()-\u003erlglInit()-\u003erlLoadRenderBatch()）。最后返回值会给RLGL。\n需要注意的是，这个函数传入的参数决定了batch buffer和buffer中能够存储的vertex数目。这个数目之后是不会变的。\nBatch部分 通过刚才的初始化我们知道，RLGL.currentBatch-\u003evertexBuffer和RLGL.currentBatch-\u003edraws的数目初始化后是固定不变的。那么Raylib在何时会真正调用DrawCall绘制呢？答案是：\n当顶点数据超出vertexBuffer时，调用所有存储的drawcall然后清除draws和vertexBuffer中数据 当draws已满时，调用所有drawcall然后清除draws和vertexBuffer中数据 调用void EndDrawing(void)时，代表游戏循环中的渲染全部结束了，会将剩下的batch全部绘制掉 那么何时会出现新对的drawcall呢？答案如下：\n需要绘制的元素类型和当前drawcall类型（即mode成员）不一致时 改变了texture时 典型raylib绘制程序结构分析 一个典型的Raylib程序如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 精简过后的examples/shapes/shapes_basic_shapes.c #include \"raylib.h\" int main(void) { const int screenWidth = 800; const int screenHeight = 450; InitWindow(screenWidth, screenHeight, \"raylib [shapes] example - basic shapes drawing\"); while (!WindowShouldClose()) { BeginDrawing(); ClearBackground(RAYWHITE); // Circle shapes and lines DrawCircle(screenWidth/5, 120, 35, DARKBLUE); DrawCircleGradient(screenWidth/5, 220, 60, GREEN, SKYBLUE); DrawCircleLines(screenWidth/5, 340, 80, DARKBLUE); // Rectangle shapes and lines DrawRectangle(screenWidth/4*2 - 60, 100, 120, 60, RED); DrawRectangleGradientH(screenWidth/4*2 - 90, 170, 180, 130, MAROON, GOLD); DrawRectangleLines(screenWidth/4*2 - 40, 320, 80, 60, ORANGE); EndDrawing(); } CloseWindow(); return 0; } 通常渲染以一对BeginDraw()，EndDrawing()包括，里面有所有的渲染调用函数。\n以DrawCircle为例，他的实现如下（最里面调用的是DrawCircleSector）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 void DrawCircleSector(Vector2 center, float radius, float startAngle, float endAngle, int segments, Color color) { ...(1) #if defined(SUPPORT_QUADS_DRAW_MODE) rlSetTexture(texShapes.id); rlBegin(RL_QUADS); // NOTE: Every QUAD actually represents two segments for (int i = 0; i \u003c segments/2; i++) { rlColor4ub(color.r, color.g, color.b, color.a); rlTexCoord2f(texShapesRec.x/texShapes.width, texShapesRec.y/texShapes.height); rlVertex2f(center.x, center.y); rlTexCoord2f(texShapesRec.x/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height); rlVertex2f(center.x + sinf(DEG2RAD*angle)*radius, center.y + cosf(DEG2RAD*angle)*radius); rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, (texShapesRec.y + texShapesRec.height)/texShapes.height); rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*radius, center.y + cosf(DEG2RAD*(angle + stepLength))*radius); rlTexCoord2f((texShapesRec.x + texShapesRec.width)/texShapes.width, texShapesRec.y/texShapes.height); rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength*2))*radius, center.y + cosf(DEG2RAD*(angle + stepLength*2))*radius); angle += (stepLength*2); } // NOTE: In case number of segments is odd, we add one last piece to the cake ...(2) rlSetTexture(0); #else rlBegin(RL_TRIANGLES); for (int i = 0; i \u003c segments; i++) { rlColor4ub(color.r, color.g, color.b, color.a); rlVertex2f(center.x, center.y); rlVertex2f(center.x + sinf(DEG2RAD*angle)*radius, center.y + cosf(DEG2RAD*angle)*radius); rlVertex2f(center.x + sinf(DEG2RAD*(angle + stepLength))*radius, center.y + cosf(DEG2RAD*(angle + stepLength))*radius); angle += stepLength; } rlEnd(); #endif } (1)处省略了一些针对扇形计算的代码。(2)处则省略了对特殊情况的处理。\n我们主要看结构，可以看到首先会使用rlSetTexture()设置纹理，然后渲染代码总以一对rlBegin(XXX),rlEnd()包裹，在里面通过rlColor4ub(),rlVertex2f(),rlTexCoord2f()指定顶点的数据。注意rlVertex2f()一定要在最后调用。因为rlColor4ub()和rlTexCoord2f()是将数据存在RLGL中。\n改变texture 改变texture会导致产生新drawcall：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // Set current texture to use void rlSetTexture(unsigned int id) { if (id == 0) { #if defined(GRAPHICS_API_OPENGL_11) rlDisableTexture(); #else // NOTE: If quads batch limit is reached, we force a draw call and next batch starts if (RLGL.State.vertexCounter \u003e= RLGL.currentBatch-\u003evertexBuffer[RLGL.currentBatch-\u003ecurrentBuffer].elementCount*4) { rlDrawRenderBatch(RLGL.currentBatch); } #endif } else { #if defined(GRAPHICS_API_OPENGL_11) rlEnableTexture(id); #else if (RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].textureId != id) { if (RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].vertexCount \u003e 0) { // Make sure current RLGL.currentBatch-\u003edraws[i].vertexCount is aligned a multiple of 4, // that way, following QUADS drawing will keep aligned with index processing // It implies adding some extra alignment vertex at the end of the draw, // those vertex are not processed but they are considered as an additional offset // for the next set of vertex to be drawn if (RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].mode == RL_LINES) RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].vertexAlignment = ((RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].vertexCount \u003c 4)? RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].vertexCount : RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].vertexCount%4); else if (RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].mode == RL_TRIANGLES) RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].vertexAlignment = ((RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].vertexCount \u003c 4)? 1 : (4 - (RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].vertexCount%4))); else RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].vertexAlignment = 0; if (!rlCheckRenderBatchLimit(RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].vertexAlignment)) { RLGL.State.vertexCounter += RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].vertexAlignment; RLGL.currentBatch-\u003edrawCounter++; } } if (RLGL.currentBatch-\u003edrawCounter \u003e= RL_DEFAULT_BATCH_DRAWCALLS) rlDrawRenderBatch(RLGL.currentBatch); RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].textureId = id; RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].vertexCount = 0; } #endif } } 22行在判断当前texture是否改变。如果改变了，24行的if内会计算alignment，然后35~41行会新增drawcall数据结构，43行时会将信息存入。\n这里面的rlDrawRenderBatch()是真正进行batch rendering的地方。后面会说。\n开始进行渲染rlBegin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // Initialize drawing mode (how to organize vertex) void rlBegin(int mode) { // Draw mode can be RL_LINES, RL_TRIANGLES and RL_QUADS // NOTE: In all three cases, vertex are accumulated over default internal vertex buffer if (RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].mode != mode) { if (RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].vertexCount \u003e 0) { // Make sure current RLGL.currentBatch-\u003edraws[i].vertexCount is aligned a multiple of 4, // that way, following QUADS drawing will keep aligned with index processing // It implies adding some extra alignment vertex at the end of the draw, // those vertex are not processed but they are considered as an additional offset // for the next set of vertex to be drawn rlDrawCall* draw = \u0026RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1]; if (draw-\u003emode == RL_LINES) draw-\u003evertexAlignment = ((draw-\u003evertexCount \u003c 4)? draw-\u003evertexCount : draw-\u003evertexCount%4); else if (draw-\u003emode == RL_TRIANGLES) draw-\u003evertexAlignment = ((draw-\u003evertexCount \u003c 4)? 1 : (4 - (draw-\u003evertexCount%4))); else draw-\u003evertexAlignment = 0; if (!rlCheckRenderBatchLimit(draw-\u003evertexAlignment)) { RLGL.State.vertexCounter += draw-\u003evertexAlignment; RLGL.currentBatch-\u003edrawCounter++; } } if (RLGL.currentBatch-\u003edrawCounter \u003e= RL_DEFAULT_BATCH_DRAWCALLS) rlDrawRenderBatch(RLGL.currentBatch); RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].mode = mode; RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].vertexCount = 0; RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].textureId = RLGL.State.defaultTextureId; } } 这里每一行都很重要:\n第6行的if判断mode是否改变了。如果改变了，说明要新增一个drawcall了。\n第8行的if及里面的代码是在算当前vertex的alignment，并存储得到draw-\u003evertexAlignment中（说是alignment，倒不如说是padding，是当前数据到之前数据之间的空隙个数。所以RLGL.State.vertexCounter也要加上这个空隙个数）。\n然后27行看一下draws是否已满，满了触发batch rendering，之后就将数据放入新的draws中。\n将数据存放入buffer中 1 2 3 4 5 6 7 8 9 10 // Define one vertex (color) void rlColor4ub(unsigned char x, unsigned char y, unsigned char z, unsigned char w) { RLGL.State.colorr = x; RLGL.State.colorg = y; RLGL.State.colorb = z; RLGL.State.colora = w; } // rlTexCoord2d()同理，不贴了 然后rlVertex2f()会将所有数据放入buffer中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // Define one vertex (position) void rlVertex2f(float x, float y) { rlVertex3f(x, y, RLGL.currentBatch-\u003ecurrentDepth); } // Define one vertex (position) // NOTE: Vertex position data is the basic information required for drawing void rlVertex3f(float x, float y, float z) { float tx = x; float ty = y; float tz = z; // Transform provided vector if required if (RLGL.State.transformRequired) { tx = RLGL.State.transform.m0*x + RLGL.State.transform.m4*y + RLGL.State.transform.m8*z + RLGL.State.transform.m12; ty = RLGL.State.transform.m1*x + RLGL.State.transform.m5*y + RLGL.State.transform.m9*z + RLGL.State.transform.m13; tz = RLGL.State.transform.m2*x + RLGL.State.transform.m6*y + RLGL.State.transform.m10*z + RLGL.State.transform.m14; } // WARNING: We can't break primitives when launching a new batch. // RL_LINES comes in pairs, RL_TRIANGLES come in groups of 3 vertices and RL_QUADS come in groups of 4 vertices. // We must check current draw.mode when a new vertex is required and finish the batch only if the draw.mode draw.vertexCount is %2, %3 or %4 if (RLGL.State.vertexCounter \u003e (RLGL.currentBatch-\u003evertexBuffer[RLGL.currentBatch-\u003ecurrentBuffer].elementCount*4 - 4)) { if ((RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].mode == RL_LINES) \u0026\u0026 (RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].vertexCount%2 == 0)) { // Reached the maximum number of vertices for RL_LINES drawing // Launch a draw call but keep current state for next vertices comming // NOTE: We add +1 vertex to the check for security rlCheckRenderBatchLimit(2 + 1); } else if ((RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].mode == RL_TRIANGLES) \u0026\u0026 (RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].vertexCount%3 == 0)) { rlCheckRenderBatchLimit(3 + 1); } else if ((RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].mode == RL_QUADS) \u0026\u0026 (RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].vertexCount%4 == 0)) { rlCheckRenderBatchLimit(4 + 1); } } // Add vertices RLGL.currentBatch-\u003evertexBuffer[RLGL.currentBatch-\u003ecurrentBuffer].vertices[3*RLGL.State.vertexCounter] = tx; RLGL.currentBatch-\u003evertexBuffer[RLGL.currentBatch-\u003ecurrentBuffer].vertices[3*RLGL.State.vertexCounter + 1] = ty; RLGL.currentBatch-\u003evertexBuffer[RLGL.currentBatch-\u003ecurrentBuffer].vertices[3*RLGL.State.vertexCounter + 2] = tz; // Add current texcoord RLGL.currentBatch-\u003evertexBuffer[RLGL.currentBatch-\u003ecurrentBuffer].texcoords[2*RLGL.State.vertexCounter] = RLGL.State.texcoordx; RLGL.currentBatch-\u003evertexBuffer[RLGL.currentBatch-\u003ecurrentBuffer].texcoords[2*RLGL.State.vertexCounter + 1] = RLGL.State.texcoordy; // TODO: Add current normal // By default rlVertexBuffer type does not store normals // Add current color RLGL.currentBatch-\u003evertexBuffer[RLGL.currentBatch-\u003ecurrentBuffer].colors[4*RLGL.State.vertexCounter] = RLGL.State.colorr; RLGL.currentBatch-\u003evertexBuffer[RLGL.currentBatch-\u003ecurrentBuffer].colors[4*RLGL.State.vertexCounter + 1] = RLGL.State.colorg; RLGL.currentBatch-\u003evertexBuffer[RLGL.currentBatch-\u003ecurrentBuffer].colors[4*RLGL.State.vertexCounter + 2] = RLGL.State.colorb; RLGL.currentBatch-\u003evertexBuffer[RLGL.currentBatch-\u003ecurrentBuffer].colors[4*RLGL.State.vertexCounter + 3] = RLGL.State.colora; RLGL.State.vertexCounter++; RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].vertexCount++; } 上面代码中，16行那个if表示如果需要进行变换，会乘上变换矩阵。\n26行那个if是在看RLGL.currentBatch-\u003evertexBuffer能否容纳新加入的顶点。如果不能，就触发BatchRendering先将所有点绘制掉，然后清空以存储新点（这一过程在rlCheckRenderBatchLimit(count)中）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 bool rlCheckRenderBatchLimit(int vCount) { bool overflow = false; #if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2) if ((RLGL.State.vertexCounter + vCount) \u003e= (RLGL.currentBatch-\u003evertexBuffer[RLGL.currentBatch-\u003ecurrentBuffer].elementCount*4)) { overflow = true; // Store current primitive drawing mode and texture id int currentMode = RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].mode; int currentTexture = RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].textureId; rlDrawRenderBatch(RLGL.currentBatch); // NOTE: Stereo rendering is checked inside // Restore state of last batch so we can continue adding vertices RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].mode = currentMode; RLGL.currentBatch-\u003edraws[RLGL.currentBatch-\u003edrawCounter - 1].textureId = currentTexture; } #endif return overflow; } 第6行在判断能否容纳。如果不行，15行会触发Batch Rendering（里面会置RLGL.currentBatch-\u003edrawCounter为1，就是清空draws），然后18-19行将数据存到draws中。\n真正的Batch Rendering：rlDrawRenderBatch() 真正的Batch Rendering代码巨多，这里简化一下贴上来：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 void rlDrawRenderBatch(rlRenderBatch *batch) { #if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2) // Update batch vertex buffers //------------------------------------------------------------------------------------------------------------ // NOTE: If there is not vertex data, buffers doesn't need to be updated (vertexCount \u003e 0) // TODO: If no data changed on the CPU arrays --\u003e No need to re-update GPU arrays (change flag required) if (RLGL.State.vertexCounter \u003e 0) { // Activate elements VAO if (RLGL.ExtSupported.vao) glBindVertexArray(batch-\u003evertexBuffer[batch-\u003ecurrentBuffer].vaoId); ...(1) // Unbind the current VAO if (RLGL.ExtSupported.vao) glBindVertexArray(0); } //------------------------------------------------------------------------------------------------------------ // Draw batch vertex buffers (considering VR stereo if required) //------------------------------------------------------------------------------------------------------------ Matrix matProjection = RLGL.State.projection; Matrix matModelView = RLGL.State.modelview; int eyeCount = 1; if (RLGL.State.stereoRender) eyeCount = 2; for (int eye = 0; eye \u003c eyeCount; eye++) { if (eyeCount == 2) { ...(2) } // Draw buffers if (RLGL.State.vertexCounter \u003e 0) { ...(3) if (RLGL.ExtSupported.vao) glBindVertexArray(batch-\u003evertexBuffer[batch-\u003ecurrentBuffer].vaoId); else { ...(4) } ...(5) for (int i = 0, vertexOffset = 0; i \u003c batch-\u003edrawCounter; i++) { // Bind current draw call texture, activated as GL_TEXTURE0 and Bound to sampler2D texture0 by default glBindTexture(GL_TEXTURE_2D, batch-\u003edraws[i].textureId); if ((batch-\u003edraws[i].mode == RL_LINES) || (batch-\u003edraws[i].mode == RL_TRIANGLES)) glDrawArrays(batch-\u003edraws[i].mode, vertexOffset, batch-\u003edraws[i].vertexCount); else { #if defined(GRAPHICS_API_OPENGL_33) // We need to define the number of indices to be processed: elementCount*6 // NOTE: The final parameter tells the GPU the offset in bytes from the // start of the index buffer to the location of the first index to process glDrawElements(GL_TRIANGLES, batch-\u003edraws[i].vertexCount/4*6, GL_UNSIGNED_INT, (GLvoid *)(vertexOffset/4*6*sizeof(GLuint))); #endif #if defined(GRAPHICS_API_OPENGL_ES2) glDrawElements(GL_TRIANGLES, batch-\u003edraws[i].vertexCount/4*6, GL_UNSIGNED_SHORT, (GLvoid *)(vertexOffset/4*6*sizeof(GLushort))); #endif } vertexOffset += (batch-\u003edraws[i].vertexCount + batch-\u003edraws[i].vertexAlignment); } if (!RLGL.ExtSupported.vao) { glBindBuffer(GL_ARRAY_BUFFER, 0); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); } glBindTexture(GL_TEXTURE_2D, 0); // Unbind textures } if (RLGL.ExtSupported.vao) glBindVertexArray(0); // Unbind VAO glUseProgram(0); // Unbind shader program } ...(6) // Reset RLGL.currentBatch-\u003edraws array for (int i = 0; i \u003c RL_DEFAULT_BATCH_DRAWCALLS; i++) { batch-\u003edraws[i].mode = RL_QUADS; batch-\u003edraws[i].vertexCount = 0; batch-\u003edraws[i].textureId = RLGL.State.defaultTextureId; } // Reset active texture units for next batch for (int i = 0; i \u003c RL_DEFAULT_BATCH_MAX_TEXTURE_UNITS; i++) RLGL.State.activeTextureId[i] = 0; // Reset draws counter to one draw for the batch batch-\u003edrawCounter = 1; //------------------------------------------------------------------------------------------------------------ // Change to next buffer in the list (in case of multi-buffering) batch-\u003ecurrentBuffer++; if (batch-\u003ecurrentBuffer \u003e= batch-\u003ebufferCount) batch-\u003ecurrentBuffer = 0; #endif } 这里(1)处是将顶点信息vertices,texcoords等的数据传入对应buffer。\n(2)处的eyeCount如果是2，代表要用VR（从两个眼睛处看物体，并绘制两幅图），做一些用于VR绘制的准备操作（主要是设置矩阵）。\n(3)处使用着色器，并初始化一些矩阵。\n(4)处，如果不能够绑定VAO（因为OpenGLES2不支持），那么会使用GLES2的方式处理各个Buffer以正确绑定（不过如果有GL_ARB_vertex_array_object拓展支持也可以绑定（也就是RLGL.ExtSupported.vao指定的事情））。\n(5)处设置一些着色器的Uniform变量。\n(6)处渲染已经完毕了，重置一些变量的值。\n真正的渲染在53行处开始：如果是RL_LINES或RL_TRIANGLES，则调用glDrawArray()直接绘制。否则调用glDrawElements进行绘制。然后vertexOffset通过vertexCount和vertexAlignment指向下一批数据。\n总结 batch rendering的优点：减少数据送往GPU的次数，减少drawcall\nraylib的batch rendering做法：将数据尽可能地先存在本地，相同类型的绘制使用一个drawcall一次性绘制完毕。\n导致新增drawcall的情况：\n改变了texture 改变了绘制类型 这就说明，如果要利用到batch rendering，就需要相同类型，相同texture的元素放在一起绘制。这也就是为什么游戏引擎中会使用图集的原因：同一类UI全部使用一个texture，texture不变。UI中能使用矩形就使用矩形，减少绘制类型的改变次数，以充分利用batch rendering。\n","description":"","tags":["图形学","源码阅读"],"title":"Raylib的BatchRendering","uri":"/posts/raylib%E7%9A%84batchrendering/"},{"categories":null,"content":"模板参数推导 模板参数有三种写法：\n1 2 3 4 5 6 7 8 template \u003ctypename T\u003e void Foo(T) { static_assert(false); } // 直接使用T template \u003ctypename T\u003e void FooWithRRef(T\u0026) { static_assert(false); } // 使用T\u0026 template \u003ctypename T\u003e void FooWithLRef(T\u0026\u0026) { static_assert(false); } // 使用T\u0026\u0026 根据《C++ Templates 2》的说法，第一种写法会decay（等同于调用std::decay），即：\n所有的const, volatile限定符会被移除 所有的引用（不管左值右值）会被移除 数组会退化为指向数组的指针，函数会退化为指向函数的指针 所以会有：\n1 2 3 4 5 6 7 8 9 10 Foo(1) -\u003e 参数真正类型:int\u0026\u0026 T推导结果：int int a; Foo(a) -\u003e 参数真正类型:int T推导结果：int int\u0026\u0026 a = 123; Foo(std::move(a)) -\u003e 参数真正类型:int\u0026\u0026 T推导结果：int const int\u0026 a = b; Foo(a) -\u003e 参数真正类型:const int\u0026 T推导结果：int 第二种写法会保留所有参数原本的类型，const不会被丢弃，引用也会被保留。\n但是有个问题：引用折叠，即当存在多个引用时，各个引用之间会发生折叠：\n类型1 类型2 结果类型 T T\u0026 T\u0026 T\u0026 T\u0026 T\u0026 T\u0026\u0026 T\u0026 T\u0026 T\u0026\u0026 T\u0026\u0026 T\u0026\u0026 也就是说，只有两个类型都是右值引用的时候，最后推导结果才会是左值引用。否则全部变为左值引用。\n那么由于引用折叠的存在，FooWithRRef()的参数类型一定是右值引用（因为左值会被折叠掉变为右值）。\n那么要想做到传递左值，就必须使用FooWithLRef()并且传入参数是左值引用类型，这样引用折叠才会折叠为左值引用。\n完美转发 使用FooWithLRef(T\u0026\u0026)仍旧有一个问题，就是在此函数内将参数传递给另一个函数时会有问题：\n1 2 3 4 5 6 7 void anotherFunc(int\u0026 a); void anotherFunc(int\u0026\u0026 a); template \u003ctypename T\u003e void FooWithLRef(T\u0026\u0026 value) { anotherFunc(value);\t// 调用的是哪个？ } 这里，如果传递左值FooWithLRef(std::move(a))，那么T会被推导为int，那么value的类型就是int\u0026\u0026。这样传入的是左值引用。\n但是左值引用本身是右值，所以在传入anotherFunc的时候，仍旧是按照右值传递，这样会调用第一个函数，永远不会调用第二个函数。\n当然，可以强制使用anotherFunc(std::move(a))进行左值版本调用。那这样右值版本将永不调用。\n这个时候就需要使用完美转发std::forward\u003cT\u003e(a)，它会将左值引用再次变为左值，而右值引用仍旧是右值。\n其他 关于FooWithLRef(T\u0026\u0026)还有一个注意点，就是如果传入一个左值，如：\n1 FooWithLRef(1); T会被推导为int，所以value的类型是T\u0026\u0026-\u003eint\u0026\u0026。\n而如果传入右值或普通值：\n1 2 int\u0026 a = b;\t// 或int a = 123; FooWithLRef(a); 那么T会被推导为int\u0026，根据引用折叠，value类型是int\u0026 \u0026\u0026 -\u003eint\u0026。\n而很离谱的是，如果你使用的是FooWithRRef(T\u0026)，传入普通类型并不会使T变为int\u0026而是int，最后value会被推导为int\u0026。\n","description":"","tags":["cpp"],"title":"引用折叠和完美转发","uri":"/posts/%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"},{"categories":null,"content":"本文分析了开源项目EnTT v3.12.2的原理和实现。述说了ECS中的Entity部分。\nEntity Entity的本质 EnTT中的Entity是正整数，或者更严谨一点，是enum class：\n1 2 3 4 5 6 7 8 enum class entity : id_type {}; //\u003e src/entt/entity/fwd.hpp using id_type = ENTT_ID_TYPE; //\u003e src/entt/core/fwd.hpp //\u003e src/entt/config/config.h #ifndef ENTT_ID_TYPE # include \u003ccstdint\u003e # define ENTT_ID_TYPE std::uint32_t #endif 所以总的来说就是正整数类型的强枚举。\n之所以使用强枚举是因为这样可以避免用户拿到Entity之后胡乱当做整数进行运算。每次操作Entity的时候其实都会将其强转到id_type的，本质上还是当整数去操作。\nentity traits traits用于限制Entity的类型，并且定义一些字段：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 //\u003e src/entt/entity/entity.hpp namespace internal { ... /*(1)*/ template\u003ctypename, typename = void\u003e struct entt_traits; /*(2)*/ template\u003ctypename Type\u003e struct entt_traits\u003cType, std::enable_if_t\u003cstd::is_enum_v\u003cType\u003e\u003e\u003e : entt_traits\u003cstd::underlying_type_t\u003cType\u003e\u003e { using value_type = Type; }; /*(3)*/ template\u003ctypename Type\u003e struct entt_traits\u003cType, std::enable_if_t\u003cstd::is_class_v\u003cType\u003e\u003e\u003e : entt_traits\u003ctypename Type::entity_type\u003e { using value_type = Type; }; /*(4)*/ template\u003c\u003e struct entt_traits\u003cstd::uint32_t\u003e { using value_type = std::uint32_t; using entity_type = std::uint32_t; using version_type = std::uint16_t; static constexpr entity_type entity_mask = 0xFFFFF; static constexpr entity_type version_mask = 0xFFF; }; template\u003c\u003e struct entt_traits\u003cstd::uint64_t\u003e { using value_type = std::uint64_t; using entity_type = std::uint64_t; using version_type = std::uint32_t; static constexpr entity_type entity_mask = 0xFFFFFFFF; static constexpr entity_type version_mask = 0xFFFFFFFF; }; ... } EnTT中有很多类似这样的操作：首先(1)处声明一个模板，但是不实现它。等到后面对其进行特化。这样只有满足特化的模板参数才可以通过编译，其余的一律是不支持的模板参数，变相地限制了模板参数（C++20 concept我想你了555）。\n(2)和(3)是在做如下事情：\n如果Type是类，那它要求Type中有一个entity_type，并且这个entity_type也必须是类或枚举，然后将这个类型递归地进行萃取 如果Type是枚举，得到他对应的数字类型（EnTT中就是id_type是uint32_t）并且通过继承聚合此类型相关的信息 (4)处开始真正的Entity信息定义。这里通过全特化指定只有uint32_t和uint64_t能够有类型，其余的数字类型一律编译失败。\nEntity由两部分组成：id部分和version部分。version部分主要是为了复用entity。\n那么我们可以看到，Entity应该有如下信息：\nvalue_type：Entity真正的数字类型 entity_type：id部分的类型 version_type：version部分的类型 entity_mask：id部分的掩码 version_mask：version部分的掩码 比如对于uint32_t类型来说，其Entity组成如下：\nversion id 0000 0000 0001 000 0000 0000 0000 0001 version在高位id在低位。\n接下来的basic_entt_traits则通过组合的方式增加了一些对Entity的操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template\u003ctypename Traits\u003e class basic_entt_traits { static constexpr auto length = internal::popcount(Traits::entity_mask); /*(1)*/ static_assert(Traits::entity_mask \u0026\u0026 ((typename Traits::entity_type{1} \u003c\u003c length) == (Traits::entity_mask + 1)), \"Invalid entity mask\"); static_assert((typename Traits::entity_type{1} \u003c\u003c internal::popcount(Traits::version_mask)) == (Traits::version_mask + 1), \"Invalid version mask\"); public: using value_type = typename Traits::value_type; using entity_type = typename Traits::entity_type; using version_type = typename Traits::version_type; static constexpr entity_type entity_mask = Traits::entity_mask; static constexpr entity_type version_mask = Traits::version_mask; [[nodiscard]] static constexpr entity_type to_integral(const value_type value) noexcept { ... } [[nodiscard]] static constexpr entity_type to_entity(const value_type value) noexcept { ... } [[nodiscard]] static constexpr version_type to_version(const value_type value) noexcept { ... } ... } 这里的模板参数Traits就是上面的entt_traits。然后类里面重新using了traits里的类型。\n增加的一些操作也很好懂，在这里就不分析了，注释写的很详细。主要是得到Entity的版本号/ID号，通过版本号\u0026ID好拼一个Entity，通过两个Entity拼一个Entity等等。\n这里稍微看一下(1)处的两个static_assert，要求entity_mask和version_mask必须满足所有位全为1的条件。我也是第一次知道static_assert可以直接放在类里面。\n最后，通过entt命名空间中的entt_traits继承basic_entt_traits得到最后的traits：\n1 2 3 4 5 template\u003ctypename Type\u003e struct entt_traits: basic_entt_traits\u003cinternal::entt_traits\u003cType\u003e\u003e { using base_type = basic_entt_traits\u003cinternal::entt_traits\u003cType\u003e\u003e; static constexpr std::size_t page_size = ENTT_SPARSE_PAGE; }; 并且在下面将basic_entt_traits的static函数封装成全局函数以便于调用。\n小结一下：\n首先通过entt_traits进行类型萃取，要求Entity的类型必须是枚举，并且枚举的底层数字类型必须是uint32_t/uint64_t（但可通过增加全特化版本来扩展支持类型） 然后通过basic_entt_traits在原本的信息上增加控制这些数据的函数 最后使用全局函数封装basic_entt_traits以方便函数调用（basic_entt_traits需要一个entt_traits作为模板参数。entt_traits需要一个Entity作为模板参数。封装成全局函数可直接通过Entity模板参数调用函数） null和tombstone null代表空，而tombstone代表“死了”，两者虽然实现非常相似，但不是一个东西（之后的文章会说用法）。\n这里对null和tombstone的实现也很有意思，可以学习学习。这两者实现几乎一样，而且也非常地好懂：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //\u003e src/entt/entity/entity.hpp struct null_t { template\u003ctypename Entity\u003e [[nodiscard]] constexpr operator Entity() const noexcept { using traits_type = entt_traits\u003cEntity\u003e; constexpr auto value = traits_type::construct(traits_type::entity_mask, traits_type::version_mask); return value; } [[nodiscard]] constexpr bool operator==([[maybe_unused]] const null_t other) const noexcept { return true; } [[nodiscard]] constexpr bool operator!=([[maybe_unused]] const null_t other) const noexcept { return false; } template\u003ctypename Entity\u003e [[nodiscard]] constexpr bool operator==(const Entity entity) const noexcept { using traits_type = entt_traits\u003cEntity\u003e; return traits_type::to_entity(entity) == traits_type::to_entity(*this); } template\u003ctypename Entity\u003e [[nodiscard]] constexpr bool operator!=(const Entity entity) const noexcept { return !(entity == *this); } }; template\u003ctypename Entity\u003e [[nodiscard]] constexpr bool operator==(const Entity entity, const null_t other) noexcept { return other.operator==(entity); } template\u003ctypename Entity\u003e [[nodiscard]] constexpr bool operator!=(const Entity entity, const null_t other) noexcept { return !(other == entity); } 实现很简单。首先，这个类是一个空类。其次有如下三种函数：\n隐式转换到Entity 和任意的null_t类型比较，总是为true 和Entity比较，只有特定情况（Entity所有位全是1）的时候为true，其他的全为false 真正的做到了0开销抽象原则。\n","description":"","tags":["源码阅读","EnTT"],"title":"EnTT源码分析【二】：Entity","uri":"/posts/entt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%8C/"},{"categories":null,"content":"本文分析了开源项目EnTT v3.12.2的原理和实现。述说了ECS中的核心数据结构sparse set。\nsparse set 结构介绍 sparse set是一个数据结构，用于极快速地对正整数进行增删改查并能够较好地利用CPU Cache。而EnTT中的Entity部分正式用正整数实现的。\nsparse set由两部分组成：\npacked：一个线性表，用于紧密存储所有正整数。也是真正保存所有数据的地方。 sparse：一个线性表，比较稀疏，用于存储packed中整数在packed数组中的下标，主要是为了建立值和下标的映射以加快查找。 需要注意的是，packed和sparse必须是内存连续的线性表，这样才能发挥它易命中Cache的优势。\n基本操作 增加 增加元素的操作如下，对于任意正整数A\n将A无条件放在packed数组末尾 得到A在packed数组中的下标I（其实就是packed数组的长度-1） 将I放在sparse数组的，以A为下标的位置处 下面用一个例子说明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 0. 一开始的sparse set: packed: 空 sparse: 空 现在要插入一个正整数3： 1. 将3放入packed最后 packed: 3 sparse: 空 2. 得到3在packed数组的下标，为0 3. 将0存入sparse[3]处： packed: 3 sparse: _ _ _ 0 查询 很简单：对于任意元素A，看sparse[A]处是否有值即可。\n如果有值，还可以通过sparse[A]得到A元素在packed数组中的下标。\n删除 删除的话也很简单，对于任意元素A：\n通过sparse[A]得到A在packed中的下标I 将packed[A] 和 packed最后一位互换，记packed最后一位元素为L 更新L在sparse中的索引：sparse[L] = I 置sparse[A]为空删除其索引 弹出packed末尾元素（就是之前换到末尾去的A） 迭代元素 packed数组中紧密存储着所有元素，所以直接迭代packed数组就行了（EnTT的迭代器sparse_set_iterator就是直接拿到packed数组的迭代器进行迭代）。\n顺便说一句，sparse set是无序容器。\n和HashMap的对比 sparse set的增删查复杂度都是O(1)，而HashMap也是。但HashMap的效率总体来说不如sparse set高。因为sparse set总能在确定步数内完成操作，而HashMap因为冲突的问题，可能需要多次使用散列函数，真正的步骤是不确定的。而如果使用拉链法解决冲突，则更会导致难以命中Cache的问题。\nsparse set的缺点就是只能对正整数进行操作。\n源码分析 源码位于src/entity/sparse_set.hpp中。\n分页的sparse数组 这个类是个模板类：\n1 2 template\u003ctypename Entity, typename Allocator\u003e class basic_sparse_set { ... }; Entity模板参数是EnTT中实体的类型。Allocator是内存分配器。\n需要注意的是，basic_sparse_set的sparse数组不是一维数组，是二维的（用的时候其实还是视为一位数组，会将二维摊开成一维），差不多是std::vector\u003cEntity[PageSize]\u003e这个类型。本质上是将一位数组分为多个“页”(Page)，每个页大小就是PageSize最终的页大小在src/entt/config/config.h中有定义：\n1 2 3 #ifndef ENTT_SPARSE_PAGE # define ENTT_SPARSE_PAGE 4096 #endif 分页的原因应该是考虑到CPU的分页机制，当内存过大时方便CPU按照这个大小换页。也有可能是为了方便内存分配器Allocator一次分配这么多内存。\n所以当你插入一个元素A的时候，他会把下标放在sparse[A / PageSize][A % PageSize]处。\n成员变量和一些using 成员变量和其using如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template\u003ctypename Entity, typename Allocator\u003e class basic_sparse_set { using alloc_traits = std::allocator_traits\u003cAllocator\u003e; static_assert(std::is_same_v\u003ctypename alloc_traits::value_type, Entity\u003e, \"Invalid value type\"); using sparse_container_type = std::vector\u003ctypename alloc_traits::pointer, typename alloc_traits::template rebind_alloc\u003ctypename alloc_traits::pointer\u003e\u003e; using packed_container_type = std::vector\u003cEntity, Allocator\u003e; ... private: sparse_container_type sparse; packed_container_type packed; const type_info *info; entity_type free_list; deletion_policy mode; }; sparse_container_type和packed_container_type是std::vector这在意料之中，但是sparse_container_type的成员有些不明朗，是Allocator分配出的指针类型。这个类型在src/entt/entity/fwd.hpp中有说明：\n1 2 template\u003ctypename Entity = entity, typename = std::allocator\u003cEntity\u003e\u003e class basic_sparse_set; 就是使用的标准库的allocator，旨在分配一个Entity。但实际的sparse_container_type中则是分配的alloc_traits::pointer，即Entity*，并且使用rebind_alloc将此allocator重绑定以让其分配Entity*（对std::allocator不熟悉可以看这个文章）。\n某些函数简述 内部函数的话我觉得没什么好说的，毕竟算法已经说明白了，代码也就是实现的事。简单说一下我比较感兴趣的函数吧：\n[[nodiscard]] auto sparse_ref(const Entity entt) const：得到sparse[entt / PageSize][entt % PageSize]元素的引用 [[nodiscard]] auto sparse_ptr(const Entity entt) const：得到sparse[entt / PageSize][entt % PageSize]元素的指针。没有这个元素返回nullptr [[nodiscard]] auto \u0026assure_at_least(const Entity entt)：保证当前sparse数组可以容纳entt（会自动扩容），并返回容纳entt的那个元素。这个函数是个很好的辅助函数，因为你可以在任何插入entt的地方使用assure_at_least(entt) = entt插入entt倒sparse中，不需要进行很多if判断 template\u003ctypename Compare, typename Sort = std_sort, typename... Args\u003e void sort_n(const size_type length, Compare compare, Sort algo = Sort{}, Args \u0026\u0026...args)：对开头的length个元素排序。EnTT是允许对sparse set排序的，这样遍历的时候会有一个顺序，在某些场景比较有用。 ","description":"","tags":["源码阅读","EnTT"],"title":"EnTT源码分析【三】：sparse set","uri":"/posts/entt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89/"},{"categories":null,"content":"本文分析了开源项目EnTT v3.12.2的原理和实现。述说了ECS架构。\nECS架构 ECS的用法 ECS是一个典型的组合优于继承的架构。\n即Entity, Component, System架构：\nEntity：游戏中的某个实体，通常用正整数实现 Component：游戏中的组件，用于附加在Entity上。例如物理系统中的RigidBody，渲染部分的PBRMaterial等。一般是不含有方法的纯粹数据 System：用于处理附加在Entity的Component。 一个ECS例子如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 以下源码仅为示例，并不严谨 void UpdatePhysics(entt::registry\u0026 reg) { auto entities = reg.view\u003cRigidBody\u003e(); for (auto\u0026 [entity, rigidbody] : entities) { // 在这里更新物理 rigidbody.acc = rigidbody.force * rigidboyd.mass; rigidbody.vel = rigidbody.acc * entt::resource_cache\u003cTimer, TimerLoader\u003e{}[0].time(); } } int main() { entt::registry reg; // EnTT中用于管理整个ECS的结构 auto entity = reg.create(); // 创建一个Entity reg.emplace(entity, RigidBody::Create(math::Vec2(100.0, 200.0))); // 创建一个物理组件并附加到Entity上 // 游戏循环中 while (!shouldClose) { // ... UpdatePhysics(reg); // ... } } 一般来说。一个ECS系统包含如下几个部分：\nWorld：即管理整个ECS数据的地方，在EnTT中是entt::registry Querier：查询器，用来得到含有某个特定组件的实体们，或者从实体得到组件。在EnTT中是entt::view Resource：[可选]，资源。本质上是组件，但不附加在任何实体上，且一般全局只有一份。EnTT中是entt::resource_cache System：系统，在游戏循环中被调用用来对组件进行实际操作。EnTT中没有特定类型，自己写函数进行组件操作即可。Bevy中有StartupSystem用于程序启动时调用一次，以及UpdateSystem用于每帧调用。 还可以分的更细致，比如Bevy中将一些功能从World中抽出：\nCommands：创建实体/将组件附加在实体/删除实体 的帮助类 Resources：用于方便地从World中得到资源 ECS的优点 相比传统的OO，ECS优点如下：\nOO编程通过类继承来组合数据/功能。这有可能导致产生冗余数据。但ECS可以将数据分为不相干的多个部分，并通过组件插拔的方式灵活地组合。 OO编程对CPU Cache不友好。摩尔定律指出，CPU每18个月性能翻倍。但内存性能增长速度没有跟上CPU，这导致利用CPU Cache数据是提升性能非常必要的手段。在近几年，由于物理原因，摩尔定律在慢慢失效，导致现在CPU提升性能的常见方法是堆核（多核CPU）。所以利用多核的优势进行并行编程也是必要的手段。而ECS通过将数据分为多个无关部分，各部分的处理更有利于并行。在Bevy游戏引擎中，就已经实现不相关系统并行运行的功能。 由于EnTT的System部分由用户自己编写，所以EnTT并没有提供任何System并行支持，本系列也不会说。并行支持部分可自行参阅flecs源码。\nEnTT的工程结构 下面列举了src/文件夹下的结构（src下是源码部分）。可选部分指可以使用，不使用的话不会参与编译（独立模块）。\nconfig：用于通过宏控制EnTT的某些配置 container：一些通用容器 core：核心算法，traits，any，内存分配器和一些工具 entity：整个EnTT最核心的部分，是entt::registry实现的地方，有着ECS大部分功能 graph：[可选]。 用于辅助开发者做出管线流图的东西。不会在本系列中分析 locator：[可选]。服务定位器 meta：[可选]。动态反射，不会在本系列中分析 platform：平台相关 poly：[可选]。用于做静态多态的东西。不会在本系列中分析 process：[可选]。文档里没说，应该是用于任务调度的东西。不会在本系列中分析 resource：[可选]。用于提供Resource支持 signal：信号和委托部分，用于提供信号，事件分发\u0026接收。本质上是个委托框架 EnTT的单元测试做的很好，所有模块对应的单测在test/目录下。\n","description":"","tags":["源码阅读","EnTT"],"title":"EnTT源码分析【一】：什么是ECS","uri":"/posts/entt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80/"},{"categories":["杂项"],"content":"因为最近开始工作了，995的那种（周末有时加班），所以基本上没什么时间写博客。我现在有时间会在B站上录一些技术视频，主要记录工作中遇到的一些技术问题和自己额外学习的一些学习内容，以及一些简单教程。\n写博客太麻烦了，码字的效率不如视频高，所以改做视频了。博客的话有时间也会更新一些短小的，如果是很耗费精力的技术分享我大概率就做视频了。\n大家可以去我的B站空间支持一波。\n","description":"","tags":["杂项"],"title":"关于逐渐迁移至B站的说明","uri":"/posts/%E5%85%B3%E4%BA%8E%E9%80%90%E6%B8%90%E8%BF%81%E7%A7%BB%E8%87%B3b%E7%AB%99%E7%9A%84%E8%AF%B4%E6%98%8E/"},{"categories":["language"],"content":"这里是跟着微软官方的C#文档学习C#笔记。着重说明了C#和C++之间的区别。\nC#是如何工作的 C#和Java十分类似，是一种静态的，带有GC的编译型语言。C#和Java一样有个“虚拟机”，即.Net平台。C#将代码编译成IL（平台无关代码），然后让.Net去执行。\n类 C#中所有的类型都是从object中派生而来。\nclass和struct class就是普通的class，struct则是不能被继承，同时也不能继承别人（其从System.ValueType隐式派生）。struct的出现主要是为了存储数据。\nstruct和class的主要区别如下：\n不能继承（但是可以继承接口） 不能被继承 不能含有abstract，protected或virtual成员 可以不使用new操作符进行实例化，这时，你必须手动赋值所有成员之后才能使用该结构体 可以有有参构造函数（无参的是默认定义且不可以被改变的），但不能有析构函数 不能在成员变量定义时初始化 类在堆上分配，结构在栈上分配 简单的class声明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class Point { public int x { get; } public int y { get; } // 构造函数中使用 =\u003e 来进行简单的初始化 public Point(int x_, int y_) =\u003e (x, y) = (x_, y_); // 使用readonly表示只能在变量声明时或构造函数中赋值的变量。 public static readonly String ClassName = \"Point\"; public void Introduce() { // 输出函数中，使用{0}代表第一个参数，{1}代表第二个参数 Console.WriteLine(\"Point2D({0}, {1})\", x, y); } } // 继承Point public class Point3D: Point { // 对成员使用get,set以方便地控制成员的读写权限 public int z { get; set; } // 构造函数中使用base调用父类构造函数 public Point3D(int x, int y, int z): base(x, y) { // 和Java类似的this this.z = z; } // 使用new关键字来说明重写了父类方法（类似C++中override） public new void Introduce() { Console.WriteLine(\"Point2D({0}, {1})\", x, y); } } 注意这里子类中虽然使用了new代表是重写方法，但是并不能在继承链中起作用。要起作用还是得变成虚函数：\n1 2 3 4 5 6 7 8 9 10 // in class Point virtual public void Introduce() { Console.WriteLine(\"Point2D({0}, {1})\", x, y); } // in class Point3D // 注意override关键字 public override void Introduce() { Console.WriteLine(\"Point3D({0}, {1}, {2})\", x, y, z); } 需要注意：\n想要进行多态的重写必须加上override，不然默认会加上new关键字（即重写，但不是多态）。 不使用virtual的函数不能被override new关键字也可以放在子类成员变量中以表示隐藏父类同名变量（默认是new）\n纯虚函数使用abstract（即抽象函数）：\n1 2 // in class Point abstract public void Introduce(); sealed关键字如同C++中的final，用在方法和类前面用于停止继承。\n从派生类访问基类成员要使用base关键字。\n接口interface 和Java一样，你可以将Interface视为C++中的纯虚类：\n1 2 3 interface Introductable { public void Introduce(); } 如果继承了多个接口，可以使用接口类型进行限定实现：\n1 2 3 4 5 6 7 8 9 10 11 12 interface Interface1 { public void Fn1(); } interface Interface2 { public void Fn2(); } class C : Interface1, Interface2 { public Interface1.Fn1() { ... } public Interface2.Fn2() { ... } } 枚举 和C++一样，使用enum关键字：\n1 2 3 4 public enum EnemyType { Flying, Standing, } C#中的enum都是C++中的enum class，需要通过枚举名访问，不能隐式转换为整型。\n函数（方法） C#和Java一样，所有的东西都是对象，所以理论上只有类方法。\n在C#8之后可以使用面向过程式的写法，类似于Python一样不需要类直接编写代码：\n1 2 3 // helloworld.cs Console.WriteLine(\"hello world without class\"); 引用传递参数 使用ref声明的参数是引用参数，使用引用方式传递。\nC#和Java一样，基本数据类型默认按值传递，其他类型按引用传递。而且C#还可以通过装箱对基本数据类型进行引用传递：\n1 2 3 4 5 int a = 12; object o = (object)a; // 使用装箱强制传递a的引用 func(o); 所以ref的作用可能只是让基本数据类型进行引用传递吧。\nin和out参数 所有参数默认是in参数。\nout参数指明此参数可以在不进行初始化的情况下按引用方式传递。并且当调用函数时，需要显式指出是out参数：\n1 2 3 4 5 6 7 8 private static void inc(in int value, out int outvalue) { outvalue = value + 1; } // Main中 int result; // 使用out关键字显式指定out参数 inc(1, out result); 数组参数/不定参数 说是数组参数，其实表现得更像是不定参数。\n即将数组当做参数(但数组的长度不是固定的)，有如下规定：\n必须使用params指定数组参数 必须放参数列表最后 1 2 3 4 5 private static void printList(params int[] list) { foreach (var item in list) { Console.WriteLine(item); } } 紧凑表示法和Lambda 1 void Sum(int a, int b) =\u003e a + b; 这有点像Lambda：\n1 2 Func lambda = (int a, int b) =\u003e { return a + b; }; 一些琐碎知识点 类型隐式转换 不同类型之间不能转换（如枚举到整型/整型到枚举） 相似类型之间不能进行窄缩转换（如long不能到int，double不能到float，float不能到int） 注意：由于以上的规则，int/float是不能转换到bool的，这意味着\n1 2 3 4 int a = 3; if (a) { Console.WriteLine(\"a\"); } 是无法通过编译的\nvar 作用同C++11的auto\n可为null的类型 和Swift一样，使用type?来表示此变量可以接受null：\n1 2 int a; // 不能接受null int? a; // 可以接受null 强制初始化 变量在使用前必须初始化/赋值，不然会报错。\n语句 拥有和C++一样的if，for，switch，while语句。只有foreach不一样：\n1 2 3 4 int[] arr0 = new int[]{1, 2, 3, 4}; foreach(int elem in arr0) { // ... } 相等性比较 对于值类型，使用==即可。\n对于引用类型，要判断引用的是否为同一变量，使用Syste.Object.ReferenceEquals(a, b)。\n对于浮点数，可以使用Float.Epsilon和Double.Epsilon辅助判断。\n条件编译和#define系列语句 没错C#是有这些东西的，而且和C++的用法一模一样。\n访问修饰符 public,private,protected: 同C++ internal：仅可访问当前程序集 protected internal：仅可访问此类，此类的派生类和同一程序集中的类 private internal：此类或同一程序集中的类 程序集 在一个大项目中可能包含多个小项目，这些小项目就是程序集。\n所以程序集可以是可执行文件或者链接库。\n常用数据结构 使用数据结构前（除了数组）必须包含System.Collections\n数组 数组和声明和Java如出一辙：\n1 2 3 4 5 6 7 8 // 一维数组 int[] arr0 = new int[5]; int[] arr1 = new int[]{1, 2, 3, 4}; int[] arr2 = {1, 2, 3, 4}; // 二维数组 int[,] arr3 = new int[1, 2]; int[,] arr4 = {{1, 2}, {3, 4}}; 元素一定会被初始化。基本数据类型初始化为0，bool值为false，可为null的值初始化为null。\n类对象会调用默认构造函数。\n注意二维数组和交错数组的区别（交错数组是数组的数组，每个数组的长度可以不一样）：\n1 2 3 4 5 // 这是交错数组 int[][] arr5 = new int[3][]; arr5[0] = new int[2]; arr5[1] = new int[3]; arr5[2] = new int[4]; 元组 和C++的Tuple类似：\n1 2 3 (double a, int b) t2 = (2.3, 4); t2.a; t2.b ArrayList和List 是简单形式的std::vector，底层是数组，可以自动扩容。缺点是他不是个泛型类，其内部存储的是Object类型，每次放入/取出元素还要装/拆箱。\n而List则是纯纯的std::vector，其是泛型类。注意List的底层是数组而不是链表，不要和C++弄混了。\nHashTable和Dictionary\u003cK,V\u003e 同C++中的std::unordered_map，底层是哈希表。HashTable存储的也是Object类型，需要拆/装箱。而Dictionary是泛型。\nHashSet 同C++的std::unordered_set，底层是哈希表，表示数学意义上的集合。\nQueue, Stack 队列和栈\nSortedList\u003cK,V\u003e和SortedDictionary\u003cK,V\u003e 自动排序的数组和红黑树（注意SortedDictionary底层是红黑树）\nListDictionary和LinkedList 分别是单链表和双向链表\nBitArray 存储位的Array，对二进制位优化了。\nHybridDictionary 混合了HashTable和ListDictionary的结构，数据量小于8时使用ListDictionary，大于8时将数据移动到HashTable中并使用HashTable管理。\n字符串 字符串的关键字是string，你也可以使用System.String类型（这两个是一个东西）。\nC#的string结尾没有'\\0'终止符。\n和Java一样，字符串初始化之后是不可变的。所以如下代码只是将新生成的字符串赋值给str1：\n1 2 3 4 string str1 = \"hello\"; string str2 = \"world\"; str1 += str2; // 先生成字符串\"helloworld\",然后赋值给str1。 这也意味着使用str1[0]方式获得的字符不可被更改。\n一些初始化方式 1 2 3 4 5 string s1 = \"hello world\"; // 最普通的初始化 string s2 = @\"C:\\Program Fileype\\asset\"; // 忽略所有转译字符的初始化（包括换行符等） char[] chars = {'h', 'e', 'l', 'l', 'o'}; string s3 = new string(chars); // 使用字符数组构造初始化 字符串格式化 使用String.Format可以格式化：\n1 string s = String.Format(\"{0}'s age = {1}\", \"XiaoMing\", 19); 空字符串 将String.Empty赋值以得到空字符串。这比让字符串接收null更好（避免NullException）。\nStringBuilder 同Java，StringBuilder创建缓冲区保存所有字符，这意味着可以就地更改字符串内容而不是创建新字符串。\n1 2 3 4 System.Text.StringBuilder builder = new System.Text.StringBuilder(\"hello world\"); builder.Append('d'); // 在末尾增加字符 builder[0] = '3'; // 更改字符 严格意义上来说StringBuilder更像C++中的std::string。\n使用ToString()成员方法返回string。\n委托 委托说白了就是观察者模式的一种简化，只不过C#做到语言里面去了。\n使用delegate创建委托，相当于函数指针。\n1 public delegate int PerformCalculation(int x, int y); 此委托可以指向任意参数为两个整数，返回值为整数的函数。\n声明委托变量：\n1 PerformCalculation pf; 可以给委托变量使用+,+=增加委托函数，使用-,-=去除委托函数。当一个委托中含有多个函数，他就是个多播委托。\nLambda表达式是一种特殊形式的委托。\n优雅输出 使用Console.WriteLine()进行输出。\n使用{0}指定第0个参数，{1}指定第1个参数：\n1 Console.WriteLine(\"{0}'s age is {1}\", \"XiaoMing\", 19); 使用$\"\"来允许字符串内插：\n1 2 int a = 123; Console.WriteLine($\"a = {a}\"); 泛型 类似于Java的泛型：\n1 void Sum\u003cT\u003e(T a, T b) =\u003e a + b; 只需要简单的在函数/类/接口/结构后面增加泛型参数就行了。\n也可以对泛型参数进行约束（类似C++20的Concept）：\n1 2 3 4 5 interface Restrict { } class Generic\u003cT\u003e where T: Restrict {} 这里要求T必须是实现了Restrict的类型。\n约束存在两种：\n对继承的约束，比如要求T继承于XX，实现于XX接口等 对类型约束，比如T必须为值类型，必须为引用类型，比如不可为null等 对继承的约束好理解，对类型的约束语法如下：\n1 class MyClass\u003cT\u003e wherer T: restrict {} 其中restrict可以为如下值：\nstruct：必须为不可为null的值类型 class：必须为不可为null的引用类型 class?：可为null或不可为null的引用类型 notnull：不可为null的类型 new()：必须有公共无参构造函数，且这个约束必须最后指定（而且你没有看错，他确实有个括号） 还有各种其他约束，详见C#微软文档。\n","description":"","tags":["C#"],"title":"【C#入门笔记】从C++到C#","uri":"/posts/csharp%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-%E4%BB%8Ecpp%E5%88%B0csharp/"},{"categories":["源码分析"],"content":"最近在看UE4中的反射机制，学了一些反射的使用方式，但并不知道其实现方式。这两天上知乎看到了Ubp.a大神写的99行静态反射，所以拿来分析一下源码。\n其知乎文章在这里。\n一些小工具 这里先来看一些小工具，以方便后面接触反射核心代码。\nTStr 首先是TStr，这是个编译期字符串，其实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 template\u003ctypename C, C... chars\u003e struct TStr { using Char = C; template\u003ctypename T\u003e static constexpr bool Is(T = {}) { return std::is_same_v\u003cT, TStr\u003e; } static constexpr const Char* Data() { return data; } static constexpr std::size_t Size() { return sizeof...(chars); } static constexpr std::basic_string_view\u003cChar\u003e View() { return data; } private: static constexpr Char data[]{ chars...,Char(0) }; }; 创建一个字符串的方法是这样：\n1 TStr\u003cchar, 'h', 'e', 'l', 'l', 'o', 'w'\u003e str; 这里的模板参数C是指字符的类型，chars...则是字符串中所有的字符。\n首先看data[]的定义，他就是一个字符数组，并且在末尾增加了0，这里是将模板中的字符串存储了下来。\n接下来看Is(T)函数，这个函数判断两个TStr是否相等。注意这里虽然字符串存到了data[]中但不能使用strcmp比较，因为strcmp只能运行在运行期。这里使用std::is_same_v进行判断。 这是因为对于两个不同的字符串，他们的类型是不一样的：\n1 2 TStr\u003cchar, 'h', 'e', 'l', 'l'\u003e str1; -\u003e 类型为 TStr\u003cchar, 'h', 'e', 'l', 'l'\u003e TStr\u003cchar, 'o', 'w', 't', 'r'\u003e str2; -\u003e 类型为 TStr\u003cchar, 'o', 'w', 't', 'r'\u003e 接下来要看一下两个创建TStr的函数，但是在此之前要介绍一下std::index_sequence：\nstd::index_sequence是integer_sequence\u003csize_t\u003e的模板别名，他存储着编译期的一个序列。std::make_index_sequence则可以生成他。\n1 2 template\u003cstd::size_t... Ints\u003e using index_sequence = std::integer_sequence\u003cstd::size_t, Ints...\u003e; 注意，这个类型主要是为了用在模板参数中，它并不像数组一样，他只有一个成员函数size()，这意味着你不能通过seq[0]这种方式得到他的值。\n要想得的值只能使用一些模板技术（例子来自cppreference）：\n1 2 3 4 5 6 7 8 9 10 11 template\u003ctypename T, T... ints\u003e void print_sequence(std::integer_sequence\u003cT, ints...\u003e int_seq) { std::cout \u003c\u003c \"The sequence of size \" \u003c\u003c int_seq.size() \u003c\u003c \": \"; ((std::cout \u003c\u003c ints \u003c\u003c ' '),...); // 这里是Fold Expression std::cout \u003c\u003c '\\n'; } int main() { print_sequence(std::integer_sequence\u003cunsigned, 9, 2, 5, 1, 9, 1, 6\u003e{}); } 现在回头来这两个函数：\n1 2 3 4 5 6 7 8 9 template\u003ctypename Char, typename T, std::size_t... Ns\u003e constexpr auto TSTRHI(std::index_sequence\u003cNs...\u003e) { return TStr\u003cChar, T::get()[Ns]...\u003e{}; } template\u003ctypename T\u003e constexpr auto TSTRH(T){ return TSTRHI\u003ctypename decltype(T::get())::value_type,T\u003e(std::make_index_sequence\u003cT::get().size()\u003e{}); } T::get()[NS]...是指从T类型中调用静态函数get()，这个get会返回一个可索引的对象，然后将此对象的内容在这里展开：\n1 2 3 4 TSTRHI(std::index_sequence\u003c1, 2, 3\u003e()); // 展开成 return TStr\u003cChar, T::get()[1], T::get()[2], T::get()[3]\u003e 其他的编译期函数 1 2 3 4 5 6 7 template\u003cclass L, class F\u003e constexpr std::size_t FindIf(const L\u0026, F\u0026\u0026, std::index_sequence\u003c\u003e) { return -1; } template\u003cclass L, class F, std::size_t N0, std::size_t... Ns\u003e constexpr std::size_t FindIf(const L\u0026 l, F\u0026\u0026 f, std::index_sequence\u003cN0, Ns...\u003e) { return f(l.template Get\u003cN0\u003e()) ? N0 : FindIf(l, std::forward\u003cF\u003e(f), std::index_sequence\u003cNs...\u003e{}); } 这两个函数是经典的递归式模板函数，用于在一个index_sequence中找到特定的数。其中f是谓词函数，用于对数字进行条件判断。\n其他的函数也大同小异（只是功能不同），就不细说了。\n核心的反射实现 Field的实现 Field是保存类中成员的结构，是反射的核心，它是存储着类中成员变量和函数的容器：\n1 2 3 4 5 template\u003cclass Name, class T, class AList\u003e struct Field : FTraits\u003cT\u003e, NamedValue\u003cName, T\u003e { AList attrs; constexpr Field(Name, T v, AList as = {}) : NamedValue\u003cName, T\u003e{ v }, attrs{ as } {} }; 可以看出他存储了NamedValue和attrs。其中attrs是AList类型，这是用于给类型附加用户自定义信息的，属于这个反射系统中可有可无的东西，我们不管他。\n先看继承的第一个类FTraits：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 template\u003cbool s, bool f\u003e struct FTraitsB { static constexpr bool is_static = s, is_func = f; }; // [1] template\u003cclass T\u003e struct FTraits : FTraitsB\u003ctrue, false\u003e {}; // default is enum // [2] template\u003cclass U, class T\u003e struct FTraits\u003cT U::*\u003e : FTraitsB\u003cfalse, std::is_function_v\u003cT\u003e\u003e {}; // [3] template\u003cclass T\u003e struct FTraits\u003cT*\u003e : FTraitsB\u003ctrue, std::is_function_v\u003cT\u003e\u003e{}; // static member FTraits类型系列是用于自动判断类型T（和U）是类中的哪种成员。s代表是否是类中静态成员，f代表是否是函数。\n[1]处的是默认值，即默认是类的静态变量。\n[2]处的T U::*是指向类成员指针的表示形式(不清楚的看我的这篇文章），所以置s为false，但到底是不是函数还得用std::is_function_v判断一下。\n[3]处的T*一定是静态成员，所以置s为true，但可能是指向变量的指针或者函数指针，所以要额外对f进行判断。\n然后再看NamedValue：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 template\u003cclass Name, class T\u003e struct NamedValue : NamedValueBase\u003cName\u003e { T value; static constexpr bool has_value = true; constexpr NamedValue(T v) : value{ v } {} template\u003cclass U\u003e constexpr bool operator==(U v) const { if constexpr (std::is_same_v\u003cT, U\u003e) return value == v; else return false; } }; template\u003cclass Name\u003e struct NamedValue\u003cName, void\u003e : NamedValueBase\u003cName\u003e { static constexpr bool has_value = false; template\u003cclass U\u003e constexpr bool operator==(U) const { return false; } }; NamedValue从广义上来说就是存储了个有名字的变量value（名字在其父类NamedValueBase的name成员中）。在这里它是存储着成员字段。\n然后看一下他的父类NamedValueBase，其实他的父类很简单，就是存了一个std::string_view，即成员的名称：\n1 2 3 4 5 template\u003cclass Name\u003e struct NamedValueBase { using TName = Name; static constexpr std::string_view name = TName::View(); }; 最后再通过Field的用法来彻底弄清楚这个玩意的用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 struct Vec { float x; float y; float norm() const { return std::sqrt(x*x + y*y); } }; template\u003c\u003e struct Ubpa::USRefl::TypeInfo\u003cVec\u003e : TypeInfoBase\u003cVec\u003e { static constexpr FieldList fields = { Field {TSTR(\"x\") , \u0026Type::x }, Field {TSTR(\"y\") , \u0026Type::y }, Field {TSTR(\"norm\"), \u0026Type::norm}, }; }; 这里的Field的Name模板参数是TSTR(\"x\")是个TStr，T则是float Vec::*也就是我们说的指向类成员的指针。那么这个时候NamedValue类就存储了成员的名字（TSRT(\"x\")中的data成员，只不过是通过std::string_view的方式得到的，存在其父类NamedValueBase的name中）和指向成员的指针（NamedValue中的value）。\n然后FTraits父类此时也存储了能够判断此成员是否静态，是否是函数的信息。所以总结下来，Field就是存储了指向类成员指针和名字的类，并且还能判断指向的是静态的还是非静态的，是函数还是变量。\n上面代码中有一个FieldList，它是ElemList的子类，存储着所有的Field并且提供了查找，增加功能。\nElemList ElemList是作者自己造的一个能够存储任意类型的列表，其内部使用了tuple实现。简单来说就是个tuple的封装，但比起tuple提供了更多的操作（如查找，询问是否包含，对每个元素进行操作和增加元素等）。操作主要是利用经典的递归模板技术，我们这里主要着眼于使用tuple存储各个类型的技巧：\n1 2 3 4 5 6 7 8 9 10 template\u003ctypename...Es\u003e struct ElemList { std::tuple\u003cEs...\u003e elems; static constexpr std::size_t size = sizeof...(Es); constexpr ElemList(Es... elems) : elems{ elems... } {} //... }; tuple可谓是实现反射中的核心和大哥大，因为它能够存储不同类型的变量。这里ElemList就是将Es类型存放到了tuple中。\nTypeInfoBase TypeInfoBase主要是存储着父类的信息。其存储的类型都是Base类的子类：\n1 2 3 4 template\u003cclass T, bool IsVirtual = false\u003e struct Base { static constexpr auto info = TypeInfo\u003cT\u003e{}; static constexpr bool is_virtual = IsVirtual; }; 可以通过这个类得到类的信息，以及是否是虚类。\n我们简单地看看TypeInfoBase：\n1 2 3 4 5 6 7 8 template\u003cclass T, typename... Bases\u003e struct TypeInfoBase { using Type = T; static constexpr BaseList bases{ Bases{}... }; // ... }; 他将所有的基类全部存储到BaseList，这是ElemList的子类：\n1 2 3 4 template\u003ctypename...Bs\u003e struct BaseList : ElemList\u003cBs...\u003e { constexpr BaseList(Bs... bs) : ElemList\u003cBs...\u003e{ bs... } {} }; 这里的Base是你使用此库时手动加上去的：\n1 2 3 4 5 6 7 8 9 template\u003c\u003e struct Ubpa::USRefl::TypeInfo\u003cC\u003e : TypeInfoBase\u003cC, Base\u003cA\u003e\u003e // \u003c--- 这里 { static constexpr AttrList attrs = {}; static constexpr FieldList fields = { Field {TSTR(\"c\"), \u0026Type::c}, }; }; 而且你得先对A类进行反射（也Base类要知道A类的反射信息）。\n其他的TypeInfoBase成员函数就是普通的查找，增加等操作了（都是ElemList中的操作），没什么可说的。\n总结 UML如下\n其中TypeInfo是一个空类，用户需要全特化他并且将自己类型的信息放入（使用Field）。\n其实说难也不难，都是模板的常见操作，但是合起来就觉得挺麻烦的了。\n","description":"","tags":["cpp"],"title":"USRefl源码分析","uri":"/posts/usrefl%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["language"],"content":"本文是对Lua语言的回顾复习。顺便作为快速入门Lua的指南。\n参考书本《Programming in Lua 4th》\n基本知识 Lua是一门弱类型的动态语言（类似Python），拥有很快的速度。\n变量类型，声明和使用 变量的类型有\nnil - 表示空，将变量置为nil来提示Lua回收此变量内存（删除此变量） boolean - true和false number - 包含了所有数类型（不区分整数和浮点数，但有整数表示形式和浮点数表示形式（有些函数要求不能传入浮点数形式）） string function table userdata thread - 线程和协程 其中userdata是C语言的数据。\n使用type函数可以获得类型对应的字符串\n和Python一样直接使用即可：\n1 a = 123 使用local声明局部变量：\n1 local a = 123 局部变量声明应该用在函数局部变量，不想被其他模块使用的全局变量，不想被其他模块使用的函数，if,while,repeat等块内的局部变量中。\n只要不声明为local，那么他们就是在全局中可用的。\nLua的四则运算 需要注意的是除法和取余：\n除法和Python一样，分为整除//和浮点除法/。\n取余是可以对小数进行的：\n1 2 3 x = math.pi x - x%0.01 --\u003e 3.14 x - x%0.001 --\u003e 3.141 这种方法用来保留小数到指定位数。\n究其原因是因为Lua对取余的计算公式为\na % b == a - ((a // b) * b)\n逻辑运算符 \u003e，\u003c，\u003e=，\u003c=，==，~=\n类型转换 很奇怪的是，我们可以用按位或运算符来将浮点数类型转化为整数类型：\n1 2 2^53 --\u003e 9.007199254741e+15 (float) 2^53 | 0 --\u003e 9007199254740992 (integer) 字符串 字符串存储Unicode字符。\n字符串使用#来获得长度：\n1 2 a = \"hello\" #a --\u003e 5 使用 ..来连接：\n1 \"hello \" .. \"world\" --\u003e hello world 注意：连接的语法是 ..（有一个空格在前面），没有此空格会报错。\nLua也会将其他类型在连接时隐式转换为字符串。\n使用单引号和双引号的结果是一样的（都不会忽略转义符）\n长字符串使用[[包裹：\n1 2 3 4 5 6 7 page = [[ \u003chtml\u003e \u003chead\u003e \u003ctitle\u003e review Lua \u003c/title\u003e \u003c/html\u003e \u003c/head\u003e ]] 和Perl一样，Lua会在运算时如果可能，会将字符串转换为数字（不能转换会报错）：\n1 2 \"10\" + 1 --\u003e 11 \"11qqa\" + 1 --\u003e Error! 可以使用tonumber()函数强制转换，无法转换返回nil。\n同理，非字符串可以通过tostring()转换到字符串。\nTable Table是Lua中非常非常重要的数据结构。其本身的表现像个字典和数组的混合体：\n1 2 3 4 5 6 7 8 9 10 11 a = { name = \"visualgmq\", age = 12321 } a.name -- 使用成员访问的格式访问 a['name'] -- 使用字典格式访问 b = { \"apple\", \"juice\", \"orange\" } b[1] --\u003e apple b[2] --\u003e juice b.1 --\u003e Error! 不能使用成员访问格式 注意下标从1开始！\nTable的本质正如其名称：是个哈希表。当查询表内不存在的元素时会返回nil，这意味着你可以查询任意值而不产生运行时异常：\n1 2 3 a[0] --\u003e nil a['unknown key'] --\u003e nil a[-1] --\u003e nil 注意到不像Python，lua没有对负数进行特化。\n同理，可以直接通过如下形式插入行键值：\n1 a['type'] = 'lua file' 当键和普通值混在一起时，普通值的按顺序编排下标：\n1 2 3 4 5 6 7 8 9 a = {11, 22, 33, key1 = 1, 44, key2 = 2} 值 下标 11 1 22 2 33 3 key1 无 44 4 key2 无 从表中移除值可以通过将其赋值为nil来实现。\n由于Table本质上是哈希表，所以对其的遍历是无序的。\n循环 首先是for-each循环：\n1 2 3 4 5 6 7 8 9 t = {10, \"hello\", type = \"lua\"} for k, v in pairs(t) do print(k, v) end --\u003e 1 10 --\u003e 2 hello --\u003e type lua 如果想让k只是下标，请将pairs用ipairs替换：\n1 2 3 4 5 6 7 for k, v, in ipairs(t) do print(k, v) end --\u003e 1 10 --\u003e 2 hello --\u003e 3 lua 然后是区间循环：\n1 2 3 for k = start_value, stop_value, step do doSomething() end 循环是在闭区间[start_value, stop_value]内进行的。\n除此之外还有while和repeat-until循环：\n1 2 3 while condition do doSomething() end 1 2 3 repeat doSomething() until condition 注意：循环只有break和goto，没有continue！我们可以用repeat-until仿一个：\n1 2 3 4 5 6 7 8 for i = 0, 10 do repeat if i == 2 then break end print(i) untile true end 或者使用goto：\n1 2 3 4 5 6 7 for i = 0, 10 do if i == 2 then goto label end print(i) :: label :: end 注意label的语法：:: label-name ::\n条件判断 1 2 3 4 5 6 7 if condition1 then doSomething1() elseif condition2 then doSomething2() else doOther() end 函数 函数定义：\n1 2 3 function FuncName(arg1, arg2, ..., argn) doSomething end 使用可变参数：\n1 2 3 4 5 6 7 8 9 10 11 12 -- ... 用来声明可变参数 function FuncName(arg1, ...) for k, v in {...} do -- 将可变参数当做表来遍历 print(k, v) end local args = {...} -- 捕获不定参数列表 print(#args) -- 和操作列表一样操作不定参数 -- 或者使用select来对不定参数操作 local len = select('#', ...) -- 获得长度 local first = select(1, ...) -- 获得第一个元素 end 匿名函数：\n1 a = function(arg) print(arg) end 返回多值的函数：\n1 2 3 4 5 function MultiRet() return 1, 2 end first, second = MultiRet() 函数内部的局部变量必须使用local声明，不然在函数第一次调用后这些非local变量将会留存下来，在外部也可使用（和Js一样）。\n高阶知识 闭包Closures 在Lua中函数也是一等公民，函数可以像变量一样传递来传递去。同样地Lua也会对尾递归优化。所以说Lua有函数式编程范式。\n闭包使用函数表示，其实他就是函数，不过是一种特定情况下的函数：\n函数内部拥有函数，并且此函数使用了外层函数的变量时，这个函数就叫闭包：\n1 2 3 4 5 6 7 function get_addone_func() local i = 0 return function() i += 1 return i end end 这时我们调用get_addone_func得到内部的闭包，然后我们再调用闭包会发生什么事情？\n在C++中因为i已经被销毁了所以会产生未定义行为。\nLua中使用”上值(upvalue)“来保存闭包使用的外层变量。并且不同的闭包保存的变量是不一样的（相当于拷贝了此变量）：\n1 2 3 4 5 6 7 8 f1 = get_addone_func() f2 = get_addone_func() print(f1()) -- f1的upvalue中存着i，输出1 print(f1()) -- 输出2 print(f2()) -- f2是新的闭包，存的i和f1的不是一个i，输出1 print(f2()) -- 输出2 模块和包 使用require来导入模块：\n1 2 3 local m = require 'math' -- 或者 require('math') print(m.pi) 一定要用变量接收require返回值（其本质上是获得一个表，后面看到如何定义自己的包时会了解到），不像Python那样可以直接用模块名。\n编写自己的模块的方法：\n本质上是将所有需要导出的函数，变量都放在一个表里，然后返回这个表：\n1 2 3 4 5 6 7 8 9 local MyModule = {} -- 定义要返回的表 M.version = 0.1.0' -- 增加常量 function M.about() { -- 增加函数 return \"MyModel version \" .. M.version } return MyModule -- 返回表 元表和元数据 元表（metatable）是实现高级功能的重要部分。\n所有的实例都可以拥有元表。Table和userdata有自己独立的元表，其他类型中，每个类型都只有一个元表，所有此类型的实例都共享这一个元表（或者没有元表）。\n使用getmetatable(instance)来获得原表，使用setmetatable(instance, metatable)来设置实例的元表。\n元表中有很多元方法，比如__index,__newindex,__add等：\n元方法 功能 __index 通过键访问table的时候，如果没有此键，会在其metatable中的__index属性中寻找（如果此属性是个表的话），或者调用此元方法（如果是函数的话） __newindex 当给不存在的键赋值时，会调用此方法。如果键存在则不会调用 __add 使用+操作符时会调用 __sub 使用-操作符时会调用(表示减法时) __mul 使用*操作符时会调用 __div 使用/操作符时会调用 __idiv 使用//操作符时会调用 __mod 使用%操作符时会调用 __unm 使用-操作符时会调用(表示取反的时候) __concat 使用..操作符时会调用 __eq 使用==时 __lt 使用\u003c时 __le 使用\u003c=时 __shl 调用左移运算时 __shr 调用右移运算时 __tostring 用于更改表的输出行为 __call 当此表以函数形式调用时（如myTable(param)）会调用此函数 面向对象编程 面向对象的函数调用法 首先是面向对象的函数调用法：\n1 2 3 4 Person = {name = 'lua leaner'} function Person:introduce() print(self.name) end 使用:来定义成员方法，在调用此方法时，会隐含一个参数self表示调用者本身。\n但需要注意的是，虽然会隐含此self，但如果你不传入的话它是不会自动传入的：\n1 2 3 4 5 -- 正确调用 Person.introduce(Person) -- 错误调用 Person.introduce() 要想让其自动传入，需要使用:：\n1 Person:introduce() -- 等价于 Person.introduce(Person) 需要注意，定义函数时使用:和调用函数时使用:没有关联，你可以定义普通函数却使用:调用法，或者反过来：\n1 2 3 4 5 6 7 function Person.introduce(self) print(self.name) end Person.introduce(Person) -- 或者 Person:introduce() 模拟面向对象 首先是成员封装，这个不必多言，使用表可轻松搞定：\n1 2 3 4 5 Person = { name = 'learner' } function Person:introduce() print('Person:', self.name) end 这里注意的是构造函数。因为Lua的表是传引用的，我们构造新对象时必须使用其他方法，其中一种方法是设置元表：\n1 2 3 4 5 6 7 8 function Person:new() local o = {} setmetatable(o, {__index = self}) return o end -- 调用 new_person = Person:new() 注意堆元表的设置：回想__index元方法的功能：如果查询此表时没有对应键，则在此元方法中查找。我们这里的__index是个表，所以他直接在此表中查找，也就是在Person表中查找。\n现在Person返回的表结构如下:\n1 2 表内容：{} 元表内容：{__index = {name = 'leaner'}} 然后是继承，可以通过重写子类元表的__index键值：\n1 2 3 4 5 6 7 8 Child = {age = 123} function Child:new() local o = {} setmetatable(self, {__index = Person}) setmetatable(o, {__index = self}) return o end 这是一个嵌套的设置，最后返回的o的结构如下：\n1 2 3 4 5 6 7 8 9 10 表：{} 元表：{__index = {age = 123, __index = {name = 'learn'} } } 即 {__index = Child} Child的元表 {__index = Person} 这就是个元表的嵌套。继承就是将父类的表放到子类元表的__index元方法中。\n通过上述步骤，就可以明白教程中实现继承的方法了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Person = {name = 'learner' } -- 首先定义父类的数据 function Person:GetNam() return self.name end -- 定义父类的方法 function Person:new(o) o = o or {} -- 如果o不是空，我们要保留o中的元素（为了后面的继承） setmetatable(o, {__index = self}) -- 设置元表的__index为自己 return o end -- 然后是子类Child Child = Person:new({age = 123}) -- 从父类创建子类，并且定义了新的子类成员age --[[ 此时Child的内容为： 表：{age = 123} 元表：{__index = Person} 这样就即保留了Child的成员，又可以查找到Person的成员 --]] -- 子类的构造方法 function Child:new(o) o = o or {} setmetatable(o, {__index = self}) return o end 注意，由于Lua的灵活性，实现OO不仅这一种方法，你完全可以使用自己的方法实现OO。\n协程 协程，即相互协同的程序。协程有点类似线程，他有自己的栈，局部变量，并且和其他协程共享全局变量。与线程不同的是，线程可以同时执行，协程则是一个接一个的执行，在同一时间只能有一个协程在执行，并且只有在明确要求此协程放弃执行的时候才会转到下一个协程去执行。\n协程就是协程，不是线程。\nCPU执行单位是线程，不是什么协程。\n协程，是同步执行，不是并行，只是切了一个上下文了，为你保存原来的上下文而已。\n切到第二个协程时，原来的协程处于挂起状态。\nCPU不知道协程，协程也不是CPU创建的。协程是用户在线程上创建的“用户态线程”。\n使用coroutine.create(func)来创建一个协程，使用coroutine.resume(co)来执行一个协程。\n协程在创建完成后默认是暂停状态。\n也可以使用coroutine.wrap(func)来返回一个函数，只要你调用了此函数，就会进入协程。\n使用coroutine.status(co)获得协程状态：\n1 2 3 4 5 co = coroutine.create(function() print('coroutine!') end) print(coroutine.status(co)) -- suspend coroutine.resume(co) print(coroutine.status(co)) -- dead 对已经dead的协程使用resume会返回false。\n使用coroutine.yield()来挂起当前协程，即主动暂停当前协程的运行，转去执行其他协程:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 co1 = coroutine.create( function() print('co1 start') coroutine.yield() print('co1 end') end) co2 = coroutine.create( function() print('co2 start') coroutine.yield() print('co2 end') end) coroutine.resume(co1) --[[ 输出 co1 start true --]] coroutine.resum(co2) --[[ 输出 co2 start true --]] coroutine.resume(co1) --[[ 输出 co1 end true --]] yield可以有参数，参数是调用resume后的返回值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 co = coroutine.create( function(a) print('a') a=a+1 coroutine.yield(a) end) coroutine.resume(co, 1) -- 返回(true, 1) -- 打印 2，然后协程暂停 coroutine.resume(co, 100) -- 返回(true, 2) 第一次调用resume时，参数就会被传入协程并保存。所以在此后再调用resume，无论传入什么样的参数都会被忽略，他只会用内部保存的参数。\n协程在IO多路复用中的优势 在网络程序中，我们会打开很多的socket。socket会做很多的IO操作。\n阻塞式IO，会将需要读取的socket放入队列中等待IO，在此期间运行其他线程。这种情况下一个socket只能由一个线程管理。\n非阻塞式IO，IO不会导致阻塞，但是需要频繁检查IO是否有数据，会增加CPU空耗时间。\nIO多路复用，由操作系统提供支持，把需要等待的socket放入监听集合，通过一次系统调用同时监听多个socket，有socket需要处理时就拿出来处理。这也是现在大多的网络程序使用的方法。\nIO多路复用的主要函数是select，poll和epoll。\n但是即使是IO多路复用也有问题。这个时候协程可以在这种环境中发挥很好的功用。\n每当监听的socket有新的连接诞生了，就为此新连接创建一个协程指向处理函数，每当需要等待IO时就主动让出，这样效率就会大大提高。\nLua和C交互 参考 《Programming in Lua 2th》\n博客园-风雨缠舟-Lua的闭包详解\n博客园-会飞的斧头-lua线程和协程\n","description":"","tags":["lua"],"title":"Lua拾遗","uri":"/posts/lua%E6%8B%BE%E9%81%97/"},{"categories":["算法和数据结构"],"content":"本文介绍了常用的字符串Hash算法。\n杂项算法 杂项哈希算法是从各个地方搜集来的哈希算法。这里只列出几个有名的，所有的可以看参考中的第一条链接。\n所有算法最后都需要将hash值限定在哈希表的长度中。这里默认哈希表长度为0x80000000。\nBKDRHash 在《C语言程序设计中提出》：\n1 2 3 4 5 6 7 8 unsigned int BKDRHash(const char* str) { unsigned int seed = 131 // 可以是31, 131, 1313, 13131, ... unsigned int hash_code = 0; while (*str) { hash = hash * seed + (*str++); } return hash \u0026 0x7FFFFFFF; } SDBMHash SDBM项目使用的哈希函数，声称对所有的数据集有很好地分布性。\n1 2 3 4 5 6 7 unsigned int SDBMHash(const char* str) { unsigned int hash = 0; while (*str) { hash = (*str++) + (hash \u003c\u003c 6) + (hash \u003c\u003c 16) - hash; } return hash \u0026 0x7FFFFFFF; } ELFHash Unix系统上广泛使用的哈希函数。\n1 2 3 4 5 6 7 8 9 10 11 12 unsigned int ELFHash(char* str) { unsigned int hash = 0; unsigned int x = 0; while (*str) { hash = (hash \u003c\u003c 4) + (*str++); if ((x = hash \u0026 0xF0000000L) != 0) { hash ^= (x \u003e\u003e 24); hash \u0026= ~x; } } return hash \u0026 0x7FFFFFFF; } DEKHash 是高德纳在《程序设计艺术》中提出的：\n1 2 3 4 5 6 7 unsigned int DEKHash(char* str) { int hash = strlen(str); while (*str) { hash = (hash \u003c\u003c 5) ^ (hash \u003e\u003e 27) ^ (*str ++); } return hash \u0026 0x7FFFFFFF; } Java String Hashcode 这是Java的字符串类的Hash算法，简单实用高效。直接从JDK6里面拿出来的代码：\n1 2 3 4 5 6 7 unsigned int JDK6Hash(char* str) { int hash = 0; while (*str) { hash = hash * 31 + *str++; } return hash \u0026 0x7FFFFFFF; } Lookup3 MD5 MD5一般用在加密方面。MD5总是会产生16字节结果。MD5有如下优点：\n返回长度总是一样的 无法从结果反推 有高度离散型，输出结果没有任何规律 抗碰撞性，想找到两个完全一样的MD5值是很难的 MD5主要用于如下情况：\n密码保护：当我们注册账号时， 服务器并不是记录我们的账号密码，而是记录密码的MD5。这样黑客就不能从服务器获得用户密码了。 完整性校验：当传输大文件时，由于网络的不稳定，可能导致文件有部分丢失。这时可以先传一下文件的MD5，等客户端收到后校验MD5即可。如果MD5一致则没问题。 数字签名：当下载文件时，为了防止被黑客篡改，可以事先发布文件的MD5码和大小，然后用户下载之后再进行校验以确保安全性。 云盘秒传：上传大文件的时候，计算文件MD5并且和数据库内的文件MD5对比。如果一致，说明数据库里有此文件，就不用上传了。 MD5算法是个固定算法，算法很繁琐，也没有什么数学原理可说的，这里直接贴一个我认为挺好的视频教程：\n{% bilicard BV1u44y1z7t1 %}\nCRC 循环冗余校验码。主要是用在通信领域中校验信息的。\n这个算法书上都有讲解，我也不再重复。直接放个视频连接：\n{% bilicard BV1V4411Z7VA %}\n参考 CSDN 字符串哈希函数\n","description":"","tags":["算法"],"title":"常用字符串Hash算法","uri":"/posts/%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2hash%E7%AE%97%E6%B3%95/"},{"categories":["game development"],"content":"文本是Games101 Material and Appearance的笔记\nBRDF材质 漫反射材质(Diffuse/Labertian Material) 我们知道BRDF其实就是对光线从表面反射出去的描述，所以BRDF就对应着漫反射材质。\n这里我们假设，所有的入射光都是一样的，并且物体自己不发光，不吸收光（即反射出去的光和入射光一样），那么渲染方程就可以写成：\n$$ L_o(\\omega_o) = \\int_{\\Omega^+}f_r L_i(\\omega_i)\\cos{\\theta}\\text{d}\\omega_i = f_rL_i\\int_{\\Omega^+}\\cos{\\theta}\\text{d}\\omega_i $$\n最后的积分是对上半球的曲面积分，根据$\\omega_i = \\sin{\\theta_i}\\text{d}\\theta\\text{d}\\phi$可以积分得到：\n$$ L_o = f_rL_i\\pi $$\n那么有\n$$ f_r = \\frac{L_o}{L_i \\pi} $$\n将$L_o/L_i$记作$\\rho$，可以得到BRDF：\n$$ f_r = \\frac{\\rho}{\\pi} $$\n这里的$\\rho$就是反射率（$\\rho \\in [0, 1]$）。在实际应用中可以是表面的颜色。\nGlossy材质(Glossy Material) Glossy材质是一种类似于金属表面的材质，但是表面没有金属那么粗糙：\n![Glossy Material](/assets/glossy\\ material.png)\n反射和折射材质(Ideal reflective/refractive material) 就和实际的透明材质一样，光线有一部分反射，另一部分折射。\n反射的方向我们可以通过入射方向和法线计算得到：\n这里由反射的定义知，$\\theta_i = \\theta_o$，入射光线的反方向是$\\omega_i$，我们要求出射光线$\\omega_o$。\n这里假设法向量是单位向量，那么我们有$\\vec{\\omega_i} + \\vec{\\omega_o} = 2\\vec{n}Proj_{\\vec{n}}\\vec{\\omega_o}$\n然后使用点乘表示投影得到公式$2\\vec{n}\\frac{(\\vec{\\omega_o}\\cdot\\vec{n})}{|\\vec{n}|} = \\vec{\\omega_i} + \\vec{\\omega_o}$\n所以我们就可以求得:\n$$ \\vec{\\omega_o} = 2\\vec{n}(\\vec{\\omega_i}\\cdot \\vec{n}) - \\vec{\\omega_i} $$\n折射则相对复杂一点。要计算折射的向量，就必须用到菲涅尔定理：\n$$ \\frac{n_1}{n_2} = \\frac{\\sin{\\theta_1}}{\\sin{\\theta_2}} $$\n这里$n_i$是介质的折射率，$\\theta_i$是光线和平面发现的夹角。\n通过很简单的计算就能得出折射光线和法线的夹角了。\n微表面材质(Microfacet Material) 各向异性/各项同性材质(Anisotropic/Isotropic Material)","description":"","tags":["图形学"],"title":"使用BRDF定义材质","uri":"/posts/%E4%BD%BF%E7%94%A8brdf%E5%AE%9A%E4%B9%89%E6%9D%90%E8%B4%A8/"},{"categories":["game development"],"content":"本文介绍了蒙特卡洛算法，重要性采样，拟蒙特卡洛算法。\n蒙特卡洛算法 蒙特卡洛算法是一种使用概率方法计算定积分的方法。\n概率论回顾 首先回顾一些概率论知识并定义一些符号：\n概率密度函数（Probability Density Function, PDF）：\n对任意的随机变量$X_i$，其pdf是其在这一点的概率的函数：\n$$ p_i = pdf(X_i) $$\n比如投骰子，记$X_i$为投出$i$点的概率，那么有：\n$pdf(X_i)$ $X_i$ $\\frac{1}{6}$ 1 $\\frac{1}{6}$ 2 $\\frac{1}{6}$ 3 $\\frac{1}{6}$ 4 $\\frac{1}{6}$ 5 $\\frac{1}{6}$ 6 （一般在离散情况下我们称概率密度函数为分布率）\n累积分布函数（或简称分布函数）（Cumulative Distribution Function, CDF）:\n其定义如下：\n$$ cdf(x) = \\int_{-\\inf}^x pdf(x) \\text{d} x $$\n显然存在如下性质：\n$$ cdf(x) \\ge 0 $$\n$$ \\lim_{x\\rightarrow\\inf} cdf(x) = 1 $$\n然后是伯努利大数定律：\n设多个随机变量$X_1,X_2,...X_i$独立同分布，$f_A$是这n次独立重复实现中事件A发生的概率，$p$是事件A在每次实验中发生的概率，则对于任意的$\\epsilon \\lt 0$，有：\n$$ \\lim_{n\\rightarrow \\inf}P{|\\frac{f_A}{n} - p)| \\lt \\epsilon} = 1 $$\n也就是说，只要我们独立重复试验做的次数够多，我们就可以用A事件成功的频率去逼近A事件的概率。这也是大部分教材上对概率最初的定义。\n蒙特卡洛算法初步理解 蒙特卡洛算法就是基于伯努利大数定律而产生的算法，回想经典的求圆面积的算法，有一种投针法：\n对于半径为r圆，我们画出其最小的AABB包围盒，然后在包围盒中不停地随机投针，记总共投针的次数为$n$，针在圆内的次数为$A$，那么在我们投了无数次之后，我们就可以得到圆的面积：\n$$ S = \\frac{A}{n} 4r^2 $$\n其中$4r^2$为AABB的面积。\n这里的投针法其实就是蒙特卡洛算法，那么对于任意的函数$f(x)$，其积分记作$F(x) = \\int_a^b f(x)\\text{d}x$，根据定积分的定义，$F(x)$其实是$f(x)$围绕x轴的面积：\n比如我们这里要计算此函数在区间$[10, 15]$上的积分，我们只需要不停地对蓝色和绿色的区域进行投点，然后记录点落在蓝色区域内的数量，最后做比就可以得到积分的估计值。\n当$X_i$以某种分布进行采样时，蒙特卡洛算法变成如下公式：\n$$ F(x) = \\frac{1}{n}\\sum_{k = 1}^n\\frac{f(X_k)}{pdf(X_k)} $$\n比如你使用均匀分布进行采样，均匀分布的pdf为：\n$$ \\begin{cases} pdf(x) = \\frac{1}{b - a}, \u0026 x\\in [a, b] \\ 0, \u0026 其他 \\end{cases} $$\n那么蒙特卡洛公式就是：\n$$ F(x) = \\frac{b - a}{n}\\sum_{k = 1}^{n}f(X_k) $$\n如何从概率分布得到随机数，可以看visualgmq-随机数生成算法\n重要性采样 对于某些函数，比如\n$$ \\begin{cases} 99.01, \u0026x \\in [0, 0.01) \\ 0.01, \u0026 x \\in [0.01, 1] \\end{cases} $$\n他的图像是这样：\n如果我们要算其[0, 0.5]的积分，我们使用均匀分布的话，很显然有大部分的点其实都不会打到函数内部，所以求出来的值就会偏小。\n重要性采样就是需要根据函数的形状，来确定自己的分布函数，以便更好地得到最后的结果。选择更加贴切的分布函数可以更快地得到误差更小的结果。\n理论上，对于任意的被积函数，其最优概率密度函数为：\n$$ pdf(x) = \\frac{|f(x)|}{\\int f(x) \\text{d}x} $$\n但显然这没什么意义，因为公式中有我们要求的$f(x)$的积分。\n拟蒙特卡洛算法 拟蒙特卡洛算法的核心是不使用随机数，而是使用低差异序列。优点是积分的收敛速度更快，在同样的采样数下，误差更小。\n由于伪随机数可能产生集聚的情况，所以我们首先可以想到将积分区间平均分成多份，然后在每一份中使用一些随机数进行采样。这种方法就叫分层采样。\n而低差异序列则是不需要对采样空间进行手动分割，就可以同时具备空间平均性和随机性这两个特点。\n在介绍这些方法前，必须定义什么是差异：\n设$P={x_1, ..., x_n}$是一组位于$[0, 1]^s$下的点集，差异可以定义为：\n$$ D_n(P) = \\sup_{B \\in J}{|\\frac{A(N)}{n} -\\lambda_s(B)|} $$\n其中，s是维度，J是整个区域，B是在J中任取的一个区域，$A(B)$是在B区域内点的数量，$n$是整个区域内点的数量，$\\lambda_s{B}$则是B区域的体积。\n这个公式直白点说就是，区域B内的点和整个区域的点的比值越接近B的体积（越聚集在一起），则这些点的差异越小。（$\\sup$是指一个集合最小的上界）\n具体的生成序列的方法有很多：\nVan der Corpu Halton Hammersley Sobol 这里推荐看参考中的后两条。\n参考 知乎-蒙特卡洛积分\n知乎-低差异序列（一）\n知乎-低差异序列（二）\n","description":"","tags":["图形学"],"title":"蒙特卡洛算法","uri":"/posts/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%AE%97%E6%B3%95/"},{"categories":["game development"],"content":"本文是Games101 RayTracing3的笔记，介绍了BRDF和渲染方程。\n前置笔记：\n辐射度量学简述 BRDF 全称是双向反射分布函数。描述的是表面的入射光和反射光之间的关系的函数。定义为：\n$$ f_r(\\omega_i \\rightarrow \\omega_r) = \\frac{\\text{d}L_r(\\omega_r)}{\\text{d}E_i(\\omega_i)} = \\frac{\\text{d}L_r(\\omega_r)}{L_i(\\omega_i)\\cos{\\theta_i}\\text{d}\\omega_i} $$\nBRDF告诉我们，可以从入射的irradiant得到出射的irradiant：\n$$ \\text{d}L_r(\\omega_r) = f_r(\\omega_i \\rightarrow \\omega_r)L_i(\\omega_i)\\cos{\\theta_i}\\text{d}\\omega_i $$\n对上式积分可得：\n$$ L_r(\\omega_r) = \\int_{\\Omega^+}f_r(\\omega_i \\rightarrow \\omega_r)L_i(\\omega_i)\\cos{\\theta_i}\\text{d}\\omega_i $$\n这里$\\Omega^+$是平面的上半球，也就是说要对所有照射到平面的光源的BFDR乘上入射irradiance乘上$\\cos{\\theta}$的和，才是平面反射的irradiance。\n渲染方程 BRDF很好地告诉了我们平面接收光线后会反射出什么样的光线，但是我们还要考虑平面自发光的情况。将自发光情况加入进去之后就会得到渲染方程：\n$$ L_o(p, \\omega_o) = L_e(p, \\omega_o) + \\int_{\\Omega^+}f_r(p, \\omega_i \\rightarrow \\omega_r)L_i(p, \\omega_i)\\vec{n}\\omega_i\\text{d}\\omega_i $$\n这里加上了自发光$L_e(p, \\omega_o)$，并将$\\cos{\\theta}$转换为向量点乘$\\vec{n}\\omega_i$\n渲染方程式基本上现代图形学的基础，所有限制在物体表面的光线传播都得满足渲染方程。\n接下来需要对渲染方程进行一些化简，好让我们能够从中看出些什么：\n首先我们看到，渲染方程中真正的未知量其实是irradiance：\n$$ L_o(p, \\omega_o),L_i(p, \\omega_i) $$\n因为物体的自发光$L_e$一定是知道的，光线从哪个角度来和平面的发现也一定是知道的。这里我们假设BRDF也是知道的（后面我们会看到一些光照模型所对应的BRDF函数）。所以只剩下$L_o$和$L_i$不知道。\n为了方便，我们定义算子：\n$$ I(x) = L_x(p, \\omega_x) $$\n那么将算子作用在$L_o$和$L_i$上，有\n$$ I(o) = L_e(p, \\omega_o) + \\int_{\\Omega^+}I(i)f_r\\vec{n}\\omega_i\\text{d}\\omega_i $$\n然后将自发光记作$E(o)$，将$f_r\\vec{n}\\omega_i\\text{d}\\omega_i$记为$K(o, i)$，那么式子变为：\n$$ I(o) = E(o) + \\int I(i)K(o, i)\\text{d}i $$\n然后通过一些奇妙难懂的数学手段（具体是什么我也不清楚，据说是弗雷姆霍得积分方程），可以将式子变为这样：\n$$ L = E +KL $$\n这里的$L = I(x)$，E为$e(o)$，K为$K(o, i)\\text{d}i$。\n然后我们可以从这个方程中解出$L$：\n$$ \\begin{aligned} (I - K)L \u0026 = E \\ L \u0026= (I - K)^{-1}E \\end{aligned} $$\n然后对$(I-K)^{-1}$进行泰勒展开（对比$\\frac{1}{1-x}$的泰勒展开式）可以得到：\n$$ \\begin{aligned} L \u0026= (I + K + K^2 + K^3 + ...)E \\ L \u0026= E + KE + K^2E + ... \\end{aligned} $$\n这个式子用通俗语言可以写成这样：\n最终反射颜色 = 物体自发光颜色 + 光源发出光线经过第一次反射颜色+ 光源发出光线经过第二次反射颜色 + ...\n如果有$L = E$，那说明物体的颜色就是物体本身自发光的颜色。\n如果$L = E + KE$，那说明物体的颜色是物体本身的颜色加上光源直接光照的颜色。\n以此类推。\n其实从原本的渲染方程也可以看出这个结果，不过那个是递归的描述（渲染方程的输入是$L_i(p, \\omega_i)$，输出是$L_o(p, \\omega_o)$，然后$L_o$又能作为下一个光线到达物体的$L_i$，以此类推）。\n渲染方程需要满足能量守恒定律（能量的削弱主要体现在BRDF），那么渲染方程最后会收敛（而不是让场面一片白）。\n在离线渲染中需要调整参数以严格满足能量守恒定律。而实时渲染中我们可以近似能量守恒。\nBRDF性质 BRDF有如下性质：\n互换性：$f_r(\\omega_i \\rightarrow \\omega_o) = f_r(\\omega_o \\rightarrow \\omega_i)$，即从入射光线可以得到反射光线，从反射光线可以得到入射光线（这就是九BRDF被称为“双向”反射分布函数的原因） $\\forall \\omega_r: \\int f_r(\\omega_i \\rightarrow \\omega_r)\\cos{\\theta_i} \\text{d}\\omega_i \\le 1$：BRDF满足能量兽痕，总会削减能量。 $f_r ge 0$：BRDF的结果一定大于等于0（小于0不就是物体吸收光却不发光了嘛，那不成暗物质了） 线性性：BRDF可以简单地累加（回想渲染方程中的积分，就是一种累加）从而计算多个光对物体的总影响。 参考 Games101 Lecture15 RayTracing3\n","description":"","tags":["图形学"],"title":"BRDF","uri":"/posts/brdf/"},{"categories":["game development"],"content":"本文是Games101 RayTracing课程中辐射度量学一章的笔记。\n辐射度量学 辐射度量学是一套基于物理的光线理论，虽然只是几个公式，但学习他可以很好地帮助我们理解BRDF，PBR，AO等算法的概念。\n基本概念 Radiant flux： 辐射通量 intensity：光强度（一般记作$I$） irradiance：辐照度 radiance：辐射度 Radiant Energy和Radiand Flux Radiant Energy（辐射强度）是电磁辐射在单位面积上的能量，用$Q$表示，单位是焦耳（$J$）\nRadiant Flux（辐射通量）的定义是：\n$$ \\Phi = \\frac{dQ}{dt} $$\n即单位时间内的Radiant Energy。单位是瓦特（$W$），或者流明（$lm$）。\n这个公式可以这样理解，将其变换：\n$$ \\text{d}Q = \\Phi\\text{d}t $$\n在辐射通量一定的情况下，光发出的能量和时间成正比，这显然符合现实的情况。\nRadian Intensity 即辐射强度，指一个光源向周围发射的光强度。定义为：\n$$ I(\\omega) = \\frac{d\\Phi}{d\\omega} $$\n其中$\\omega$是Solid Angle（立体角）的单位。\nRadian Intensity的单位是坎德拉（$cd$）\nSolid Angle 是三维空间中对角度的定义。\n在二维空间中，我们知道圆的弧长公式是：\n$$ l = r\\theta $$\n那么可以得到角度的定义：\n$$ \\theta = \\frac{l}{r} $$\n在三维的球中，也可以如法炮制：\n$$ r^2 \\omega = S \\Rightarrow \\omega = \\frac{S}{r^2} $$\n其中$S$是球对应立体角的面积，$r$则是球的半径。\n立体角的单位是steradian（球面度，简记$sterad$）\n显然，$\\omega \\in [0, 4\\pi]$。\n单位立体角则是在单位球中，对应面积$S$的立体角。\n微分立体角则是立体角的微分，可以从球坐标系中算出来：\n首先算出单位立体角对应的面的面积：\n$$ dS = (r\\text{d}\\theta)(r\\sin{\\theta}\\text{d}\\phi) = r^2\\sin{\\theta}\\text{d}\\theta \\text{d} \\phi $$\n那么有\n$$ \\frac{\\text{d}S}{r^2} = \\sin{\\theta}\\text{d}\\theta\\text{d}\\phi = \\text{d}\\omega $$\n你可以反过来验证：\n$$ \\int_S \\sin{\\theta}\\text{d}\\theta\\text{d}\\phi = \\int^{2\\pi}_0 \\int^{\\pi}_0\\sin{\\theta}\\text{d}\\theta\\text{d}\\phi = 4\\pi $$\n这样通过公式\n$$ I = \\frac{\\text{d}\\Phi}{\\text{d}\\omega} $$\n可以得到\n$$ \\text{d}\\Phi = I\\text{d}\\omega \\Rightarrow \\Phi = \\int_{S^2} I\\text{d}\\omega $$\n其中$S^2$是指整个光源所在的球面的面积。\nIrradiance 即辐照度，是指单位面积上的辐射通量：\n$$ E(x) = \\frac{\\text{d}\\Phi(x)}{\\text{d}S} $$\n单位是$lux$\n注意Irradiance和Radiant Intensity的区别。Radiant Intensity是度量光源发出光强度的量，而Irradiance是某点接收光辐射的量。\nRadiance 即辐射度（或辐射），是描述光在环境中分布的基本量。Radiance和光的方向有关。\nRadiance的定义如下：\n$$ L(p,\\omega) = \\frac{\\partial^2{\\Phi(p, \\omega)}}{\\partial{\\omega}\\partial{S\\cos{\\theta}}} $$\n单位是尼特（$nit$）。\n这里$p$是辐射到的点，$\\omega$是立体角，$S$是辐射到这一点的面积，$\\cos\\theta$是这一点所在面的法向量和光线的夹角。\n这里的Radiance是总体的定义，我们也可以对入射和出射光定义，分别是光源发出的Radiance（Exiting Radiance）和接收的Radiance（Incident Radiance）。\nExiting Radiance使用Radiant Intensity定义，根据前面对Radiant Intensity的定义，可以将公式变化为：\n$$ L(p,\\omega) = \\frac{\\partial{I(p, \\omega)}}{\\partial{\\omega}\\partial{S\\cos{\\theta}}} $$\nIncident Radiance使用Irradiance定义，根据Irradiance的定义，可以将公式化简为：\n$$ L(p,\\omega) = \\frac{\\text{d}{E(p, \\omega)}}{\\text{d}{\\omega}\\cos{\\theta}} $$\nIradiance 和 Radiance的联系 通过对Radiance的定义可以得到：\n$$ L(p, \\omega) = \\frac{\\text{d}E(p)}{\\text{d}\\omega \\cos{\\theta}} \\Rightarrow \\text{d}E(p) = L(p, \\omega)\\text{d}\\omega \\cos{\\theta} $$\n即\n$$ E(p) = \\int L(p, \\omega) \\cos{\\theta} \\text{d}\\omega $$\n显然，irradiance只是在radiance上增加了方向，而这个公式则说明了，某一点所受的irradiance的总量为其半球面上垂直于该面的radiance总和:\n之所以是半球面，是因为从面的底部照射的光不应该产生任何光照效果。\n","description":"","tags":["图形学"],"title":"辐射度量学简述","uri":"/posts/%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E7%AE%80%E8%BF%B0/"},{"categories":null,"content":"这里是《C++ Templates 2th》的读书笔记。\n本文中一部分来自于《Effective Morden C++》。\nauto自动推导的推导法则 auto推导的法则和模板推导是一样的（除了一个例外），auto就像模板参数T，比如：\n1 2 3 auto a = 32; // 推导为 int const auto b = 33; // 推导为int，整个的类型是const int const auto\u0026 c = 34; // 推导为int, 整个的类型是const int\u0026 对于最复杂的右值引用，情况同理：\n1 2 3 4 5 6 7 8 int x = 32; const int cx = 33; int\u0026 rx = 34; auto\u0026\u0026 a = x; // 推导为int\u0026 auto\u0026\u0026 b = cx; // 推导为const int\u0026 auto\u0026\u0026 c = rx; // 推导为const int\u0026 auto\u0026\u0026 d = 32; // 推导为int\u0026\u0026 特例是在使用花括号初始化的时候：\n1 2 3 4 auto a1(32); auto a2 = 32; auto a3 = {32}; auto a4{32}; 前两种是普通的初始化方法，会产生和预期一样的结果。后两种是C++11之后的花括号初始化语法，会产生问题。\n问题在于这里auto会被自动推导为std::initializer_list\u003cint\u003e而不是int。所有花括号初始化都会被auto推导成std::initializer_list\u003cT\u003e。\n与之相对的，模板则不会这么做：\n1 2 3 4 5 6 template \u003ctypename T\u003e void Func(T t) { // ... } Func({1, 2, 3, 4}); // Error，无法推导参数类型 所以你必须显式指定传入initializer_list：\n1 2 template \u003ctypename T\u003e void Func(std::initializer_list\u003cT\u003e list) {} 作为参数和返回值的auto自动推导 在C++14及以后，可以使用auto作为函数的参数和返回值。这个时候auto推导使用的是模板参数推导规则而不是原本的auto推导规则：\n1 2 3 4 5 6 auto createInitList() { return {1, 2, 3}; // Error，无法推导出返回值类型 } auto func = [](const auto\u0026 value) { std::cout \u003c\u003c value \u003c\u003c std::endl; }; func({1, 2, 3, 4}); // Error，无法推导参数类型 ","description":"","tags":["cpp"],"title":"C++ Template 6-auto推导","uri":"/posts/c++-templates-6-auto%E6%8E%A8%E5%AF%BC/"},{"categories":null,"content":"本文解释了TBN矩阵的推导和在顶点着色器中对切线空间变换的推导。\nTBN矩阵推导 TBN即切线，副切线，法线的缩写(Tangent, Bitangent, Normal)，是用在法线贴图中用于将贴图中的法线转换到正确坐标的矩阵。\n蓝色方框表示法线贴图的大小，红色三角形是我们要将发现贴图贴上去的三角形。我们的目标是求出T向量和B向量，然后使用叉乘可以得到N向量。这样TBN矩阵就完成了。 假设$P_i = (x_i,y_i,z_i)$，在$P_i$点的UV坐标为$(U_i, V_i)$, 那么有：\n$$ \\begin{align} \\vec{P_2P_1} \u0026= (U_1 - U_2)\\vec{T} + (V_1 - V_2)\\vec{B} \\ \\vec{P_2P_3} \u0026= (U_3 - U_2)\\vec{T} + (V_3 - V_2)\\vec{B} \\ \\end{align} $$\n这里设$\\vec{T} = (T_x, T_y, T_z)，\\vec{B} = (B_x, B_y, B_z)$，那么有方程组：\n$$ \\begin{align} \\vec{P_2P_1} \u0026= (U_1 - U_2)(T_x, T_y, T_z) + (V_1 - V_2)(B_x, B_y, B_z) \\ \\vec{P_2P_3} \u0026= (U_3 - U_2)(T_x, T_y, T_z) + (V_3 - V_2)(B_x, B_y, B_z) \\ \\end{align} $$\n显然，这可以写成矩阵形式：\n$$ \\begin{bmatrix} \\vec{P_2P_1}_x \u0026 \\vec{P_2P_1}_y \u0026 \\vec{P_2P_1}_z \\ \\vec{P_2P_3}_x \u0026 \\vec{P_2P_3}_y \u0026 \\vec{P_2P_3}_z \\ \\end{bmatrix} \\begin{bmatrix} U_1 - U_2 \u0026 V_1 - V_2 \\ U_3 - U_2 \u0026 V_3 - V_2 \\ \\end{bmatrix} \\begin{bmatrix} T_x \u0026 T_y \u0026 T_z \\ B_x \u0026 B_y \u0026 B_z \\ \\end{bmatrix} $$\n这个方程很好解，直接左右同乘右边第一个方程的逆即可：\n$$ \\begin{bmatrix} T_x \u0026 T_y \u0026 T_z \\ B_x \u0026 B_y \u0026 B_z \\ \\end{bmatrix} \\begin{bmatrix} U_1 - U_2 \u0026 V_1 - V_2 \\ U_3 - U_2 \u0026 V_3 - V_2 \\ \\end{bmatrix}^{-1} \\begin{bmatrix} \\vec{P_2P_1}_x \u0026 \\vec{P_2P_1}_y \u0026 \\vec{P_2P_1}_z \\ \\vec{P_2P_3}_x \u0026 \\vec{P_2P_3}_y \u0026 \\vec{P_2P_3}_z \\ \\end{bmatrix} $$\n这样T和B就解出来了，叉乘之后N也就解出来了。\n顶点着色器中对TBN的变换 最简单使用TBN矩阵的方法是先在顶点着色器中随着模型矩阵一起变换，然后传入片段着色器。但是我们知道片段着色器的开销很大，所以这里有个方法是反过来做：使用TBN矩阵的逆矩阵乘上光源位置，片段位置和观察位置，将他们变换到切线空间中，这一步可以直接在顶点着色器中进行计算，从而节省片段着色器的开销：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 组装TBN矩阵 vec3 T = normalize(vec3(model * vec4(tangent, 0.0))); vec3 B = normalize(vec3(model * vec4(bitangent, 0.0))); vec3 N = cross(T, B); mat3 TBN = mat3(T, B, N); // 得到矩阵的逆（正交矩阵的逆为其转置） TBN = transpose(TBN); // 将光照信息转换到切线空间： lightDir = TBN * lightDir; viewDir = TBN * viewDir; // ... ","description":"","tags":["图形学"],"title":"切线空间详解","uri":"/posts/%E5%88%87%E7%BA%BF%E7%A9%BA%E9%97%B4%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"本文描述了3D空间中的旋转，包括使用欧拉角旋转，四元数旋转，绕坐标轴轴旋转，绕旋转轴旋转以及四元数插值。\n欧拉角 欧拉角是很直白的旋转方式，其思想就是先绕x轴旋转，再绕y轴旋转，再绕z轴旋转（这里x,y,z的顺序不是固定的）。这样的想法让我们将3D空间的旋转拆分为三个2D平面旋转的组合：\n$$ EulerRotateMat = \\ \\begin{bmatrix} \\cos{\\gamma} \u0026 -\\sin{\\gamma} \u0026 0 \u0026 0 \\ \\sin{\\gamma} \u0026 \\cos{\\gamma} \u0026 0 \u0026 0 \\ 0 \u0026 0 \u0026 1 \u0026 0 \\ 0 \u0026 0 \u0026 0 \u0026 1 \\ \\end{bmatrix}\\begin{bmatrix} \\cos{\\beta} \u0026 0 \u0026 \\sin{\\beta} \u0026 0 \\ 0 \u0026 1 \u0026 0 \u0026 0 \\ -\\sin{\\beta} \u0026 0 \u0026 \\cos{\\beta} \u0026 0 \\ 0 \u0026 0 \u0026 0 \u0026 1\\ \\end{bmatrix} \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\ 0 \u0026 \\cos{\\alpha} \u0026 -\\sin{\\alpha} \u0026 0 \\ 0 \u0026 \\sin{\\alpha} \u0026 \\cos{\\alpha} \u0026 0 \\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} $$ 欧拉角的优点是很简洁直观，缺点是由很多问题，这里有一个视频展示了使用欧拉角带来的这些问题（14:20 ~ 17:43）。\n万向节死锁问题 万向节死锁仅发生在动态旋转中。\n旋转分为两种：静态旋转，动态旋转。静态旋转是指每次旋转的旋转轴都是世界坐标系下的坐标轴（即绕x轴即绕$(1, 0, 0)$，绕y轴即绕$(0, 1, 0)$，z轴则是$(0, 0, 1)$）。而动态旋转则是按照旋转体当前的轴，即旋转体的局部坐标系的轴。\n绕任意轴旋转的矩阵 有了欧拉角，我们可以推导出绕任意轴旋转$\\theta$角的方法：\n假设$\\vec{a}$为旋转轴的单位向量，$p$是旋转的点，那么首先首先$\\vec{p}$在$\\vec{a}$上的投影为\n$$ proj_a{p} = (p\\cdot a)a $$ 那么与a，p在同一平面内，且垂直于a的轴为\n$$ p - proj_ap = p - (p\\cdot a)a $$\n然后我们再用叉乘求得垂直于a，(p·a)a的轴：\n$$ a \\times p $$ 因为和$a$平行的分量$proj_ap$不受旋转影响，那么这个问题就变成在$a\\times p$和$p - (p\\cdot a)a$平面中对p的垂直分量进行旋转。这是典型的2D旋转，可以很容易得到：\n$$ p^{'}_h = [p - (p\\cdot a)a]\\cos{\\theta} + (a\\times p)\\sin{\\theta} $$\n然后我们再加上$proj_ap$即可：\n$$ p^{'} = p^{'}_v + p^{'}_h = proj_ap + p^{'}_h = (a\\cdot p)a + [p - (p\\cdot a)a]\\cos{\\theta} + (a\\times p)\\sin{\\theta} $$\n化简得\n$$ p^{'} = p\\cos{\\theta} + (a\\times p)\\sin{\\theta} +(1-\\cos{\\theta})(a\\cdot p)a $$\n接下来将其变为矩阵形式。\n$proj_qp$的矩阵形式为\n$$ \\begin{bmatrix} q_x^2 \u0026 q_xq_y \u0026 q_xq_z \\ q_xq_y \u0026 q_y^2 \u0026 q_yq_z \\ q_xq_z \u0026 q_yq_z \u0026 q_z^2 \\ \\end{bmatrix}\n\\begin{bmatrix} p_x \\ p_y \\ p_z \\ \\end{bmatrix}\n\\frac{1}{|q|^2} $$\n而$p\\times q$的矩阵表示形式为：\n$$ p \\times q = \\begin{bmatrix} 0 \u0026 -p_z \u0026 p_y \\ p_z \u0026 0 \u0026 -p_x \\ -p_y \u0026 p_x \u0026 0 \\ \\end{bmatrix}\n\\begin{bmatrix} q_x \\ q_y \\ q_z \\ \\end{bmatrix} $$\n我们可以用如上的两个公式将绕轴旋转公式表示成矩阵形式，设$c = \\cos{\\theta}$，$s = \\sin{\\theta}$\n$$ \\begin{bmatrix} c+(1-c)a_x^2 \u0026 (1-c)a_xa_y - sa_z \u0026 (1-c)a_xa_z + sa_y \\ (1-c)a_xa_y + sa_z \u0026 c+(1-c)a_y^2 \u0026 (1-c)a_ya_z - sa_x \\ (1-c)a_xa_z - s a_y \u0026 (1-c)a_ya_z + sa_x \u0026 c + (1-c)a_z^2 \\ \\end{bmatrix} $$\n四元数 四元数可以说是完美解决3D空间旋转的一个绝佳办法，与欧拉角相比只需要多一些数学知识。它由哈密顿发现。当时哈密顿一直在寻找三维空间中的复数（即带有两个虚数单位的复数-三元数），但在经过一座桥时，他突然明白没有办法得到三元数，而是应该再升高一个维度，得到四元数。他当时就将它脑中所想的四元数公式刻在桥上，四元数就诞生了。\n基本公式 四元数通俗来说就是有三个虚数单位的复数，回想复数的定义：\n$$ \\begin{aligned} p \u0026 = a\\pmb{i} + b \\ \\pmb{i}^2 \u0026 = -1 \\ \\end{aligned} $$\n而四元数则是有四个虚数单位的复数：\n$$ \\begin{aligned} p = a\\pmb{i} + b\\pmb{j} + c\\pmb{k} + d \\ \\pmb{i}^2 = \\pmb{j}^2 = \\pmb{k}^2 = -1 \\ \\pmb{ij} = \\pm{k}, \\pmb{jk} = \\pmb{i}, \\pmb{ki} = \\pmb{j} \\ \\pmb{ji} = \\pmb{k}, \\pmb{kj} = -\\pmb{i}, \\pmb{ik} = -\\pmb{j} \\ \\end{aligned} $$\n后面的几条规则可以这样记忆：想象i,j,k分别是3D空间中的x,y,z轴的单位向量，他们的乘积结果总是剩下那个轴的所代表的的虚数单位，而结果的符号则由右手定则确定。而相同虚数单位和自己的乘积总是-1。\n一般将四元数记为：\n$$ q = \\begin{bmatrix} \\pmb{q}_v \u0026 q_s \\end{bmatrix} $$ 其中矢量部分为$\\pmb{q}_v = x\\pmb{i} + y\\pmb{j} + z\\pmb{k}$，而标量部分为$q_s = w$\n四元数比欧拉角更优秀的地方在于：\n没有万向节死锁问题 只需要存储四个浮点数，比矩阵表示更加简单 四元数求逆，串联等操作比矩阵更加高效 四元数和复数有着很多共通特性，比如，任意一个复数$x\\pmb{i}+y$可以在复平面内表示一个点$(x, y)$，而四元数作为四维空间的负数，其$x\\pmb{i}+y\\pmb{j}+z\\pmb{k}+w$表示的则是四维空间中的一个点$(x, y, z, w)$。\n再比如，对于复数，我们乘上一个虚数单位其实是将其对应点逆时针旋转了90度。同理，在四元数中乘上某一轴所代表的虚数单位，则是表示绕此轴逆时针旋转90度。\n四元数的乘法计算规则如下：\n$$ \\begin{aligned} p \u0026 = \\begin{bmatrix}\\pmb{p}_v \u0026 p_s\\end{bmatrix} \\ q \u0026 = \\begin{bmatrix}\\pmb{q}_v \u0026 q_s\\end{bmatrix} \\ p*q \u0026 = \\begin{bmatrix}(p_s\\pmb{q}_v + q_s\\pmb{p}_v + \\pmb{p}_v \\times \\pmb{q}_v) \u0026 (p_sq_s - \\pmb{p}_v \\pmb{q}_v)\\end{bmatrix} \\end{aligned} $$ 就是用乘法结合律拆开了计算。这叫做格拉斯曼积。其中$\\pmb{p}_v\\times\\pmb{q}_v$是将p，q的虚部看做向量进行叉积，而$\\pmb{p}_v\\pmb{q}_v$则是其对应向量的点积。\n四元数有很多种乘法，但是格拉斯曼积是最通用的形式。\n四元数满足：\n封闭性：四元数的四则运算结果还是四元数 结合律：$(pq)r = p(qr)$ 四元数的单位元素和逆元素：\n单位元素：$(1, 0, 0, 0)$，任何四元数乘上单位元素都等于自身。 逆元素：$q^{-1} = \\frac{q^*}{|q|^2}$，任何四元数和其逆相乘为单位元素。 其中$|q|^2$代表其模的平方（即$x^2 + y^2 + z^2 + w^2$），$q^{-1}$则是$q$的共轭（和复数共轭类似：$q^{-1} = w -xi - yj - zk$）。 共轭和逆还有如下性质：：\n$$ \\begin{aligned} q^q = qq^ = |q|^2 \\ (qp)^* = p^q^ \\ (qp)^{-1} = p^{-1}q^{-1} \\end{aligned} $$\n四元数表示旋转 只有单位四元数才能表示旋转。因为根据四元数的几何意义，$\\pmb{q}_v = x\\pmb{i}+y\\pmb{j}+k\\pmb{k}$代表着3维空间中的三条虚数轴，而$q_s = w$则代表第四维度中垂直于三维的一条轴。\n第四维度的轴对我们来说没什么用，我们只需要用到三维的虚数轴就可以了。\n首先要将单位四元数视为旋转矢量，其公式如下：\n$$ q = \\begin{bmatrix}\\pmb{q}_v \u0026 q_s\\end{bmatrix} = \\begin{bmatrix}\\vec{a}\\sin{\\frac{\\theta}{2}} \u0026 \\cos{\\frac{\\theta}{2}}\\end{bmatrix} = \\begin{bmatrix} a_x\\sin{\\frac{\\theta}{2}} \\ a_y\\sin{\\frac{\\theta}{2}} \\ a_z\\sin{\\frac{\\theta}{2}} \\ \\cos{\\frac{\\theta}{2}} \\end{bmatrix} $$ $\\vec{a}$是旋转轴所在的单位矢量。旋转的方向根据右手定则（前提是你用的是右手系）决定（握住旋转轴，大拇指朝向$\\vec{a}$的朝向，四指环绕方向即为旋转方向。\n然后再用旋转矢量去旋转物体：\n$$ v^{'} = qvq^{-1} = qvq^* $$ 由于q是单位矢量，由公式$q^{-1} = \\frac{q^*}{|q|}$可知q的逆和其共轭是相等的。\n这里需要将点$v = [x\\ y\\ z\\ w]$也视为四元数$w + x\\pmb{i} + y\\pmb{j} + z\\pmb{k}$。\n这个公式可以化简成不将$v$转化成四元数的版本：\n$$ \\pmb{v^{'}} = \\pmb{v} + 2\\pmb{q}_v\\times(\\pmb{q}_v \\times \\pmb{v} + q_s\\pmb{v}) $$ 这里只需要单纯的将$\\pmb{v}$视为三维的向量即可，此公式还减少了运算量。\n和矩阵类似，旋转也可以串接：\n$$ \\begin{aligned} q_{net} \u0026 = q_3q_2q_1 \\ v^{'} \u0026 = q_{net}vq_{net}^{-1} = q_3q_2q_1vq_1^{-1}q_2^{-1}q_3^{-1} \\end{aligned} $$\n四元数的旋转也可以写成对应的矩阵形式，只需要将上面的旋转公式用矩阵形式表示即可：\n$$ \\pmb{R} = \\begin{bmatrix} 1-2y^2-2z^2 \u0026 2xy + 2zw \u0026 2xy - 2yw \\ 2xy - 2zw \u0026 1-2x^2 - 2z^2 \u0026 2yz + 2xw \\ 2xz + 2yw \u0026 2yz - 2xw \u0026 1-2x^2 - 2y^2 \\ \\end{bmatrix} $$\n用于旋转的四元数的存储优化 一般来说，四元数需要四个float变量来存储，但是由于用于旋转的四元数必须是单位长度的（$x^2+y^2+z^2+w^2 = 1$）,所以我们其实可以只存储三个元素，然后另一个元素通过计算得到：\n$$ w = \\pm \\sqrt{x^2 + y^2 + z^2} $$ 这里还有一个问题是无法确定w的符号。我们可以利用四元数在旋转时q和-q效果一样这个特性，看到w为负数时直接存储$-\\pmb{q}_v$即可。这样我们可以默认重现的w一定是正的。\n四元数旋转的线性插值 直接对四元数进行插值即可，假设要从$q_a$旋转到$q_b$，那么从a到b之间$\\beta$百分点的中间旋转$q_{LERP}$为：\n$$ q_{LERP} = LERP(q_a, q_b, \\beta) = \\frac{(1-\\beta)q_a + \\beta q_b}{|(1-\\beta)q_a + \\beta q_b|} = normalize( \\begin{bmatrix} (1-\\beta)q_{a_x} + \\beta q_{b_x} \\ (1-\\beta)q_{a_y} + \\beta q_{b_y} \\ (1-\\beta)q_{a_z} + \\beta q_{b_z} \\ (1-\\beta)q_{a_w} + \\beta q_{b_w} \\ \\end{bmatrix}) $$ 需要注意的是线性插值可能会改变四元数的长度，所以最后要归一化四元数。\n这个公式存在一定问题，因为四元数其实表示四维空间中的球体，上面的公式是在超球的弦上插值，这会导致当$\\beta$以恒定速率改变时，旋转却并非以很定角速率进行。我们需要在超球面上进行插值才可以：\n$$ SLERP(q_a, q_b, \\beta) = w_aq_a + w_pq_p $$ 其中\n$$ \\begin{aligned} w_a \u0026 = \\frac{\\sin{(1 - \\beta)}\\theta}{\\sin{\\theta}} \\ w_p \u0026 = \\frac{\\sin{\\beta \\theta}}{\\sin{\\theta}} \\ \\end{aligned} $$\n参考 四元数-基本概念-知乎 四元数和旋转 四元数和旋转（知乎） 《游戏引擎架构 第二版》\n","description":"","tags":["图形学"],"title":"3D空间中的旋转","uri":"/posts/3d%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E6%97%8B%E8%BD%AC/"},{"categories":null,"content":"本文说明了纹理映射。\n纹理映射 纹理映射也很简单，纹理是一张图像，纹理的左下角坐标为$(0, 0)$，右上角坐标为$(1, 1)$。在传入三角形三个顶点的时候传入坐标，渲染器会在片段着色器之前对其进行插值，从而得到对应的纹理坐标。\n这里主要要实现的是gl shader中的texture函数。这个函数接收一个纹理和一个纹理坐标，并返回这个坐标上的颜色信息：\n1 2 3 4 5 6 7 inline Color4 TextureSample(const Surface* const surface, Vec2 texcoord) { texcoord.x = Clamp\u003creal\u003e(texcoord.x, 0, 1); texcoord.y = Clamp\u003creal\u003e(texcoord.y, 0, 1); // nearest sample return surface-\u003eGetPixel(texcoord.x * surface-\u003eWidth(), texcoord.y * surface-\u003eHeight()); } 这里首先对纹理坐标Clamp以确保其在$[0, 1]$中，然后对纹理进行采样，将数据返回。\n这里做的是临近采样，纹理还有双线性插值法，即当你的纹理坐标为小数的时候（比如$(2.2, 2.3)$）这个时候如果直接转换为整数采样就是临近采样，而双线性插值则是要在x方向和y方向分别取最临近的点（这里是$(2, 2), (3, 2)$和$(2, 2), (2, 3)$，然后对x方向和y方向进行线性插值（比如x方向就是$color_{2,2}+(color_{3,2}-color_{2,2})*0.2$）以得到更加平滑的效果。\n","description":"","tags":["图形学"],"title":"从0开始制作软渲染器（四）","uri":"/posts/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%88%B6%E4%BD%9C%E8%BD%AF%E6%B8%B2%E6%9F%93%E5%99%A8%E5%9B%9B/"},{"categories":null,"content":"本文开始编写渲染器的代码。\n本着色器很大程度上参考了韦易笑大神的RenderHelp渲染器。我的渲染器的理论是跟着Games101和《Fundamentals of Computer Graphics, Fourth Edition》这本书来的，和韦大神渲染器中的方程不太一样（尤其是透视投影，深度测试的地方），所以如果要跟着我这系列博客学习，请务必从头看到尾，以避免公式和细节不一致的情况出现。\n最后的渲染器项目在这里，gitee上也有同名镜像。\n开始编码前的准备工作 这一章我们开始编写渲染器的代码。编码前我们需要一个数学库和一个图形库。数学库用于计算矩阵，图形库用于渲染和保存结果。\n我自己是手写了一份数学库，然后图形库我使用的是SDL2。\n如果你不想自己写数学库，我推荐你使用armadillo或者Eigen，但不推荐使用glm，原因如下：\n我们会手动输入矩阵，这可以检验我们推导的矩阵的正确性\n也不能使用glm已有的矩阵，glm的某些矩阵和我们的不一样（比如投影矩阵对OpenGL特化，或者推导的方式不一样从而达到了形式不一样的矩阵）\n你可以使用glm但不使用他生成矩阵的函数，如果是这样，不如使用 armadillo和Eigen。他两使用SIMD进行加速，这对于软渲染这种效率低的东西来说是节省时间的好方法。\n对于图形库，这就看你的心情了，你甚至可以用平台API直接开干。我使用的是封装了SDL_Surface的Surface类，这里给出声明，以方便熟悉其各个功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Surface final { public: // 加载位图，为了之后的纹理映射使用 Surface(const char *filename); // 按照大小，生成一份空的Surface Surface(int w, int h); Surface(const Surface \u0026) = delete; ~Surface(); Surface \u0026operator=(const Surface \u0026) = delete; int Width() const; int Height() const; // 绘制点 void PutPixel(int x, int y, const Color4 \u0026color); // 使用指定颜色清除 void Clear(const Color4 \u0026color); // 保存到位图 void Save(const char *filename); }; 渲染器初步 我们先搭建一个简单的渲染器，他可以清屏，在Framebuffer上画点，并且可以将Framebuffer保存成位图：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /*********************************** * Renderer ***********************************/ class Renderer final { public: Renderer(int w, int h) : drawColor_{0, 0, 0, 0} { framebuffer_.reset(new Surface(w, h)); } void SetDrawColor(const Color4 \u0026c) { drawColor_ = c; } void SetClearColor(const Color4 \u0026c) { clearColor_ = c; } std::shared_ptr\u003cSurface\u003e GetFramebuffer() { return framebuffer_; } // 给Framebuffer清屏 void Clear() { framebuffer_-\u003eClear(clearColor_); } // 在Framebuffer上绘制点 void DrawPixel(int x, int y) { if (IsPointInRect(Vec2{real(x), real(y)}, Rect{Vec2{0, 0}, framebuffer_-\u003eSize()})) { framebuffer_-\u003ePutPixel(x, y, drawColor_); } } // 设置Viewport，这里直接生成Viewport矩阵 void SetViewport(int x, int y, int w, int h) { viewport_ = Mat44::Zeros(); viewport_.Set(0, 0, w / 2); viewport_.Set(1, 1, -h / 2); viewport_.Set(3, 0, w / 2 + x); viewport_.Set(3, 1, h / 2 + y); viewport_.Set(2, 2, 0.5); viewport_.Set(3, 2, 1); viewport_.Set(4, 4, 1); } // 保存Framebuffer到位图 void Save(const char *filename) { framebuffer_-\u003eSave(filename); } // 绘制三角形图元，这是最重要的函数 bool DrawPrimitive(); private: std::shared_ptr\u003cSurface\u003e framebuffer_; Color4 drawColor_; Color4 clearColor_; Mat44 viewport_; }; 完成之后你应该可以在Framebuffer上画点，清屏了，并且保存到位图了。\n让我们来做个测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { Renderer renderer(480, 360); // 设置绘制颜色 renderer.SetDrawColor(Color4{1, 0, 0, 1}); // 设置清屏颜色 renderer.SetClearColor(Color4{0.2, 0.2, 0.2, 1}); // 清屏 renderer.Clear(); // 画一条水平的直线 for (int i = 100; i \u003c 400; i++) { renderer.DrawPixel(i, 180); } // 保存到位图 renderer.Save(\"test_renderer.bmp\"); return 0; } 你应该可以看到这个结果：\n着色器的编写 我们希望做一个可编程渲染管线的着色器，所以这里来做着色器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /*********************************** * Shader ***********************************/ struct ShaderContext { std::unordered_map\u003cint, real\u003e varyingFloat; std::unordered_map\u003cint, Vec2\u003e varyingVec2; std::unordered_map\u003cint, Vec3\u003e varyingVec3; std::unordered_map\u003cint, Vec4\u003e varyingVec4; void Clear() { varyingFloat.clear(); varyingVec2.clear(); varyingVec3.clear(); varyingVec4.clear(); } }; using VertexShader = std::function\u003cVec4(int index, ShaderContext \u0026output)\u003e; using FragmentShader = std::function\u003cVec4(ShaderContext \u0026input)\u003e; ShaderContext模拟OpenGL中的layout变量，而顶点着色器和片段着色器仅仅是函数对象。\n接下来让渲染器可以设置着色器：\n1 2 3 4 5 6 7 8 9 10 class Renderer { public: void SetVertexShader(VertexShader shader) { vertexShader_ = shader; } void SetFragmentShader(FragmentShader shader) { fragmentShader_ = shader; } // ... private: VertexShader vertexShader_ = nullptr; FragmentShader fragmentShader_ = nullptr; // ... }; 光栅化步骤编写 渲染器需要的顶点数据 接下来我们要编写最复杂的光栅化部分，首先我们定义渲染器中一个顶点所需要的各项信息：\n1 2 3 4 5 6 7 8 9 // in class Renderer private: struct Vertex { ShaderContext context; real rhw; Vec4 pos; Vec3 spf; Vec2 spi; } vertices_[3]; context：是着色器上下文，里面存放着所有Uniform变量 rhw：是进行MVP变换后的w坐标的倒数 pos：是顶点在全局空间中的坐标 spf：是顶点经过MVP变换后的坐标 spi：是顶点经过MVP变换后的x, y坐标的整数值 运行顶点着色器 然后我们开始编写光栅化部分，根据我们第0章说的渲染管线，首先我们需要对于所有输入的点运行顶点着色器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // in class Renderer bool DrawPrimitive() { if (!vertexShader_) { return false; } // 对于每个顶点，我们要运行顶点着色器，进行裁剪和面剔除，进视口变换 for (int i = 0; i \u003c 3; i++) { Vertex\u0026 vertex = vertices_[i]; // 1. 清空着色器上下文 vertex.context.Clear(); // 2. 运行顶点着色器 vertex.pos = vertexShader_(i, vertices_[i].context); // 得到w的倒数，注意预防除0错误 vertex.rhw = 1.0 / (vertex.pos.w == 0 ? 1e-5 : vertex.pos.w); // 接下来是面剔除和裁切 } 在运行顶点着色器之前，我们需要将ShaderContext里的Uniform变量全部清除。\n然后第二步，运行顶点着色器，并且记录下rhw的值。\n顶点着色器需要一个着色器上下文，它会将所有的Uniform变量存进去，然后返回此顶点经过处理后的值（相当于gl_Position）。\n这里可能会有疑问：渲染管线的第一步明明是顶点输入，你这顶点怎么输入呢？\n如果要完全仿照OpenGL，你可以定义自己的Vertex Buffer，Vertex Attribute Pointer和Element Index Buffer。但是我们这里从简，直接在顶点着色器里处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 这是渲染器完成后的使用方法，展示了如何进行顶点输入： // 定义一个Uniform变量的序号 enum UniformVar { Uniform_Color = 0, }; int main() { Renderer renderer(480, 320); renderer.SetClearColor(Color4{0.1, 0.1, 0.1, 1}); renderer.Clear(); renderer.SetViewport(0, 0, 480, 320); // 定义自己的顶点数据 struct { Vec4 pos; Vec4 color; } vs_input[3] = { //坐标 颜色 {Vec4{-0.5, -0.5, 1, 1}, Vec4{1, 0, 0, 1}}, {Vec4{0.5, -0.5, 1, 1}, Vec4{0, 1, 0, 1}}, {Vec4{0, 0.5, 1, 1}, Vec4{0, 0, 1, 1}}, }; // 顶点着色器是Lambda，直接捕获顶点数据完成顶点输入，然后处理顶点数据 renderer.SetVertexShader([\u0026](int index, ShaderContext\u0026 output) { // 将颜色数据放入ShaderContext， output.varyingVec4[Uniform_Color] = vs_input[index].color; // 返回处理后的顶点 return vs_input[index].pos; }); renderer.SetFragmentShader([\u0026](ShaderContext\u0026 input) { // 片段着色器从ShaderContext中取出Uniform变量 return input.varyingVec4[Uniform_Color]; }); renderer.DrawPrimitive(); renderer.Save(\"hello_triangle.bmp\"); return 0; } 面剔除和裁切 顶点着色器运行完之后应该运行细分着色器和片段着色器，但是我们这里为了方便就不写那两个着色器了。\n那么接下来就到了面剔除和裁剪的部分，面剔除使用向量叉积即可解决：\n1 2 3 4 5 6 7 8 9 // 6. face culling, cull the CCW face real result = Cross(Vec\u003c2\u003e(vertices_[1].pos - vertices_[0].pos), Vec\u003c2\u003e(vertices_[2].pos - vertices_[1].pos)); if (faceCull_ == CCW \u0026\u0026 result \u003e= 0) { return false; } else if (faceCull_ == CW \u0026\u0026 result \u003c= 0) { return false; } CCW代表要剔除逆时针面，CW要剔除顺时针面。这里使用向量叉积即可判断顺，逆时针。\n裁剪可以做的很复杂，比如使用Cohen-Sutherland algorithm算法进行裁剪。我们这里图简单使用简单裁剪，即只要三角形任意一个边超出屏幕，我们就直接丢弃整个三角形。\n由于经过投影矩阵后的点理论上在$[-1, 1]^3$中，而如果是透视投影，由于将$(x, y, z, 1)$转换为$(zx, zy, z^2, z)$，所以其被转换到$[-|z|, |z|]^3$上。我们只要判断点是否在这个区间外就可以了：\n1 2 3 4 5 6 7 8 // 3. clipping, if AABB not intersect with screen, clip it for (int i = 0; i \u003c 3; i++) { real absw = std::abs(vertices_[i].pos.w); if (vertices_[i].pos.x \u003c -absw || vertices_[i].pos.x \u003e absw || vertices_[i].pos.y \u003c -absw || vertices_[i].pos.y \u003e absw) { return false; } } 透视除法和视口变换 面剔除和裁剪后要进行透视除法和变换，代码也很简单：\n1 2 3 4 5 6 7 8 9 10 for (auto\u0026 vertex : vertices_) { // 4. perspective divide vertex.pos *= vertex.rhw; // 5. viewport transform and prepare to step into rasterization vertex.spf = Vec\u003c3\u003e(viewport_ * vertex.pos); vertex.spi.x = int(vertex.spf.x + 0.5f); vertex.spi.y = int(vertex.spf.y + 0.5f); } 这里vertex.spi是点在$XoY$平面上的坐标，这里加0.5是因为，根据定义，我们将像素看场一个小正方形，需要用其中心的坐标来计算。\n开始光栅化 经过了顶点着色器，裁剪，面剔除和视口变换后，终于来到了最终要的光栅化阶段。\n光栅化就是对屏幕上的所有点，判断点是否在三角形内：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 Rect boundingRect = GetTriangleAABB(vertices_[0].spi, vertices_[1].spi, vertices_[2].spi); int minX = std::max\u003cint\u003e(boundingRect.pos.x, 0), minY = std::max\u003cint\u003e(boundingRect.pos.y, 0), maxX = std::min\u003cint\u003e(boundingRect.pos.x + boundingRect.size.w, framebuffer_-\u003eWidth()), maxY = std::min\u003cint\u003e(boundingRect.pos.y + boundingRect.size.h, framebuffer_-\u003eHeight()); // 7. rasterization for (int i = minX; i \u003c maxX; i++) { for (int j = minY; j \u003c maxY; j++) { Vec2 p{i + 0.5f, j+ 0.5f}; // [1] if (!IsPointInRect(p, boundingRect)) { //[2] continue; } // 7.1 barycentric calculate // [5] Vec3 barycentric = Barycentric(vertices_[0].spi, vertices_[1].spi, vertices_[2].spi, p); real rhw = vertices_[0].rhw * barycentric.alpha + vertices_[1].rhw * barycentric.beta + vertices_[2].rhw * barycentric.gamma; float w = 1.0f / ((rhw != 0.0f)? rhw : 1.0f); barycentric.alpha *= vertices_[0].rhw * w; barycentric.beta *= vertices_[1].rhw * w; barycentric.gamma *= vertices_[2].rhw * w; if (barycentric.alpha \u003c 0 \u0026\u0026 barycentric.beta \u003c 0 \u0026\u0026 barycentric.gamma \u003c 0) { return false; } if (barycentric.alpha \u003c 0 || barycentric.beta \u003c 0 || barycentric.gamma \u003c 0) { continue; } real z = 1.0 / rhw; // 7.2 update depth buffer(camera look at -z, but depth buffer store positive value, so we take the opposite of 1.0 / rhw) if (z \u003c= depthBuffer_-\u003eGet(i, j)) { // [6] continue; } depthBuffer_-\u003eSet(i, j, z); // 下面要运行片段着色器了 首先得到三角形的AABB包围盒boundingRect，用来得到三角形AABB和屏幕相交的矩形，来减少遍历的点。然后一个双重for循环遍历屏幕上的点，注意这里的[1]语句同样将点偏移到像素的中心。\n然后[2]使用boundingBox快速判断点是否在三角形的AABB内，如果不在直接丢弃。\n然后是重心坐标的计算，这个在第二节中说了，有两种方法，我这里使用的是第二种方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 inline Vec3 Barycentric(const Vec2\u0026 v1, const Vec2\u0026 v2, const Vec2\u0026 v3, const Vec2\u0026 p) { Vec3 result; Vec3 c1{v1.x - v2.x, v1.x - v3.x, p.x - v1.x}, c2{v1.y - v2.y, v1.y - v3.y, p.y - v1.y}; result = Cross(c1, c2); if (result.z == 0) { // (-1, -1, -1) means a invalid condition, should discard this point return Vec3{-1, -1, -1}; } return Vec3{1 - result.x / result.z - result.y / result.z, result.x / result.z, result.y / result.z}; } 如果返回$(-1, -1, -1)$，则表示计算失败，三角形退化成直线了，那么我们直接丢弃整个三角形（即[3]处）。\n如果这个点不在三角形上，那重心坐标必定有一个值为负数，我们就丢弃这个点（即[4]处）。\n步骤[5]则是通过重心坐标插值出z坐标。这里有一个非常要注意的点，和你如何设计深度缓冲有关：\n如果你的深度缓冲是只存储各个片段的深度值，不像OpenGL那样要求他们在$[0, 1]$之间的话，你应该使用三角形的全局顶点去插值。 如果你想让深度缓冲存储的范围在$[0, 1]$中，那么你就必须使用视口变换后的点进行深度插值（也就是我这里做的），因为视口变换会直接将z坐标变换到$[0, 1]$中。 接下来的[6]则说明了如何更新深度缓存。这里你可能会有疑惑：网上的教程都是深度小的绘制，深度大的丢弃，你这里怎么反过来了？\n回忆上一章说的透视投影矩阵的作用，其是将$(x, y, z, w)$变换到$(zx, zy, z^2, zw)$，然后经过透视除法，令每个坐标在$[-1, 1]^3$中，然后经过视口变换，得到：\n$$ \\begin{align} x \u0026\\in [-\\frac{w}{2}, \\frac{w}{2}] \\ y \u0026\\in [-\\frac{h}{2}, \\frac{h}{2}] \\ z \u0026\\in [0, 1] \\ \\end{align} $$\n那么也就是说，z坐标从：$[-1, 1]$变换到了$[0, 1]$，即越靠近近平面变换后的z越靠近1，而越远离近平面的z越靠近0。也就是说，z值大的点应该在z值小的点的前面。\nOpenGL中之所以是z值小的在前面，是因为他的透视投影矩阵和我们的不太一样，从而导致这里的深度测试也不一样。\n所以如果你输出深度图的话，将会是离得近的点越白，远的点反而黑，这和OpenGL输出的深度图正好相反。\n然后还有一点要注意：常理来说，深度测试应该在片段着色器之后，我们这里是提前深度测试，这是在保证片段着色器不改变顶点z坐标的情况下才能做的优化（我们全程都不会改变z值，所以进行了优化）。如果你的片段着色器需要改变z值，请将深度测试放到片段着色器之后。\n对其他值进行插值并运行片段着色器 然后就是对ShaderContext中的所有值进行插值，然后运行片段着色器了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 7.3 interpolation other varying properties ShaderContext input; ShaderContext\u0026 i0 = vertices_[0].context, i1 = vertices_[1].context, i2 = vertices_[2].context; for (auto\u0026 [key, value] : i0.varyingFloat) { input.varyingFloat[key] = i0.varyingFloat[key] * barycentric.alpha + i1.varyingFloat[key] * barycentric.beta + i2.varyingFloat[key] * barycentric.gamma; } for (auto\u0026 [key, value] : i0.varyingVec2) { input.varyingVec2[key] = i0.varyingVec2[key] * barycentric.alpha + i1.varyingVec2[key] * barycentric.beta + i2.varyingVec2[key] * barycentric.gamma; } // ... 其他的成员如法炮制，这里直接省略 // 8. run Fragment Shader Vec4 color{0, 0, 0, 0}; if (fragmentShader_) { // 运行片段着色器 color = fragmentShader_(input); // 绘制点到Framebuffer framebuffer_-\u003ePutPixel(i, j, color); } } } return true; } 这里我们还有模板测试，Alpha测试和融混没有做。如果有时间，我会在以后的章节中补上。\n使用已完成的着色器渲染三角形 让我们尝试在透视投影下渲染一个三角形：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \"renderer.hpp\" enum UniformVar { Color = 0, }; int main() { Renderer renderer(480, 320); renderer.SetClearColor(Color4{0.1, 0.1, 0.1, 1}); renderer.Clear(); // 设置Viewport renderer.SetViewport(0, 0, 480, 320); // 顶点属性 struct { Vec4 pos; Vec4 color; } vs_input[3] = { {Vec4{0.5, 0.5, -1, 1}, Vec4{1, 0, 0, 1}}, {Vec4{0.5, -0.5, -1, 1}, Vec4{0, 1, 0, 1}}, {Vec4{-0.5, -0.5, -1, 1}, Vec4{0, 0, 1, 1}}, }; // 生成透视投影矩阵，注意这里的near和far参数是近，远平面的坐标，而不是到原点的距离 auto perspMat = CreatePersp(M_PI * 0.5, 480.f/320.f, -0.1, -100); // 设置着色器 renderer.SetVertexShader([\u0026](int index, ShaderContext\u0026 output) { output.varyingVec4[Color] = vs_input[index].color; return perspMat * vs_input[index].pos; }); renderer.SetFragmentShader([\u0026](ShaderContext\u0026 input) { return input.varyingVec4[Color]; }); // 绘制三角形 renderer.DrawPrimitive(); // 保存结果到位图 renderer.Save(\"persp_triangle.bmp\"); return 0; } 运行成功后应该会生成如下的图片：\n你可能会发现图片是上下颠倒的。这是因为我们默认的坐标系是y轴向上，x轴向右，z轴朝向屏幕外面。而大多数窗体程序的坐标都是y轴向下的，这回导致图片上下颠倒。\n如果想要修复这种颠倒，可以在viewport矩阵中翻转y坐标。\n","description":"","tags":["图形学"],"title":"从0开始制作软渲染器（三）","uri":"/posts/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%88%B6%E4%BD%9C%E8%BD%AF%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B8%89/"},{"categories":null,"content":"本文介绍了基本的渲染管线知识。\n渲染管线 渲染管线是每个编写渲染器的人都逃不开的话题。这里我直接推荐这个博客，讲的非常详细。\n大体来说，在OpenGL中，渲染管线的流程如下图：\n顶点输入(Vertex Data Input) 这一步就是将顶点传输给渲染器，在OpenGL中就是使用VBO，EBO，VAO然后将顶点数据填充给VBO。\n运行顶点着色器(Vertex Shader) 接下来需要运行顶点着色器，顶点着色器会对每个输入的顶点进行操作。\n顶点着色器：\n输入： 顶点\n输出： 顶点\n一般在这里进行MVP矩阵运算。对图形学算法的优化的一个方法就是将在片段着色器中运行的代码尽可能地放到顶点着色器中，这样着色器处理的像素点就少。\n曲面细分着色器(Tessellation) 然后顶点会传送到曲面细分着色器，在这一阶段进行曲面细分和曲面简化。\n曲面细分用于给面增加更多的顶点，以此来增加更多的细节。曲面简化则是相反的操作，会减少面数，减少细节。\n这常常用在LOD（细节层次技术）优化中。LOD简单来说就是对远处的物体使用低面数的模型，对近处的看的很清楚的物体使用高面数的模型。这个时候，如果你只有一个模型，但是想使用LOD，你就可以使用曲面细分和曲面简化来达到效果。\n这一阶段有两个着色器：曲面控制着色器，曲面求值着色器。\n曲面细分着色器：\n输入： 顶点\n输出： 顶点\n几何着色器(Geometry Shader) 这个着色器用于产生新的图元。\n注意其和曲面细分着色器的区别：曲面细分着色器是对顶点操作，并且输出顶点。而几何着色器则是对图元操作，输出的是图元。\n几何着色器：\n输入： 图元\n输出： 图元\n图元装配(Primitive Setup) 几何着色器输出的图元会进行图元装配。图元组装做如下事情：\n将输入的顶点组合成图元 面剔除和裁剪(Face Culling and Clipping) 面剔除即剔除指定的面，通常是顺时针或逆时针的面。裁剪则是当三角形全部位于屏幕外面的时候就直接丢弃以减少计算时间。\n光栅化(Rasterization) 光栅化就是对图元内的每个点进行采样，或者说将图元离散化，即屏幕上哪些点在图元内，哪些点不在。不在的点会被丢弃。\n光栅化之前会做两件事：\n进行透视除法\n进行视口变换\n光栅化会通过插值来计算出图元内部点的信息（比如z坐标），然后将此点传给片段着色器。\n片段着色器(Fragment Shader) 片段着色器是对点进行着色的着色器，它是产生高级渲染效果的着色器，但同时也是最吃时间的着色器。\n因为在光栅化之前的所有着色器都是只对顶点进行操作（几何着色器其实也是增加或者丢弃顶点）。一个模型再复杂，顶点也就几千个。但是光栅化会将图元内部的所有点都计算出来传给着色器，这会大大增加点的数目，所以到达片段着色器的点数量会剧增。\n测试混合阶段 这是最后一个阶段，主要做两件事：\n进行测试，包括：\n深度测试\n模板测试\nalpha测试\n对于测试通过的点，还要进行alpha混合来达到透明效果\n注意，这里可能有提前深度测试优化，即将深度测试提前到光栅化阶段。因为如果片段着色器不改变点的深度值的话，点的深度值其实在光栅化时就已经确定了，这个时候光栅化阶段可以做深度测试将点丢弃，减少片段着色器的负担。\n输出到Framebuffer上 最后所有的点会被绘制到framebuffer上，然后系统会将framebuffer绘制到屏幕上，完成一次渲染。\n","description":"","tags":["图形学"],"title":"从0开始制作软渲染器（零）","uri":"/posts/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%88%B6%E4%BD%9C%E8%BD%AF%E6%B8%B2%E6%9F%93%E5%99%A8%E9%9B%B6/"},{"categories":null,"content":"本文介绍了如何在wxWidget库里面使用SDL绘制东西。\nwxWidget嵌入SDL 基本的wxWidget程序 首先我们给一个基本的wxWidget3的窗体程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \"SDL.h\" #include \u003cwx/wxprec.h\u003e #ifndef WX_PRECOMP #include \u003cwx/wx.h\u003e #endif constexpr int WindowWidth = 480; constexpr int WindowHeight = 320; class MyCanva: public wxPanel { public: MyCanva(wxFrame* parent): wxPanel(parent) { } }; class MyFrame: public wxFrame { public: MyFrame(): wxFrame(nullptr, wxID_ANY, \"Embed SDL in wxWidget\", wxDefaultPosition, wxSize(WindowWidth, WindowHeight)) { MyCanva* canva = new MyCanva(this); } }; class MyApp: public wxApp { public: bool OnInit() override { MyFrame* window = new MyFrame; window-\u003eShow(); return true; } int OnExit() override { return 0; } }; wxIMPLEMENT_APP(MyApp); 运行之后应该会显示一个窗体。\n这个窗体是在MyApp里面使用了MyFrame，然后在MyFrame中放了一个MyCanva。\n之所以放MyCanva是因为wxPanel可以自动绘制，而wxFrame不能自动调用OnPaint方法。\n初始化SDL和创建SDL窗口 然后我们要初始化SDL，在MyFrame的构造函数中：\n1 2 3 4 5 6 bool OnInit() override { SDL_Init(SDL_INIT_EVERYTHING); MyFrame* window = new MyFrame; window-\u003eShow(); return true; } 接下来我们需要将MyCanva的窗口数据给SDL，让SDL管理他的数据，这样我们才能让SDL进行绘制：\n1 2 3 4 5 6 7 8 9 10 11 12 MyCanva(wxFrame* parent): wxPanel(parent) { sdl_window = SDL_CreateWindowFrom(GetHandle()); if (!sdl_window) { wxLogMessage(\"SDL window create failed: %s\", SDL_GetError()); } else { renderer = SDL_CreateRenderer(sdl_window, -1, 0); if (!renderer) { wxLogMessage(\"SDL renderer create failed: %s\", SDL_GetError()); } SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND); } } 这里主要使用了SDL_CreateWindowFrom方法从MyCanva已经创建好的窗体中拿到数据。\n注意：sdl_window和renderer是全局变量。\n使用SDL进行绘制 接下来我们要使用SDL在MyCanva上进行绘制，只需要在其OnPaint事件中绘制即可：\n1 2 3 4 5 6 7 void OnPaint(wxPaintEvent\u0026 event) { SDL_SetRenderDrawColor(renderer, 100, 100, 100, 255); SDL_RenderClear(renderer); SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255); SDL_RenderFillRect(renderer, \u0026rect); SDL_RenderPresent(renderer); } 这里rect也是全局变量（SDL_Rect类型）。不要把其移动到MyCanva的public部分，然后在下文的按钮事件中使用类似canva-\u003erect.x = xxx;的代码，这样会产生总线错误（但应该可以使用wxWidget在控件之间共享变量的方法，不过这方面我没接触过）。\n然后我们注册这个函数到OnPaint事件：\n1 2 3 4 MyCanva(wxFrame* parent): wxPanel(parent) { Bind(wxEVT_PAINT, \u0026MyCanva::OnPaint, this); // ... 完成之后你应该会在屏幕中看到一个红色方块。\n使用定时器逐帧绘制 OnPaint事件只会在特定的情况下调用（比如窗口打开时，被遮挡时和缩放时等），如果你想要编写游戏，需要让其按照某一间隔进行不停地绘制，这里我们可以使用定时器事件做到这一点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 在MyCanva类中 // 将要绑定到定时器事件的函数，Refresh用于强制触发一次OnPaint事件 void OnTimer(wxTimerEvent\u0026 event) { Refresh(); } MyCanva(wxFrame* parent): wxPanel(parent) { Bind(wxEVT_PAINT, \u0026MyCanva::OnPaint, this); // 绑定函数到定时器事件 Bind(wxEVT_TIMER, \u0026MyCanva::OnTimer, this); // 创建定时器 wxTimer* timer = new wxTimer(this); // 开启定时器，以30毫秒为间隔 timer-\u003eStart(30); // ... } 使用其他控件 我们的MyCanva现在可以视为一个纯纯的SDL窗口，接下来我们在窗体中增加两个按钮left和right，点击left小方块会向左移动，点击right小方块会向右移动。\n我们需要在MyFrame中增加，不要在MyCanva中增加。因为按钮也是绘制上去的，现在我们的MyCanva已经被SDL管控，绘制上去的按钮会被SDL的绘制覆盖掉。\n而MyFrame和MyCanva不在一个层，wxWidget会帮我们正确地绘制按钮。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class MyFrame: public wxFrame { public: MyFrame(): wxFrame(nullptr, wxID_ANY, \"Embed SDL in wxWidget\", wxDefaultPosition, wxSize(WindowWidth, WindowHeight)) { MyCanva* canva = new MyCanva(this); wxButton* button1 = new wxButton(this, ID_LeftBtn, \"move right\", wxPoint(0, 0)); Bind(wxEVT_BUTTON, [\u0026](wxCommandEvent\u0026 e){ rect.x -= 10; }, ID_LeftBtn); wxButton* button2 = new wxButton(this, ID_RightBtn, \"move right\", wxPoint(100, 0)); Bind(wxEVT_BUTTON, [\u0026](wxCommandEvent\u0026 e){ rect.x += 10; }, ID_RightBtn); } private: enum { ID_LeftBtn = 1, ID_RightBtn, }; }; 结果如下：\n存在的问题 因为一开始我们使用SDL_CreateWindowFrom函数获得了窗口的数据，但这时窗口数据同时被wxWidget和SDL所拥有，这意味着当程序退出时，SDL和wxWidget会将这同一个窗口销毁两次，从而产生段错。\n我的解决方法是不添加SDL_Quit这样SDL就不回去销毁窗口。但我不知道会不会因此导致SDL的其他部分内存泄漏。\n完整的代码 完整的代码在这里\n参考 如何在wxWidgets窗口内嵌入SDL窗口_viking_xie的博客-CSDN博客\n","description":"","tags":["SDL2","wxWidgets"],"title":"wxWidget中嵌入SDL","uri":"/posts/wxwidget%E4%B8%AD%E5%B5%8C%E5%85%A5sdl/"},{"categories":null,"content":"这里介绍了物理引擎中使用的连续碰撞检测的一些知识。\n连续碰撞检测 众所周知，物理引擎中模拟物理效果并不难，难就难在碰撞检测。一般的碰撞检测是每帧检测一下自己的包围盒有没有和其他物体的包围盒相交，但当存在高速物体时容易出现穿墙的情况。\n连续碰撞检测(CCD)则旨在解决这个问题，它主要做两件事情：\n避免穿墙情况\n计算出影响时间（time of impact - TOI），即物体碰到墙的时间\n连续碰撞检测有很多很多的方法：\n超采样（SuperSampling）：和其名字一样，比如你的游戏FPS是60，那我在物理引擎迭代的时候就用FPS120，FPS180的速率去迭代，这样能一定程度上防止物体速度过快导致穿墙。但显然这种方法运行起来很慢。\n二分法（Bisection）：如果一个物体在第i帧处有碰撞但在第i+1帧处没有碰撞，那么我们要寻找在第i+0.5帧处有没有碰撞，如果没有，再寻找i+0.25和i+0.75处有没有碰撞，以此类推，直到数值足够小为止。这个算法没办法避免穿墙，因为它要求第i帧处有碰撞。但是我们可以修改这个条件，让他不管有没有碰撞都检测一下。\n射线投射法（Ray casting）：有很多很小的高速物体，比如子弹，使用上面的方法会很消耗资源。这里就可以使用射线投射法。从上一帧的位置向下一帧投射一条射线（或者将上一帧和下一帧的位置连起来称为一条线段），然后判断射线是否与其他物体相交。这适用于子弹和慢速物体。\n光线投射到一般的凸物体上：大多数情况下，所涉及的形状是凸的（因为与凹形相比，凸形在碰撞检测中要快得多）。Gino van den Bergen开发了一种迭代算法，可以计算两个凸形状（凸壳，球体，胶囊，盒子，...，所有凸形状！）的CCD。它的工作原理是在配置空间障碍物 （CSO） 上执行基于 GJK 的光线投射。在论文\"针对一般凸物体的光线投射与连续碰撞检测的应用\"中对此进行了描述。如果你不知道GJK，CSO是什么算法，可以看看这本书 《Collision Detection in Interactive Environments》, Gino van den Bergen著，或者直接去啃GJK的论文\n保守推进法（Conservative Advancement）：上面讲述的方法都不能处理旋转体，而本算法可以很好地处理，可以看 Continuous Collision Detection for Non-Convex Polyhedra这篇文章以及 Continuous Collision Detection and Physics这篇文章\n参考 Continuous Collision Detection (Background Information)\n","description":"","tags":["game development"],"title":"连续碰撞检测(CCD)介绍","uri":"/posts/%E8%BF%9E%E7%BB%AD%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B-ccd-%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"本文说了有关光栅化的事情\n光栅化是什么 光栅化的基础单位是最简单的多边形：三角形。\n光栅化做的事就是如下：\n遍历屏幕中所有的点，判断点是否在三角形内\n如果在三角形内，通过重心坐标计算出此点的z坐标，并且对其他顶点属性进行插值\n将点传给片段着色器进行着色\n其主要功能就是对三角形进行采样，确定其中的点传给片段着色器。\n判断点是否在三角形内 首先要做的第一步就是判断点是否在三角形内。\n我们光栅化的做法是这样：假设三角形坐标为，对屏幕上的每个点，判断其是否在三角形对XoY平面投影的区域内。\n假设三角形的三个顶点是$(x_1, y_1, z_1)$，$(x_2, y_2, z_2)$，$(x_3, y_3, z_3)$，那么他对XoY的投影点是$(x_1, y_1)$,$(x_2, y_2)$,$(x_3, y_3)$，我们就要对屏幕上每个点判断其是否在这三个顶点所围成的三角形内部。\nEdge Equation Edge Equation算法使用叉积来判断：\n当Q点在三角形外面时，$\\vec{P_0P_1}\\times \\vec{P_0Q}$,$\\vec{P_1P_2}\\times \\vec{P_1Q}$,$\\vec{P_2P_0}\\times \\vec{P_2Q}$这三者的值一定有至少一个和其他两个的值的符号不一样。而当Q在内部时，符号一定是一样的。\n注意这里向量的顺序一定是按照顺时针或逆时针，不要搞什么$\\vec{P_0P_2},\\vec{P_0P_1}$。\n使用重心坐标 重心坐标主要是用来插值出点的z坐标，但是这里也可以使用它来判断三角形在不在内部。\n首先看一下重心坐标的定义：\n如果一个点$P$在三角形$V_1, V_2, V_3$内部，那么有：\n$$ \\begin{aligned} \\vec{P} = \\alpha \\vec{V_1} + \\beta \\vec{V_2} + \\gamma \\vec{V_3} \\ \\alpha + \\beta + \\gamma = 1 \\end{aligned} $$\n这里第二个式子告诉我们，其实可以只使用$\\alpha$和$\\beta$来表示点P：\n$$ \\vec{P} = (1-\\beta - \\gamma) \\vec{V_1} + \\beta \\vec{V_2} + \\gamma \\vec{V_3} $$\n当$\\alpha \\beta \\gamma$中任意一者为0时点在三角形边上，任意两个为0时点在三角形顶点上。任意一个为负数则表示点在三角形外面。我们可以使用这个来判断点在不在三角形中间。\n那么接下来就是求解这三个未知数，有两种方法：\n使用面积比来计算 第一种是通过重心坐标的性质：\n$\\alpha,\\beta,\\gamma$的值为对应小三角形面积和整个三角形面积的比，所以我们就能使用向量叉乘的性质来算出这三个量：\n$$ \\begin{matrix} A = \\frac{\\vec{ca} \\times \\vec{ba}}{2} \\ A_a = \\frac{\\vec{pc} \\times \\vec{pb}}{2} \\ A_b = \\frac{\\vec{pa} \\times \\vec{pc}}{2} \\ A_c = \\frac{\\vec{pa} \\times \\vec{pb}}{2} \\ \\end{matrix} $$\n这样$\\alpha,\\beta,\\gamma$就出来了。注意这里可能产生的除0错误：A的值为0。这意味着三角形退化成线或者点了，我们直接抛弃三角形。\n推导出公式来计算 第二种是我们自己推导：\n$$ \\begin{matrix} \u0026 \\vec{P} = (1-\\beta - \\gamma) \\vec{V_1} + \\beta \\vec{V_2} + \\gamma \\vec{V_3} \\ \u0026 \\Downarrow \\ \u0026 \\vec{P} = \\vec{V_1}-\\beta \\vec{V_1} - \\gamma \\vec{V_1} + \\beta \\vec{V_2} + \\gamma \\vec{V_3} \\ \u0026 \\Downarrow \\ \u0026 \\vec{P} - \\vec{V_1} = \\beta(\\vec{V_2} - \\vec{V_1}) + \\gamma(\\vec{V_3} - \\vec{V_1}) \\ \u0026 \\Downarrow \\ \u0026\\vec{PV_1} = \\beta \\vec{V_2V_1} + \\gamma \\vec{V_3V_1} \\end{matrix} $$\n把左边的$\\vec{PV_1}$挪到右边，就有：\n$$ \\beta \\vec{V_2V_1} + \\gamma \\vec{V_3V_1} + \\vec{V_1P} = 0 $$\n因为这里的所有向量都是二维向量，所以我们有：\n$$ \\begin{cases} \\beta \\vec{V_2V_1}_x + \\gamma \\vec{V_3V_1}_x + \\vec{V_1P}_x = 0 \\ \\beta \\vec{V_2V_1}_y + \\gamma \\vec{V_3V_1}_y + \\vec{V_1P}_y = 0 \\ \\end{cases} $$\n任意的线性方程组都可以写成矩阵形式，那么我们有：\n$$ \\begin{cases}\n\\begin{bmatrix} \\beta \u0026 \\gamma \u0026 1 \\end{bmatrix} \\begin{bmatrix} \\vec{V_2V_1}_x \\ \\vec{V_3V_1}_x \\ \\vec{V_1P}_x \\end{bmatrix}\n= 0 \\\n\\begin{bmatrix} \\beta \u0026 \\gamma \u0026 1 \\end{bmatrix}\n\\begin{bmatrix} \\vec{V_2V_1}_y \\ \\vec{V_3V_1}_y \\ \\vec{V_1P}_y \\end{bmatrix}\n= 0\n\\end{cases} $$\n那么这就意味着$\\begin{bmatrix} \\beta \u0026 \\gamma \u0026 1 \\end{bmatrix}$和另外两个向量的点乘为0，这意味着其和另外两个向量垂直。\n那就好做了，直接对上面方程组右边两个向量做叉积：\n$$ \\begin{bmatrix} \\vec{V_2V_1}_x \\ \\vec{V_2V_3}_x \\ \\vec{V_1P}_x \\end{bmatrix}\n\\times\n\\begin{bmatrix} \\vec{V_2V_1}_y \\ \\vec{V_2V_3}_y \\ \\vec{V_1P}_y \\end{bmatrix}\n=\n\\begin{bmatrix} a \u0026 b \u0026 c \\end{bmatrix}\n=\nc \\begin{bmatrix} \\beta \u0026 \\gamma \u0026 1 \\end{bmatrix} $$\n这里我们算出来的向量是$\\begin{bmatrix}\\beta \u0026 \\gamma \u0026 1 \\end{bmatrix}$的c倍，所以我们得对其除以c。\n这个时候必须考虑$c = 0$的情况。由向量叉乘公式，c的计算过程其实是这样：\n$$ c = \\left| \\begin{matrix} \\vec{V_2V_1}_x \u0026 \\vec{V_2V_3}_x \\ \\vec{V_2V_1}_y \u0026 \\vec{V_2V_3}_y \\ \\end{matrix} \\right| \\left| \\begin{matrix} \\vec{V_2V_1}_x \u0026 \\vec{V_2V_1}_y \\ \\vec{V_2V_3}_x \u0026 \\vec{V_2V_3}_y \\ \\end{matrix} \\right| $$\n上述行列式为0说明$\\vec{V_2V_1}\\times \\vec{V_2V_3} = 0$，这意味着这两个向量共线，即三角形退化成直线了。\n这里你可以抛弃三角形，或者绘制这条直线。\n显然，方法二比起方法一更好，他只需要做一次叉乘就能得到结果。\n使用三角形AABB包围盒加速判断 这里我们可以加速这一步骤：我们找到三角形的AABB包围盒，然后遍历屏幕上的点时先判断在不在包围盒内，不在就直接丢弃：\n对三角形内的每个点求出z坐标 我们确定了三角形内的所有点，现在需要对每个点计算其z坐标。\n平面方程法（推荐仅在平行投影中使用） 可以使用平面方程来解：\n三角形所在平面的方程为：\n$$ A(x-x_1)+B(y-y_1)+C(z-z_1) = 0 $$\n而$(A, B, C)$又是此平面的法向量：\n$$ \\vec{V_1V_2} \\times \\vec{V_1V_3} = \\begin{bmatrix} A \u0026 B \u0026 C \\end{bmatrix} $$\n那么就可以很容易求得此三角形所在平面的方程。然后对屏幕上的点$P(x, y)$，我们可以将其带入方程求得z坐标：\n$$ z = \\frac{x_1+y_1+z_1-Ax-By}{C} $$\n当$C = 0$时意味着平面的法向量位于$XoY$平面内，这意味着从我们的视角看去，三角形变成了一条线。这个时候可以抛弃三角形。\nz坐标的透视校正（透视投影中使用） 平面方程法只能在平行投影中使用，因为正交投影会让三角形“变形”，导致其z坐标和其他点并不是线性关系。所以我们需要对z坐标进行透视校正。\n上图解释了为何需要透视校正。在屏幕上，c点位于a，b的中间，但在透视投影的情况下真正的点C并不位于AB之间，如果这时候还用线性关系去运算就会带来错误的结果。\n接下来我们来算透视校正：\n我们先从侧面看整个场景，研究二维的情况，然后将其推广到三维情况。\n这里我们的摄像机看向z的正方向，近平面到摄像机的z距离为d。$s = \\frac{|ab|}{|ac|}$，$t = \\frac{|AC|}{|AB|}$。\n首先，通过相似三角形可得：\n$$ \\frac{X_1}{Z_1} = \\frac{u_1}{d} \\Rightarrow X_1 = \\frac{u_1}{d}Z_1 \\tag{1} $$\n$$ \\frac{X_2}{Z_2} = \\frac{u_2}{d} \\Rightarrow X_2 = \\frac{u_2}{d}Z_2 \\tag{2} $$\n$$ \\frac{X_t}{Z_t} = \\frac{u_s}{d} \\Rightarrow X_t = \\frac{u_s}{d}Z_t \\tag{3} $$\n然后由s的计算公式可以得到：\n$$ s = \\frac{u_2 - u_1}{u_s - u_1} \\Rightarrow u_s = u_1 + (u_2 - u_1)s \\tag{4} $$\n同理，通过t的计算公式可以得到：\n$$ X_t = X_1 + (X_2 - X_1)t \\tag{5} $$\n$$ Z_t = Z_1 + (Z_2 - Z_1)t \\tag{6} $$\n将$(4)$和$(5)$式代入$(3)$式可得：\n$$ Z_t = \\frac{d(X_1 + t(X_2 - X_1))}{u_1 + (u_2 - u_1)s} \\tag{7} $$\n再将$(1),(2)$代入$(7)$可得：\n$$ Z_t = \\frac{d(\\frac{u_1Z_1}{d}+t(\\frac{u_2Z_2}{d} - \\frac{u_1Z_1}{d}))}{u_1 + s(u_2 - u_1)} \\tag{8} $$\n将$(6)$代入$(7)$：\n$$ Z_1 + (Z_2 - Z_1)t = \\frac{d(\\frac{u_1Z_1}{d}+t(\\frac{u_2Z_2}{d} - \\frac{u_1Z_1}{d}))}{u_1 + s(u_2 - u_1)} \\tag{9} $$\n化简得\n$$ t = \\frac{sZ_1}{sZ_1 + (1-s)Z_2} \\tag{10} $$\n然后将$(10)$代入$(6)$：\n$$ Z_t = Z_1 + \\frac{sZ_1}{sZ_1 + (1-s)Z_2}(Z_2 - Z_1) $$\n化简得：\n$$ Z_t = \\frac{1}{\\frac{1}{Z_1}+s(\\frac{1}{Z_2} - \\frac{1}{Z_1})} $$\n然后对$Z_t$取倒数：\n$$ \\frac{1}{Z_t} = \\frac{1}{Z_1} + s(\\frac{1}{Z_2} - \\frac{1}{Z_1}) $$\n这说明z的倒数之间是成正比的，也就是说，记$W = \\frac{1}{Z}$，有：\n$$ W_t = W_1 + s(W_2 - W_1) = (1-s)W_1 + sW_2 $$\n这就是二维空间中的透视校正。\n推广到三维空间中，我们就需要找到和$s$相对应的量。注意这里$s$是点c到点a的距离比，并且$s \\in [0, 1]$。我们很容易想到一个和此有类似性质的东西：重心坐标。\n所以推广到3D的公式就是这样：\n$$ \\frac{1}{Z_t} = \\frac{\\alpha}{Z_1} + \\frac{\\beta}{Z_2} + \\frac{\\gamma}{Z_3} $$\n其中$\\alpha, \\beta, \\gamma$三角形投影到近平面上的重心坐标参数。\n重心坐标在透视投影的情况下会发生改变，那么其他的属性值也会发生改变。对于任意的属性值，我们可以用如下公式进行透视校正：\n$$ \\frac{1}{Z_t}I_t = \\frac{\\alpha}{Z_1}I_1 + \\frac{\\beta}{Z_2}I_2 + \\frac{\\gamma}{Z_3}I_3 $$\n编程小技巧 这里因为$\\frac{1}{Z}$之间成正比，所以我们一般会令$w = \\frac{1}{Z}$。而通过上一章的透视投影矩阵推导，我们可以知道经过透视投影变换后得到的点为：\n$$ \\begin{bmatrix} x \\ y \\ z \\ 1 \\end{bmatrix}\n\\Rightarrow\n\\begin{bmatrix} zx \\ zy \\ z^2 \\ z \\end{bmatrix} $$\n所以我们可以提前保留下$\\frac{1}{Z}$，不仅是为了进行线性插值，在后面做透视除法（即给透视之后的点除以$z$）也可以直接乘上$\\frac{1}{Z}$。\n参考 OpenGL 和 DirectX 是如何在只知道顶点的情况下得出像素位置的？ - 知乎 (zhihu.com)\n十天自制软渲染器 DAY 03：画一个三角形（向量叉乘算法 \u0026 重心坐标算法）卤蛋实验室-CSDN博客\n","description":"","tags":["图形学"],"title":"从0开始制作软渲染器（二）","uri":"/posts/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%88%B6%E4%BD%9C%E8%BD%AF%E6%B8%B2%E6%9F%93%E5%99%A8%E4%BA%8C/"},{"categories":null,"content":"本文讲述了MVP矩阵的意义,投影变换（透视投影和平行投影）矩阵的推导以及视口变换\n模型变换 模型变换是将物体从原点移动到他应该在的位置（世界坐标）\n视图变换 视图变换主要指摄像机变换。因为存在规定：\n摄像机坐标必须在原点\n摄像机看向$-z$轴\n所以我们需要一些变换作用在世界中的所有物体上，以便于将他们变换到摄像机坐标。\n投影变换 这是最后一步，将三维空间的物体（程序中记录的所有物体）投影到二维空间（屏幕）上从而显示他们。\n平行投影 平行投影很简单：\n我们的可视范围在这个最左边的长方体里面，我们的目标是将其变换成最右边的标准立方体（即$x, y, z \\in [-1, 1]$）。\n很简单，先将长方体中心平移到原点（图中间的情况），然后再对长方体进行缩放即可：\n$$ \\begin{bmatrix} \\frac{2}{right - left} \u0026 0 \u0026 0 \u0026 0 \\ 0 \u0026 \\frac{2}{top - bottom} \u0026 0 \u0026 0 \\ 0 \u0026 0 \u0026 \\frac{2}{near - far} \u0026 0 \\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 -\\frac{left + right}{2} \\ 0 \u0026 1 \u0026 0 \u0026 -\\frac{top + bottom}{2} \\ 0 \u0026 0 \u0026 1 \u0026 -\\frac{near + far}{2} \\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} = \\ \\begin{bmatrix} \\frac{2}{right - left} \u0026 0 \u0026 0 \u0026 -\\frac{left + right}{right - left} \\ 0 \u0026 \\frac{2}{top - bottom} \u0026 0 \u0026 -\\frac{top + bottom}{top - bottom} \\ 0 \u0026 0 \u0026 \\frac{2}{near - far} \u0026 -\\frac{near + far}{near - far} \\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} $$\n正交投影 正交投影的推导比较麻烦:\n我们采用从平行投影推导到正交投影的方法，你可以想像将透视投影（Frustum）的远平面进行挤压，从而让其四条线平行来得到平行投影。\n对于透视投影，我们有如下规定：\n挤压前后近平面和远平面位置保持不变（即透视投影和平行投影的近，远平面的z值是一样的）\n进平面上的点挤压前后不会发生变化\n远平面的中心点挤压前后不会发生变化\n有了上面两条规定，就可以推导出透视投影了，这里的公式为：\n$$ M_{persp} = M_{ortho}M_{persp_to_ortho} $$\n我们现在要求的就是$M_{persp_to_ortho}$矩阵。\n从侧面来看这个Frustum，$(x, y, z)$是视锥内的一点，$(x^{'},y^{'},z^{'})$是其经过变换后的点（确定这个点的方法是从原点做到$(x, y, z)$点的直线，和近平面的交点）\n显然，由相似三角形得知：\n$$ y^{'} = \\frac{n}{z}y $$\n那么同理，x的坐标也可以知道：\n$$ x^{'} = \\frac{n}{z}x $$\n那么我们现在已经知道两个坐标了，接下来就是解$z$坐标：\n$$ \\begin{pmatrix} x \\ y \\ z \\ 1 \\end{pmatrix} \\Rightarrow \\begin{pmatrix} \\frac{n}{z}y \\ \\frac{n}{z}x \\ ? \\ 1 \\end{pmatrix} $$\n首先根据齐次坐标性质，对齐次向量乘上常数不改变向量表示的点，那么我们直接乘上$z$，将除式消去：\n$$ \\begin{pmatrix} x \\ y \\ z \\ 1 \\end{pmatrix} \\Rightarrow \\begin{pmatrix} \\frac{n}{z}y \\ \\frac{n}{z}x \\ ? \\ 1 \\end{pmatrix} {multiply\\ z} \\Rightarrow \\begin{pmatrix} ny \\ nx \\ ? \\ z \\end{pmatrix} $$\n那么我们现在的$M_{persp_to_ortho}$就是：\n$$ M_{persp_to_ortho} = \\begin{bmatrix} n \u0026 0 \u0026 0 \u0026 0 \\ 0 \u0026 n \u0026 0 \u0026 0 \\ a \u0026 b \u0026 c \u0026 d \\ 0 \u0026 0 \u0026 1 \u0026 0 \\end{bmatrix} $$\n其中$a, b, c, d$都是未知量。\n然后我们使用上面说的两条规定：\n规定二告诉我们，近平面上的点在挤压前后不会发生变化，这意味着当$z=n$时，有：\n$$ \\begin{pmatrix} x \\ y \\ n \\ 1 \\end{pmatrix} \\Rightarrow \\begin{pmatrix} nx \\ ny \\ n^2 \\ n \\end{pmatrix} $$\n也就是说通过$M_{persp_to_ortho}$矩阵的变换，有：\n$$ \\begin{pmatrix} a \u0026 b \u0026 c \u0026 d \\end{pmatrix} \\begin{pmatrix} x \\ y \\ n \\ 1 \\end{pmatrix} = n^2 $$\n显然，最后的结果$n^2$和$x,y$没有半毛钱关系，这意味着一定有\n$$ a = 0, b = 0 $$\n那么我们可以得到方程：\n$$ \\begin{pmatrix} 0 \u0026 0 \u0026 c \u0026 d \\end{pmatrix} \\begin{pmatrix} x \\ y \\ n \\ 1 \\end{pmatrix} cn + d n^2 $$\n规定三告诉我们，远平面的中心点挤压之后也不发生改变，这意味着有：\n$$ \\begin{pmatrix} 0 \u0026 0 \u0026 c \u0026 d \\end{pmatrix} \\begin{pmatrix} 0 \\ 0 \\ f \\ 1 \\end{pmatrix} cf + d = f^2 $$\n由上述两个方程联立可解得：\n$$ \\begin{matrix} c \u0026 = n + f \\ d \u0026 = -nf \\end{matrix} $$\n这样结果就出来了：\n$$ M_{persp_to_ortho} = \\begin{bmatrix} near \u0026 0 \u0026 0 \u0026 0 \\ 0 \u0026 near \u0026 0 \u0026 0 \\ 0 \u0026 0 \u0026 near+far \u0026 -near far \\ 0 \u0026 0 \u0026 1 \u0026 0 \\end{bmatrix} $$\n$$ M_{persp} = M_{ortho}M_{persp_to_ortho} = \\ \\begin{bmatrix} \\frac{2}{right - left} \u0026 0 \u0026 0 \u0026 -\\frac{left + right}{right - left} \\ 0 \u0026 \\frac{2}{top - bottom} \u0026 0 \u0026 -\\frac{top + bottom}{top - bottom} \\ 0 \u0026 0 \u0026 \\frac{2}{near - far} \u0026 -\\frac{near + far}{near - far} \\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} near \u0026 0 \u0026 0 \u0026 0 \\ 0 \u0026 near \u0026 0 \u0026 0 \\ 0 \u0026 0 \u0026 near+far \u0026 -near\\ far \\ 0 \u0026 0 \u0026 1 \u0026 0 \\end{bmatrix} \\begin{bmatrix} \\frac{2n}{r - l} \u0026 0 \u0026 -\\frac{r+l}{r-l} \u0026 0 \\ 0 \u0026 \\frac{2n}{t-b} \u0026 -\\frac{t+b}{t-b} \u0026 0 \\ 0 \u0026 0 \u0026 \\frac{n+f}{n-f} \u0026 \\frac{2fn}{f-n} \\ 0 \u0026 0 \u0026 1 \u0026 0 \\end{bmatrix} $$\nOpenGL的做法则是对$n$和$f$取绝对值：\n$$ \\begin{bmatrix} \\frac{2|n|}{r - l} \u0026 0 \u0026 -\\frac{r+l}{r-l} \u0026 0 \\ 0 \u0026 \\frac{2|n|}{t-b} \u0026 -\\frac{t+b}{t-b} \u0026 0 \\ 0 \u0026 0 \u0026 \\frac{|n|+|f|}{|n|-|f|} \u0026 \\frac{2|f||n|}{|n|-|f|} \\ 0 \u0026 0 \u0026 -1 \u0026 0 \\end{bmatrix} \\ $$\n更一般的做法是通过四个参数来确定投影矩阵：\nfov：纵向的视角大小 aspect：近平面的宽高比 zNear：近平面到摄像机距离（即到原点距离） zFar：远平面到摄像机距离（即到原点距离） 通过这些可以计算出：\n近平面高度H：$H = 2zNear\\times \\tan{\\frac{fov}{2}}$ 近平面宽度W：$W=2aspect\\times zNear\\times \\tan{\\frac{fov}{2}}$ 这样可以得到\n$t = \\frac{H}{2}$ $b = -\\frac{H}{2}$ $l = -\\frac{W}{2}$ $r = \\frac{W}{2}$ 注意zNear和zFar是到原点的距离，不是近，远平面的坐标，所以为了和上面平行投影矩阵合二为一，我们需要用到的是近远平面坐标。假设进平面坐标为$n$，远平面坐标为$f$，就有：\n$$ \\begin{aligned} H \u0026= 2|n|\\times \\tan{\\frac{fov}{2}} \\ W \u0026= 2aspect\\times |n|\\times \\tan{\\frac{fov}{2}} \\end{aligned} $$\n最终的结果就是：\n$$ \\begin{bmatrix} \\frac{2n}{W} \u0026 0 \u0026 0 \u0026 0 \\ 0 \u0026 \\frac{2n}{H} \u0026 0 \u0026 0 \\ 0 \u0026 0 \u0026 \\frac{n + f}{n - f} \u0026 \\frac{2fn}{f - n} \\ 0 \u0026 0 \u0026 1 \u0026 0 \\ \\end{bmatrix} = \\ \\begin{bmatrix} \\frac{n}{|n|aspect\\times \\tan{0.5fov}} \u0026 0 \u0026 0 \u0026 0 \\ 0 \u0026 \\frac{n}{|n|\\tan{0.5fov}} \u0026 0 \u0026 0 \\ 0 \u0026 0 \u0026 \\frac{n + f}{n - f} \u0026 \\frac{2fn}{f - n} \\ 0 \u0026 0 \u0026 1 \u0026 0 \\ \\end{bmatrix} $$\nViewport w前面我们使用了投影矩阵将场景归一化到$[-1, 1]^3$中，而视口变换则是将$[-1,1]^3$转换到$[x, x+width]\\times [y, y+height]\\times [0, d]$上，也就是我们真正的屏幕坐标中。\n$$ \\begin{bmatrix} \\frac{width}{2} \u0026 0 \u0026 0 \u0026 0 \\ 0 \u0026 \\frac{height}{2} \u0026 0 \u0026 0 \\ 0 \u0026 0 \u0026 \\frac{d}{2} \u0026 0 \\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix}\n\\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 \\frac{width}{2} + x \\ 0 \u0026 1 \u0026 0 \u0026 \\frac{height}{2} + y \\ 0 \u0026 0 \u0026 1 \u0026 1 \\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix}\n=\n\\begin{bmatrix} \\frac{width}{2} \u0026 0 \u0026 0 \u0026 \\frac{width}{2} + x \\ 0 \u0026 \\frac{height}{2} \u0026 0 \u0026 \\frac{height}{2} + y \\ 0 \u0026 0 \u0026 \\frac{d}{2} \u0026 1 \\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} $$\n一般的屏幕坐标是以窗口左上角为原点，x轴向右，y轴向下。现在我们视口的中心是在(0, 0)处也就是左上角原点位置，并且z值一般在(0, 1)之间。所以我们一般取$x = y = 0$，$d = 1$。\n","description":"","tags":["图形学"],"title":"从0开始制作软渲染器（一）","uri":"/posts/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%88%B6%E4%BD%9C%E8%BD%AF%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B8%80/"},{"categories":null,"content":"这里介绍了一些几何算法\n有关面积的计算 三角形面积的计算 有很多的方法：\n知道三条边长a,b,c的话可以使用海伦公式:\n$$ p = \\frac{1}{2}(a + b + c) \\ S = \\sqrt{p(p-a)(p-b)(p-c)} $$\n知道三个顶点可以使用向量叉积:\n$$ S = |\\frac{1}{2}\\vec{AB} \\times \\vec{AC}| = |\\frac{1}{2}|\\vec{AB}||\\vec{AC}|\\sin{\\theta}| $$\n四边形的面积计算 知道四条边长：\n$$ p = \\frac{1}{2}(a+b+c+d) \\ S = \\sqrt{p(p-a)(p-b)(p-c)(p-d)} $$\n平行四边形，知道四个顶点坐标：\n$$ S = \\vec{AB} \\times \\vec{AC} $$\n不规则多边形面积计算 其实也很简单，将多边形拆成多个三角形即可，使用$S=\\frac{\\vec{AB}\\times \\vec{AC}}{2}$：\n假设顶点是顺时针排列的（记为$V[i]$）。我们可以在空间中任选一点$P$，然后顺时针遍历顶点并构造三角形，然后计算所有三角形面积再求和：\n$$ S = \\frac{1}{2}(\\vec{PV_0} \\times \\vec{PV_1} + \\vec{PV_1} \\times \\vec{PV_2} + \\cdots \\vec{PV_{n-1}} \\times \\vec{PV_n} + \\vec{PV_n} \\times \\vec{PV_0}) $$\n很容易可以看出这个公式在做什么：\n假设点在多边形内，那么有：\n显然，$S_0 + S_1 + S_2 + S_3 + S_4$就是其面积（不需要加绝对值，因为顶点是顺时针排列，所以叉积的结果也是正的）\n当点在多边形外，有：\n这个时候，$\\vec{PV_3}\\times \\vec{PV_4}$和$\\vec{PV_4}\\times \\vec{PV_5}$的面积都是负数，可以抵消到之前所有三角形面积和中多出的那一部分。\n也可以通过此方法来判断多边形的顶点是否是按顺时针排列，如果最后面积大于0就是顺时针，否则是逆时针。\n各种相交判断 判断点是否在线段上 使用点积或叉积判断是否在线段所在直线上，然后判断点是否在线段构成的矩形内，不然点可能在线段的延长线上：\n1 2 3 4 5 6 7 bool PointInSegment(const Point\u0026 p, const Point\u0026 v1, const Point\u0026 v2) { return // 首先使用叉积判断点是否在线段所在直线上 p.x * (v2.y - v1.y) - p.y * (v2.x - v1.x) == 0 \u0026\u0026 // 然后判断是否在线段构成的矩形内 min(v1.x, v2.x) \u003c= p.x \u0026\u0026 p.x \u003c= max(v1.x, v2.x) \u0026\u0026 min(v1.y, v2.y) \u003c= p.y \u0026\u0026 p.y \u003c= max(v1.y, v2.y); } 判断AABB矩形是否相交以及求出相交矩形 判断AABB矩形是否相交很简单：\n1 2 3 4 5 6 7 bool IsRectIntersect(const Rect\u0026 r1, const Rect\u0026 r2) { float cx1 = std::max(r1.x, r2.x), cy1 = std::max(r1.x, r2.x), cx2 = std::min(r1.x + r1.w, r2.x + r2.w), cy2 = std::min(r1.y + r1.h, r2.y + r2.h); return (cx1 \u003c cx2) || (cy1 \u003c cy2); } (cx1, cy1)和(cx2, cy2)其实就是相交矩形的右下角顶点和左上角顶点。如果右下角顶点在左上角顶点左上方的话，那矩形就不相交了。\n判断两线段是否相交 分为两步：\n快速排斥实验：判断两线段构成的矩形是否相交，如果矩形不相交线段也一定不相交\n跨立实验：使用叉积来判断两线段是否相交：\n如果像左边一样相交，那么$\\vec{V_1V_2}\\times \\vec{V_1P_1}$，$\\vec{V_1V_2}\\times \\vec{V_1P_2}$一定是异号的，并且同理，$\\vec{P_1P_2}\\times \\vec{P_1V_1}$和$\\vec{P_1P_2}\\times \\vec{P_1V_2}$也是异号的。\n如果不相交（如右边），则会有$\\vec{P_1P_2}\\times \\vec{P_1V_2}$和$\\vec{P_1P_2}\\times \\vec{P_1V_1}$同号。\n1 2 3 4 5 6 7 8 bool SegmentIntersect(const Point\u0026 p1, const Point\u0026 p2, const Point\u0026 v1, const Point\u0026 v2) { if (!IsRectIntersect(Rect(p1, p2), Rect(v1, v2))) return false; Point p_dir = p2 - p1, v_dir = v2 - v1; return Cross(p_dir, v1 - p1) * Cross(p_dir, v2 - p1) \u003c= 0 \u0026\u0026 Cross(v_dir, p1 - v1) * Cross(v_dir, p2 - v1) \u003c= 0; } 注意第一步快速排斥实验其实也可以不做，但是快速排斥实验很快，在两个线段离得远的时候可以快速返回false而不用进行第二步的叉乘。\n判断线段和直线是否相交 和上面判断两线段是否相交差不多，也是使用跨立实验（假设线段两端点为$P_1\\ P_2$）：\n任取直线$L$上一点$Q$，和直线的方向向量$\\vec{V}$，如果$\\vec{QP_1}\\times \\vec{V}$和$\\vec{QP_2}\\times \\vec{V}$异号，则相交。\n判断AABB矩形和圆是否相交 有很多方法：\n先判断矩形是否在圆内（四个顶点到圆心的距离小于圆半径），如果是则相交，否则看圆心到矩形四条边的距离，有小于圆半径的则相交\n将矩形的四条边延长，将空间平分为九份：\n如果圆心在矩形内则相交，否则\n若圆心在矩形的上，下，左，右侧，则直接看圆心和对应边的距离，小于半径则相交\n若圆心在矩形的左上，左下，右上，右下，则直接看圆心到对应顶点的距离，小于半径则相交\n第一种方法代码简单，但是计算较多。第二种方法代码复杂，但是每条分支的计算很少。\n判断点是否在多边形内 Crossing Number Method 此算法基于一个定理：从给定点发出一条射线，如果此点在多边形内，那么这条射线和多边形的交点一定是奇数个，否则是偶数个。\n那么这里要解决的问题就是：\n如何判断射线和边相交 判断射线和边相交很简单，我们先要做两个规定：\n顶点按照顺时针排列\n我们不要使用复杂的射线，直接用$x = x_0$这条穿过P点的竖直向上的射线。\n首先要判断此边是否可能和直线相交：\n$$ x_n\\le x_0 \\le x_{n+1} 或\\ x_{n+1} \\le x_0 \\le x_n $$\n然后我们要判断此边是否在直线上方：\n$$ \\frac{y_0 - y_n}{x_0 - x_n} \\lt k $$\n使用斜率进行判断即可。\n当这两个条件都满足，此边即和直线相交，那么对相交点的计数就+1.\n整个的代码可以是这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 bool Contains(const std::array\u003cPoint\u003e\u0026 vertices, const Point\u0026 p) { for (size_t i = 0; i \u003c vertices.size(); i++) { int crossing = 0; const Point\u0026 v1 = vertices[i], v2 = vertices[(i + 1 % vertices.size())]; double slope = (v2.y - v1.y) / (v2.x - v1.x); bool cond1 = v1.x \u003c= p.x \u0026\u0026 p.x \u003c= v2.x, cond2 = v2.x \u003c= p.x \u0026\u0026 p.x \u003c= v1.x, above = (p.y - v1.y) / (p.x - v1.x) \u003c slope; if ((cond1 || cond2) \u0026\u0026 above) crossing ++; } return crossing % 2 == 0; } 这里cond1和cond2分别对应于顶点顺时针排列和逆时针排列的情况。\n这里要注意的是slope处可能出现除0错误，你可以在计算above变量的时候将除法去掉来避免：\n1 2 // 不计算slope，直接在above上计算 bool above = (p.y - v1.y) * (v2.x - v1.x) \u003c (p.x - v1.x) * (v2.y - v1.y) Winding Number Method 这个算法利用叉乘的方向性，和上面多边形求面积方法差不多：如果$\\vec{PV_0}\\times \\vec{PV_1}，\\vec{PV_1}\\times \\vec{PV_2}，\\cdots，\\vec{PV_{n-1}}\\times \\vec{PV_n}和\\vec{PV_n}\\times \\vec{PV_0}$ 所得结果的符号都一样的话，那么点就是在多边形内部，否则就是在外部。\n判断射线和多边形相交 很简单，假设射线起点为$P$，射线方向为$\\vec{D}$，多边形顶点为$V_i$，那么对所有的$\\vec{PV_i}\\times \\vec{D}$的结果都同号的话就是不相交，出现异号就是相交。\n判断射线和圆相交 假设射线起点为$P$，方向为$\\vec{D}$，圆心为$Q$，半径为$R$。\n分两步：\n首先判断射线的方向是否朝向圆，若$\\vec{PQ}\\cdot \\vec{D} \\lt 0$即不朝向圆，那么一定不相交\n否则，使用点到直线距离公式即可判断：$\\frac{Ax+By+C}{\\sqrt{A^2 + B^2}} \\le R$则相交（或者用叉乘也行：$\\frac{\\vec{PQ}\\times \\vec{D}}{|\\vec{D}|} \\le R$即相交）\n将凸多边形顶点按照顺时针排列 顺时针排列顶点问题在凹多边形下没有唯一解，所以这里只有凸多边形的情况，算法很简单：\n找到最左边的点（x坐标最小）\n将这个点和其他点连线，算出直线斜率，然后按照斜率进行排序即可\n将简单多边形拆分成数个三角形 未完成\n耳切法（Ear Clipping）","description":"","tags":["算法"],"title":"一些2D几何算法","uri":"/posts/%E4%B8%80%E4%BA%9B2d%E5%87%A0%E4%BD%95%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"这里介绍了一些随机数生成算法\n为何要自己编写随机数算法 显然，无论是哪个语言，都会有随机数生成器，差一点的像C语言这样只有一个rand()，好一点的像C++这样有一整套的random解决方案。那为何我们还要自己编写随机数算法呢？\n事情还得从SpaceWar说起。这个游戏中使用了大量的随机数，比如星星的绘制，友军对敌机的选择等。实现的方式就是使用的C++17 STL中的random。但是当我将此游戏移植到Windows下后，发现随机数和在我电脑上的表现不一致。\n这使得我的游戏在Windows上会造成一些bug（像是许多友军攻击一个敌机），而在我的电脑上（MacOS），友军对敌军的选择是平均的（因为我当时用的是std::random_device生成随机数，然后将随机数放入std::uniform_int_distribution中产生均匀分布的随机数，但是random_device的实现在不同平台下不一样，可能对结果造成很大的差异）。\n这种bug不是因为随机数种子导致的。我和我的朋友尝试了很多次，就是存在上述差异。这时我才知道，上次面试的时候面试官问我随机数生成算法的意义：自己编写的随机数生成算法是可控的，并且可以在各个平台造成一样的结果。\n自己实现随机数算法还有一个好处：在一些需要随机生成地图的游戏中（比如Minecraft），同一个种子会生成同一份地图。这个时候不得不使用自己编写的随机数算法来避免不同编译器实现的随机数算法的差异。\n线性同余方法（LCG) 这是很常见的一种算法，就一个公式：\n$$ X_{n+1} = (aX_{n} + b) \\mod{m} $$\n这个算法有三个参数a,b,m。LCG的最大周期为m，但是往往达不到。\n这个算法严重依赖参数的取值，取得好可以产生很好的结果。而且这个算法算起来也快。\n参考博客的第一条中列举了不同编译器对参数的选择，这里只给出C++11minstd_rand()的参数：\na = 48271\nb = 0\nm = $2^{31}-1$\n混合同余法 混合同余法可以看做LCG的加强版：\n$$ \\begin{cases} x_{n+1} \u0026 = (\\lambda x_{n} + c) \\mod{m} \\ result \u0026 = \\frac{x_{n+1}}{m} ,\\ \\ result \\in [0, 1]) \\ \\end{cases} $$\n这里$\\lambda$, $c$和$m$都是参数，$x_0$是种子，$result$是返回的结果，在0~1之间。\n这几个参数选择也有要求的，如果随机选的话很容易得到重复序列。\n$\\lambda$应当是$2^k +1(k \u003e 2)$\n$m$应当是$2^n(2 \\le n \\le 34)$\n$c$可以是任何整数\nk和n越接近，就会得到越重复的序列。经过我的实验，k=2,n=18和这附近的值表现得都还可以。\n这里给了个在线例子，可以进去看一看。这里$x_0$是time(nullptr)的返回值。这里每个点的x坐标是其在数组中的下标（生成了720个数），y坐标则是处理后的随机数（我将随机数乘以480以让其铺满整个屏幕）。\n和混合同余法有关的有两个算法，分别是他的低配和高配版：\n乘同余法：\n$$ \\begin{cases} x_{n+1} \u0026 = \\lambda x \\mod{m} \\ result \u0026= \\frac{x_{n+1}}{m} \\ \\end{cases} $$\n高配版\n$$ \\begin{cases} x_{n+1} \u0026 = (\\lambda_1 x_{n} + \\lambda_2 x_{n-1} \\cdots \\lambda_k x_{n+1-k} + c)\\mod{m} \\ result \u0026 = \\frac{x_{n+1}}{m} \\end{cases} $$\nxorshift算法 这个算法是和代码相关的，所以我直接贴代码了：\n1 2 3 4 5 6 7 8 9 10 11 std::uint32_t x = time(nullptr), y = time(nullptr), z = time(nullptr), w = time(nullptr); std::uint32_t xorshf32(void) { // period 2^128 - 1 std::uint32_t tmp = (x ^ (x \u003c\u003c 15)); x = y; y = z; z = w; w = (w^(w \u003e\u003e 21) ^ (tmp ^(tmp \u003e\u003e 4))); return w; } 这个算法需要四个参数x,y,z,w，并且他的周期很长（这里是$2^{128} -1$），并且只需要异或和位移运算就能得到不同的随机数，具体我也不知道为什么，不过我可以给你这个算法的论文以及wiki上的文献🐶。\n这个算法很快，而且也表现出了很好的随机性。\n实例网页在这里\n其他算法 比较有名的还有梅森旋转算法(Mersenne Twister),LFG(lagged-fibonacci-generator)。MT算法是太复杂了我没搞懂。LFG我压根就找不到相关资料，只有英文wiki。\n真正的随机数 众所周知，电脑产生的随机数都是伪随机数。但我们可以通过自然的力量得到真正的随机数。\nwww.random.org网站通过采集大气噪声来产生随机数。这种随机数可以应用在如彩票生成，密码生成器等程序中，用以避免伪随机数的周期性带来的不好的后果。\n得到遵从概率分布的随机数 C语言中，只可以使用$rand()$函数产生随机数，但C++中还能产生依据某种概率分布的随机数：\n1 2 3 4 5 6 std::random_device rd; // 随机数生成器 std::mt19937 gen(rd()); // 使用梅森素数缠绕算法给其一个初值 std::uniform_int_distribution\u003c\u003e dis(1, 6); // 均匀分布发生器 for (int n=0; n\u003c10; ++n) std::cout \u003c\u003c dis(gen) \u003c\u003c ' '; // 使用发生器产生[1, 6]之间服从均匀分布的随机数 这其中的原理如下：\n对于我们想要的分布$D(x)$，从概率分布函数的定义来看：\n$$ D(x) = \\int_{-\\inf}^x f(x) \\text{d} x $$\n其中$f(x)$是其概率密度函数。\n我们可以通过解反函数，来得到X到D(x)的映射：\n$$ X = D(X)^{-1} $$\n比如对于均匀分布，其概率密度函数为：\n$$ \\begin{cases} \\frac{1}{b - a}, \u0026 x \\in [a, b] \\ 0, \u0026 其他 \\end{cases} $$\n使用概率分布函数的定义公式，可积分得到：\n$$ \\begin{cases} 0, \u0026 x \u003c a \\ D(x) = \\frac{x - a}{b - a}, \u0026 x \\in [a, b] \\ 1, \u0026 x \u003e b \\end{cases} $$\n那么我们可以反解出x：\n$$ x = D(x)^{-1} = (b-a)D(x)+a $$\n这时，使用上面说的随机数生成算法生成出随机数d，然后将d替换$D(x)$就可以得到服从分布的x了。\n参考博客 LCG(linear congruential generator): 一种简单的随机数生成算法\n随机数生成算法【详解，归纳】 - Angel_Kitty - 博客园 (cnblogs.com)\nxorshift算法生成随机数的原理是什么？ - 知乎 (zhihu.com)\n","description":"","tags":["算法"],"title":"随机数生成算法","uri":"/posts/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"这里是SpaceWar游戏开发的一些感想。游戏视频可以在这里看到\n这个游戏是为了参加频道内1MGames游戏开发比赛而制作的。从2月2号开始铺底层，断断续续地做到18号，差不多做了十天。\n游戏内容方面 当时刚开始做这款游戏是想着做一个ASCII Sector的复刻版本。那个游戏也是我很喜欢的一款游戏，不过人家全屏都是字符，而且是回合制的（老Roguelike了），而且人家不是开源的，在2012年作者就断更了。所以我其实一直想做个他的实时的复刻版。所以这游戏一开始的命名是Space Sector。\n因为游戏只能在1M大小内，所以一开始就打算使用TileSheet，每个Tile都是8x8的，不含有声音。说白了就是打算纯纯靠代码硬抗（毕竟咱也只会写写代码）。\n我自己本来是有个SDLEngine，但是那个太大了编译出来就3M了（其实开Release和编译器优化，然后再拿upx压一压能压到400KB，不过当时还没接触这些），然后我就放弃了打算从头再整个小引擎，就选了glfw+glad的组合。花了四五天时间搞了个tinyengine。\n然后做着做着发现，ASCII Sector东西怎么这么多啊（我本以为有ECS在手可以很快地搞出来），其中主要是卡在了地牢生成的部分，因为ASCII Sector他的设定是有很多星球，玩家可以在这些星球之间跃迁，在各地进行交易和接任务。然后因为他的星球太多了，我要做的话还得整个地图编辑器，所以我就打算改变一下，整个随机地牢，玩家可以在地牢里面挖矿，然后拿到其他星球去卖（没错就是我DigAndFight游戏的内容😁），但是这方面花了我挺长时间（主要是迁移DigAndFight的代码）。然后我搞到一半的时候感冒了，在家躺了三四天🙄\n等我好的时候，我感觉这个计划8大行，没多少时间了，所以我放弃了复刻。当时已经做了飞机的移动，我就想要不干脆就做成空战得了，所以又做了子弹，然后两种飞机，雷达地图等东西，一直搞到18号完成。\n其实一开始是想做塔防类的，玩家有个能量塔不断地给玩家积攒能量，玩家可以花费能量建造防御工事，然后去进攻别人的能量塔（能量塔的图像废案还在TileSheet里面），但是时间实在是不大够，所以改成做空战了（当时还有许多bug没调）。\n其实游戏中的FreightShip翻译应该是运货机而不是防御机，因为一开始复刻的ASCII Sector需要飞船运货。\n做的过程中感觉只有这点东西不行，所以又把miniaudio抓来加了声音。\n我在开始做的时候一度认为会超出1M，要用upx压一压，结果做出来之后带资源才900KB多，属实是高估自己了。\n技术方面 这次制作只能说成也ECS败也ECS。众所周知ECS是个非常灵活的系统，开发者可以自由地为Entity添加组件。一开始的开发进度很快，这归功于ECS系统。\n但是等我代码多起来的时候就开始乱了，具体有三点表现：\n增加新组件的时候会有功能和其他组件重合，并且组件和系统之间的调用太杂乱了。这个我承认是我自己设计的问题。\n每次使用组件的时候，都需要先查询一次是否存在此组件，不然会有未定义行为（访问了未定内存）。这里有两点坏处：\n每次使用组件前都需要查询，查询会搜索一次Hash表，然后如果找到了，紧接着调用Get或者Use方法时会立刻再找一次表，很浪费时间（事后想了想其实可以缓存的，但是当时急于赶进度懒得加，后面这个时间浪费就表现出来了）\n程序中有很多指向Entity的指针，比如控制器。但是当一个Entity死亡后，他不会被销毁内存，而是放入内存池中，他的组件也会回到内存池，但是会被置为空。这就导致控制器其实并不知道自己控制的Entity是否死亡了，必须每回合通过IsAlive()方法来查询。这就导致增加了很多的IsAlive()语句。\n有时候会莫名其妙地使用重生的Entity，这是因为Entity回到内存池然后又被拿出来的原因。但是这个时候Entity所代表的的实体可能已经完全变化了（可能上次是飞船，这次是子弹），所以会导致程序混乱。主要是因为我已开始太自信了，没有加上IsAlive()在实体死亡的时候替换他。\n而且我在编写的过程中逐渐意识到，其实我并不需要ECS系统，我老老实实用Sprite和继承就可以了，因为我发现在代码逐渐增加的过程中，ECS本身就趋向于可以使用Sprite表现的情况，而由于ECS的存在我的代码反而更加凌乱了。\n然后是关于智能指针的思考。确实，我们应该尽量地使用智能指针。我现在已经开始大量用unique_ptr了，但是这次的制作让我看到了shared_ptr的力量。很多时候其实用智能指针就可以解决问题，但是我自己传递裸指针造成了很多麻烦。\n","description":"","tags":["game development"],"title":"SpaceWar制作感想","uri":"/posts/spacewar%E5%88%B6%E4%BD%9C%E6%84%9F%E6%83%B3/"},{"categories":null,"content":"这里说明一下如何在SDL2中使用OpenGL。\nSDL + GLEW 这个方法是使用SDL和GLEW两个库。GLEW是用来导入OpenGL函数的。\n首先我们需要导入头文件：\n1 2 3 #define GLEW_STATIC #include \"GL/glew.h\" #include \"SDL/SDL.h\" 这里定义了GLEW_STATIC，表示我们要使用glew的静态库。\n然后需要配置OpenGL：\n1 2 3 4 5 6 7 8 9 10 11 12 SDL_Init(SDL_INIT_EVERYTHING); SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3); //主版本3 SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3); //副版本3 SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE); //核心库 window = SDL_CreateWindow(title.c_str(), SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, width, height, SDL_WINDOW_OPENGL|SDL_WINDOW_SHOWN); SDL_GL_CreateContext(window); //将本窗口作为绘制载体 glewExperimental = GL_TRUE; glewInit(); //初始化glew库，一定要在窗口创建之后初始化 这里首先使用SDL_Init()初始化了SDL，然后需要使用SDL_GL_SetAttribute()函数来给SDL说明使用那个版本的SDL。这里使用的是3.3版的核心库。\n然后创建了SDL窗口用于作为绘制的容器。需要注意这里不再需要SDL_Renderer，因为我们直接用OpenGL绘制。然后需要使用SDL_GL_CreateContext()函数指定这个窗口为绘制载体。\n创建窗口的时候要指定SDL_WINDOW_OPENGL来启用窗体的OpenGL支持。\n最后需要初始化GLEW库，使用glewInit()即可。 这里需要注意的是：在Windows和Linux系统上，你需要在glewInit()之前加上glewExperimental = GL_TRUE;语句，不然在Linux上会报核心短转储的错误。在MacOSX下不用。\n主循环中的窗口更新 除了上面的配置之外，其他的就和OpenGL一样了，该怎么编写就怎么编写。在主循环中窗口更新的函数是SDL_GL_SwapWindow()。\nSDL + 系统OpenGL库 这个方法是使用SDL和系统的OpenGL库。这个方法不需要除SDL外的任何拓展库。缺点是SDL目前只支持到OpenGL4.4版本函数（SDL2.0.14），使用更高版本函数可能还得用GLEW（或者手动加载）\n其他的操作和上面一样，但是我们要包含一些其他头文件：\n1 2 #define GL_GLEXT_PROTOTYPES #include \"SDL_opengl.h\" 然后在编译的时候需要链接系统的OpenGL库。我这里是Mac系统，直接连接的OpenGL.framework:\n1 g++ main.cpp `sdl2-config --libs --cflags` -framework OpenGL 这样就可以使用了，很简单对吧。\n在Windows下应该是连接opengl32或opengl64库。在Linux下应该是GL库。\n添加SDL没有的OpenGL函数 如果你使用的OpenGL版本过高，导致有一些函数没法使用，但是你又不想引入其他辅助库，那么你可以自己手动引入这些函数。主要的方法是使用\n1 void* SDL_GL_GetProcAddress(const char *proc); 函数获得OpenGL的函数。\n在include了SDL_opengl.h的情况下，首先我们要声明自己的函数：\n1 2 3 4 5 // 这里以glGenBuffers()为例 // 首先声明函数指针 typedef void (APIENTRY * GLGENBUFFERSFN)( GLsizei n, GLuint* buffers ); // 然后声明函数 GLGENBUFFERSFN glGenBuffers; 然后我们要找到OpenGL函数并赋值给glGenBuffers:\n1 2 3 4 5 6 7 8 9 10 11 12 glGenBuffers = (GLGENBUFFERSFN)SDL_GL_GetProcAddress(\"glGenBuffers\"); // 如果没有找到，检查一下OpenGL拓展内有没有 // 检查ARB拓展 if (!glGenBuffers) { glGenBuffers = (GLGENBUFFERSFN)SDL_GL_GetProcAddress(\"glGenBuffersARB\"); } // ARB里面没有就检查一下EXT if (!glGenBuffers) { glGenBuffers = (GLGENBUFFERSFN)SDL_GL_GetProcAddress(\"glGenBuffersEXT\"); } // 如果还没找到，那就是真没了，报错吧 throw std::runtime_error(\"can't find glGenBuffers function\"); 可以使用这个方法添加所有SDL原生不支持的OpenGL API。\n运行时打开OpenGL库 如果你想要运行时打开OpenGL库，你可以使用\n1 int SDL_GL_LoadLibrary(const char *path); 打开。传入参数为NULL时打开默认的库。返回0代表成功。\n这个函数必须在初始化Video模块之后，创建支持OpenGL的窗口之前调用。\n打开之后需要用上面添加OpenGL函数的方式将你要使用的gl函数找到（所以并不推荐用这种方法），这个时候，你不应该包含SDL_openg.h，因为他里面有很多gl函数声明，你的声明会和他冲突。\n程序结束后不要忘记关闭库：\n1 void SDL_GL_UnloadLibrary(void); ","description":"","tags":["SDL2","OpenGL"],"title":"SDL2-使用OpenGL","uri":"/posts/sdl2-%E4%BD%BF%E7%94%A8opengl/"},{"categories":null,"content":"这里是《C++ Tempaltes 2th》的读书笔记\n万能引用(Universal Reference) 在模板中，存在一种万能引用模板，其参数是T\u0026\u0026：\n1 2 template \u003ctypename T\u003e void foo(T\u0026\u0026); 这种引用时可以同时接收左值和右值引用的（不像T\u0026只能接受左值引用）：\n1 foo(3); // T\u0026\u0026 -\u003e int\u0026\u0026; T -\u003e int 当传入一个右值/右值引用时，它会将其推导为对应的引用。\n1 2 3 4 5 6 7 int a = 32; const int b = 64; const int\u0026 ra = a; foo(a); // T -\u003e int\u0026; T\u0026\u0026 -\u003e int\u0026 foo(b); // T -\u003e const int\u0026; T\u0026\u0026 -\u003e const int\u0026 foo(ra); // T -\u003e const int\u0026; T\u0026\u0026 -\u003e const int\u0026 注意这里T的推导：被推导为int\u0026或const int\u0026而不是int或const int！\n这个规则在转发函数参数时会造成问题：\n1 2 3 4 5 6 7 8 9 10 11 template \u003ctypename T\u003e void foo(T\u0026); // 针对值引用 template \u003ctypename T\u003e void foo(T\u0026\u0026); // 针对右值 // 调用foo函数的万能引用模板 template \u003ctypename T\u003e void caller(T\u0026\u0026 t) { foo(t); } 这个时候，无论t是T还是T\u0026，t都会被视为T\u0026，都会调用左值引用的foo函数（第一个函数）。\n完美转发 要解决如上的参数转发问题，必须要使用完美转发。\n完美转发会保留变量原本的特性：\n可变变量转发后仍然可变 const变量转发后仍然为const 可移动对象转发后仍然是可移动的 完美转发就一个函数：std::forward()，我们需要这么用：\n1 2 3 4 template \u003ctypename T\u003e void caller(T\u0026\u0026 t) { foo(std::forward\u003cT\u003e(t)); } 使用万能引用的麻烦 使用万能引用的时候，T会被视为T\u0026，这意味着你没办法在函数体内声明非引用变量：\n1 2 3 4 5 6 7 template \u003ctypename T\u003e void foo(T\u0026\u0026 t) { T x; // ERROR, T -\u003e T\u0026 } int a = 10; foo(a); 这里由于T会被推断为int\u0026，所以这里x的声明是错误的。\nstd::move std::move说白了就是一个类似于static_cast的强制类型转换，它会将所有的类型强转到右值引用。但是其本身不会进行移动操作。\n注意以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class String { public: String() = default; String(const String\u0026); String(String\u0026\u0026); }; // call String a; String b(std::move(a)); // [1] const String c; String b(std::move(c)); // [2] 这里[1]将会调用String的拷贝构造函数，这毋庸置疑。\n但是[2]同时也会调用拷贝构造函数。记住，std::move只是将类型强转为右值引用，这意味着其会保留const标识，也就是说[2]中经过std::move之后的类型为const String\u0026\u0026，这类型和移动构造函数的类型不符，所以会调用拷贝构造函数。\nstd::move和std::forward的区别 他们两个本质上都是强制类型转换，只不过std::move无条件转换，而std::forward是只有参数为右值引用的时候才会转换。\n","description":"","tags":["cpp"],"title":"C++ Templates 5-万能引用完美转发","uri":"/posts/c++-templates-5-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"},{"categories":null,"content":"我们都知道，const T\u0026这种形式的参数可以避免拷贝，从而提高性能。但是几乎没有人会对基本数据类型写这样的参数。这是因为这样做并不能提高性能。\n在底层上，按引用传递其实还是通过传地址实现的，但是这就有一个问题：传入的地址上的值是可以被用户随意修改的。这就意味着每次处理完这个值后，缓存在寄存器中的此变量值将会无效，编译器不得不从Cache或者内存中再次得到这个值。这个操作的开销在基本数据类型的情况下可能会比拷贝产生的开销更大。\n你可能会说：我这里标了const了，明确了不会被改变了啊。但是编译器并不能做到这一点（或者说保证这一点），因为有一些方式可以改变值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void Modify(const int\u0026 value1) { a = 123; } // call: // a 是全局变量 // Modify(a); void Modify(const int\u0026 value) { int\u0026 b = const_cast\u003cint\u0026\u003e(value); b = 32; } // call: Modify(a); 第一种情况是在函数中虽然传入了const引用，但是a是全局变量，在这种情况下const引用就没有意义。\n第二种情况是使用const_cast将常量引用转为普通引用，从而改变参数的值。\n但是在函数inline的时候，编译器可能可以通过调用者和被调用者的信息推断出参数是否可以被修改，尤其是对于模板函数。\n","description":"","tags":["cpp"],"title":"C++对基本数据类型进行const T\u0026有意义吗","uri":"/posts/c++-%E5%AF%B9%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8Cconst-t%E6%9C%89%E6%84%8F%E4%B9%89%E5%90%97/"},{"categories":null,"content":"这里是《C++ Templates 2th》的读书笔记。\nSFINAE 为Substitution Failure Is Not An Error的简写，意味着“替换失败并不是个错误”。\n假设我们现在有这样的代码：\n1 2 3 4 5 6 7 8 class Buffer { public: void Append(char c, size_t repeat); // [1] void Append(const char* c, size_t len); // [2] template \u003ctypename Iter\u003e void Append(Iter begin, Iter end); // [3] }; [1]的功能是在buffer中放入repeat个字符c。\n[2]的功能是将字符串c放入buffer中。\n[3]的功能是给入迭代器begin和end，将其间所有数据放入buffer。\n接下来我们看一下这个使用方法：\n1 2 3 Buffer buffer; int ch = getchar(); buffer.Append(ch, 10); 这里我们的本意是让其调用[1]，往buffer里放10个ch。但是编译器会调用[3]，因为[3]更符合参数为int, int的情况。\n这里我不想让这种情况发生，那么我们可以这样写：\n1 2 3 4 template \u003ctypename Iter, typename = typename std::enable_if\u003c !std::is_integral\u003cIter\u003e::value\u003e::type\u003e void Append(Iter begin, Iter end); // [3] 这里就不得不介绍一下enable_if和is_integral了。\nis_integral只有一个模板参数T，并且有一个静态成员bool value。当T为整数类型时，value为true，否则为false。说白了他就是用来判断类型是否为整数的模板类。\nenable_if有两个模板参数数enable_if\u003cbool, typename T = void\u003e，和一个类型别名using type = XXX。如果bool为true，则enable_if的type成员为T，否则不存在这个成员。\n那么再回来看这个模板。当我们传入两个整型的时候，std::_is_integral\u003cIter\u003e::value将会返回true，我们对他取反变为false，这样std::enable_if\u003cfalse\u003e就不存在type这个成员，那么这个模板显然就是有问题的，编译器就不会去匹配这个模板，但是他也不会报错，而是去寻找下一个函数看看能不能匹配。显然，这会匹配到void Append(char, size_t)。\n这就是SFINAE，当出现了无意义或者有问题的模板匹配时，编译器不会报错，而是自动忽略，所以这规则叫做“替换失败不是个错误”。\n类型萃取 类型萃取是一个利用模板特性而实现的功能（一般是利用特化），其典型的一个用法就是从指针类型种将原类型抽出，即我们要实现这样一个功能：\n1 2 3 strip_point\u003cint*\u003e::type a; // 这里a是int类型，strip_point会将任意指针类型的指针符去掉一个 strip_point\u003cint**\u003e::type b; // 这里b是int*类型。 strip_point\u003cint\u003e::type c; // 这里c是int类型，当类型不是指针时不改变传入类型 如何实现呢，请看代码：\n1 2 3 4 5 6 7 8 9 template \u003ctypename T\u003e // [1] struct strip_point { using type = T; }; template \u003ctypename U\u003e // [2] struct strip_point\u003cU*\u003e { using type = U; }; 这里使用了模板的偏特化。[1]是模板的通用形式，对于任意的类型T，让type为\nT，即不改变传入的类型。\n[2]是模板的偏特化，注意strip_point\u003cU*\u003e，当我们传入strip_point\u003cint*\u003e时，U*会被推断为int*，这样U就是int了，所以这样就剥离了一层指针。\n这种从某种混合类型种抽取（萃取）出某种特定类型的功能就是类型萃取。\n我们可以这样来让此功能变得更方便使用：\n1 2 template \u003ctypename T\u003e using strip_point_t = strip_point\u003cT\u003e::type; 类型萃取广泛地运用在标准库中，尤其是type_triats头文件里。上面strip_point的功能其实就是标准库中remove_pointer的功能。\nenable_if的实现 接下来我们简单实现一个enable_if：\n1 2 3 4 5 6 7 8 9 10 template \u003cbool BOOL, typename T = void\u003e struct EnableIf; template \u003ctypename T\u003e struct EnableIf\u003ctrue, T\u003e { using value = T; }; template \u003cbool B, typename T = void\u003e using EnableIfV = typename EnableIf\u003cB, T\u003e::value; 很简单吧，就是根据enable_if的定义，使用偏特化就可以做出来了。\n通用函数 我们可以通过这种形式给模板一个通用函数：\n1 return_type YourFunc(...); 你没看错，参数就是三个点。这种函数总会匹配所有调用，但是其匹配情况是重载函数中最差的，不到万不得已找不到其他函数时编译器是不会调用这个函数的。\n","description":"","tags":["cpp"],"title":"C++ Templates 4-SFINAE,类型萃取和enable_if","uri":"/posts/c++-templates-4-sfinae%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96%E5%92%8Cenable_if/"},{"categories":null,"content":"这里是《C++ Templates》第二版的读书笔记\n变参模板(Variadic Template) 使用方式如下：\n1 2 template \u003ctypename... Args\u003e void foo(Args... args); 这里的Args被称为template parameter pack，而args被称为function parameter pack。\n这里有一个输出每个参数的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 void Print() {} template \u003ctypename T, typename... Args\u003e void Print(T value, Args... args) { std::cout \u003c\u003c value \u003c\u003c std::endl; Print(args ...); } int main() { Print(1, 2.18, \"string\"); } 使用模板变参的时候不能够像使用vector一样去遍历，我们只能通过递归的方式处理参数。\n这里Print调用之后，所有的参数都会被传入void Print(T, Args...)中，这会让此函数展开为void Print\u003cint, int, const char*\u003e(1, 2, \"string\")，而1会传给value，剩下的参数会传给args，所以会输出1。然后此函数再次递归地调用自己，将2输出，再是最后的字符串，直到没有任何参数剩下时，会调用普通的print(){}函数结束递归。\n如果存在普通参数模板（如template \u003ctypename T\u003e void Print(T value)），则会在只剩下最后一个参数时调用此模板函数（因为此模板的条件最为精确）。\nsizeof... 在C++11中，可以通过sizeof ...操作符得到模板变参的个数：\n1 2 3 4 5 template \u003ctypename T, typename... Args\u003e void Print(T value, Args... args){ std::cout \u003c\u003c \"remain paramter num = \" \u003c\u003c sizeof...(args) \u003c\u003c std::endl; /* ... */ } 或者写sizeof...(Args)也可以。\n折叠表达式(Fold Expression) C++17开始可以使用折叠表达式来对模板变参进行一些简单操作：\n1 2 3 4 template \u003ctypename... Args\u003e auto Sum(Args... args) { return (... + args); } 这个式子对所有的参数进行求和。\n有如下可能的折叠表达式形式：\n折叠表达式 如何求值 (... op pack) (((pack1 op pack2) op pack3 ... op packN) (pack op ...) (pack1 op (pack2 op (... (packN-1 op packN)))) (init op ... op pack) (((init op pack1) op pack2) ... op packN) (pack op ... op init) (pack1 op (pack2 op (... (packN op init)))) 看完这个你应该知道为什么他叫Fold Expression了，没错，这就是函数式编程中的“折叠”(Fold)。而且还分为左右折叠。\n实际应用 变参模板用的最多的可能就是将函数参数进行转发了，比如我们可以改良上一篇文章中的内存池，让他通过不同的构造函数构造对象：\n1 2 3 4 5 6 // in template\u003ctypename T\u003e class Pool; template \u003ctypename... Args\u003e T* Create(Args... args) { T* element = new T(args ...); /* ... */ } 一般都会用Args\u0026\u0026... args进行完美转发，这个后面再说。\n变参表达式 指一些好用的表达式：\n1 2 3 4 template \u003ctypename... Args\u003e void AddOne(Args... args) { Print(args + args...) } 这个函数会将所有的参数翻倍，即下面两行是等价的：\n1 2 AddOne(1, 2, 3, 4); Print(1 + 1, 2 + 2, 3 + 3, 4 + 4); 甚至可以和数字相加：\n1 2 3 AddOne(Args... args) { Print(args + 1 ...); } 这会将所有的参数+1。\n变参下标 看看这种用法：\n1 2 3 4 template \u003ctypename C, typename... Idx\u003e void PrintElements(const C\u0026 container, Idx... idx) { Print(container[idx]...); } 下面是一种展开例子：\n1 2 3 void PrintElements(v, 1, 2, 3, 4) { Print(v[1], v[2], v[3], v[4]); } 也可以用非类型模板参数：\n1 2 3 4 template \u003csize_t... Idx, typename C\u003e void PrintElements(const C\u0026 container) { Print(container[Idx]...); } 变参模板类 模板类也可以使用变参，这种方式在C++标准库中屡见不鲜，比如tuple的声明：\n1 2 template \u003ctypename... Elements\u003e class Tuple; Variant也使用了这种声明。\n或者我们可以发挥想象：变参不仅仅可以指定成员变量的类型，它还可以指定基类的类型：\n1 2 3 template \u003ctypename... Bases\u003e class Child: Bases ... { }; 这样就创造了一个集成多个类的模板类。\n","description":"","tags":["cpp"],"title":"C++ Templates 2-变参模板","uri":"/posts/c++-templates-2-%E5%8F%98%E5%8F%82%E6%A8%A1%E6%9D%BF/"},{"categories":null,"content":"这里是《C++ Templates 2th》的读书笔记\n使用模板时的一些小知识 typename关键字用于告诉编译器接下来的东西是类型而不是其他，比如：\n1 2 3 4 5 template \u003ctypename T\u003e void foo() { typename Class::InnerType a; /* ... */ } 这里明确说明InnerType是Class内的类型，而不是静态成员变量或其他。\n使用a{}的方式对变量进行零初始化：\n1 2 3 4 template \u003ctypename T\u003e void foo() { T a{}; } 基本数据类型会被初始化，bool初始化为false，数值类型初始化为0。C++11之前用a()的方式。\n继承了模板类的子类，在调用父类的成员函数时需要显式地使用this或者Base\u003cT\u003e:::\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 template \u003ctypename T\u003e class Base { public: void DoSomething(); }; template \u003ctypename T\u003e class Derived: public Base\u003cT\u003e { public: void DoMyself() { this-\u003eDoSomething(); // or use Base\u003cT\u003e::DoSomething(); } }; 全特化的函数被视为全局函数而非模板函数。这意味着在头文件中全特化某个模板函数时需要将这个函数声明为inline：\n1 2 3 4 5 6 7 8 9 template \u003ctypename T\u003e void foo() { std::cout \u003c\u003c \"template foo\" \u003c\u003c std::endl; } template \u003c\u003e inline void foo\u003cint\u003e() { std::cout \u003c\u003c \"int foo\" \u003c\u003c std::endl; } 某些时候需要使用template关键字显式指定要调用的是模板成员函数：\n1 std::cout \u003c\u003c instance.template foo\u003cint\u003e(3) \u003c\u003c std::endl; 这里如果不加template，编译器会将\u003c视为小于的逻辑运算。\n使用auto关键字来使用泛型Lambda：\n1 [](auto a, auto b) { return a + b; } 模板参数模板（Template Template Parameter）\n指模板参数是一个模板，比如：\n1 2 3 4 5 template \u003ctypename T, typename Cont\u003e class A { public: Cont container; }; 这里我们要存储的元素类型是T，容器的类型时Cont，但是我们使用的时候得指定容器内元素的类型：\n1 A\u003cint, std::vector\u003cint\u003e\u003e a; 我们想这样写：\n1 A\u003cint, std::vector\u003e a; 让C++自动推断容器元素类型。这个时候容器就必须变为模板参数模板：\n1 2 3 4 5 6 7 template \u003ctypename T, template \u003ctypename Elem, typename Allocator = std::allocator\u003cT\u003e\u003e class Cont\u003e class A { public: Cont\u003cT\u003e container; }; 这里要注意的是多出来的Allocator模板参数，因为std::vector的模板声明为：\n1 2 3 4 template\u003c class T, class Allocator = std::allocator\u003cT\u003e \u003e class vector; 它是有两个模板参数的，所以如果我们要用std::vector作为其容器的话就必须将两个参数都适配上，这就是为什么Allocator也要写的原因。\n上面的代码中Elem和Allocator都没有用到，没用到的模板参数可以省略名字：\n1 2 3 4 template \u003ctypename T, template \u003ctypename, typename = std::allocator\u003cT\u003e\u003e class Cont\u003e class A; ","description":"","tags":["cpp"],"title":"C++ Templates 3-一些细节","uri":"/posts/c++-templates-3-%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/"},{"categories":null,"content":"这里是《C++ Templates》第二版的读书笔记\n函数模板 函数模板的定义举例：\n1 2 3 4 template \u003ctypename T\u003e T Sum(T a, T b) { return a + b; } 使用模板：\n1 2 3 Sum(1, 2); // OK，模板自动推导T为int Sum(1l, 2l); // OK，模板自动推导T为long Sum(3.12, 5.18); // OK，模板自动推导为double 注意：模板的参数可以退化(decay)，但是不能进行隐式转换：\n1 2 Sum(3.12f, 5.18); // Error，第一个参数是float，第二个参数是double，无法推断 Sum(1, 2.3); // Error 第一个参数是int，第二个是double，无法推断 这个时候可以强制指定模板参数：\n1 Sum\u003cint\u003e(1, 2.3); // OK 2.3转换为int 二阶段翻译（Two-Phase Translation） 模板的编译是“两阶段的”\n首先模板会检查所有不含模板参数T的语法是否正确，这意味着： 语法错误会被检测到，比如缺了分号 不依赖模板参数的语句的语法错误也会被检测到 不依赖于模板参数的static_assert会被执行 然后如果存在模板实例化，将会将实际的类型代替模板参数T再次检查模板的语法是否正确 比如下面这段代码：\n1 2 3 4 5 6 7 template \u003ctypename T\u003e void foo(T t) { static_assert(false); // Error, 此静态断言不依赖于T，会执行，表现为编译时报错 static_assert(T == 3); // OK， 此静态断言依赖于T，将会推迟到第二阶段（模板实例化的阶段）执行 std::cout \u003c\u003c T-\u003eGetName(); // OK，此语句依赖于T，推迟到第二阶段检查语法 std::cout \u003c\u003c 3 // Error， 此语句不依赖于T，会在第一阶段进行语法检查 } 这意味着，实例化模板时，你的类必须能够满足两个条件才不会报编译错误：\n可以和整数用operator==比较 有GetName()成员函数 这其实是限制了使用此模板类的类型，强制要求这些类增加这些操作（而不是使用继承）。\n这就给我们一个新思路，试想我们现在要编写一个内存复用池：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template \u003ctypename T\u003e class Pool final { public: T* Create() { T* element; if (cache_.empty()) { element = cache_.top(); cache_.pop(); element-\u003eReset(); } else { element = new T; element-\u003eReset(); elements_.push_back(element); } return element; } void Destroy(T* element) { /* ... */ } private: std::vector\u003cT*\u003e elements_; std::stack\u003cT*\u003e cache_; }; 这个池子将所有不使用的对象放入cache_中，当调用Create()函数时会首先检查cache_中是否存在元素，如果有就拿出来调用其Reset()函数重置对象并返回，否则new一个新的对象。\n可以看出，要想让此模板类实例化成功，T类型必须满足两个条件：\n拥有一个默认构造函数 拥有一个Reset()成员函数，并且Pool可以访问这个函数（这意味着如果是私有函数，你需要将Pool变为友元） 这样，只要任何类满足上面的条件，就可以使用此内存池。不满足条件的将在编译时就报错。\n如果用面向对象，你可能需要一个基类：\n1 2 3 4 5 class PoolElement { public: virtual ~PoolElement(); virtual void Reset() = 0; }; 然后每个要放入内存的类都继承他，这有一些缺点：\n新类必须记得继承此类 虚函数会带来性能开销，尤其是继承链越来越长时 但是使用模板就不会存在这种问题。无疑模板是一种更加通用的方法。\n模板参数推导及 作为函数参数的模板参数推导(Decay规则) 当模板参数作为函数参数时，会有一些奇怪的推导规则：\n不能够进行窄缩的隐式转换 1 2 3 4 5 template \u003ctypename T\u003e void foo(T a, T b); foo(1, 2); // OK, T推导为int foo(1, 2.12); // Error, 1是int，2.12是double，无法推导 foo(1.23, 2.18f); // Error, 1.23是double，2.18是float，无法推导 当为引用时T\u0026，不会发生什么奇怪的事情 当为值时T，实参的const和volatile和引用会被忽略；数组，函数会转变为对应的指针（这个规则被称为退化(Decay)） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 当模板参数为引用时，一切都很正常 template \u003ctypename T\u003e void fooRef(T\u0026 a) {} int a; fooRef(a); // T -\u003e int, fooRef(T\u0026) -\u003e fooRef(int\u0026) const int b; fooRef(b); // T -\u003e const int, fooRef(T\u0026) -\u003e fooRef(const int\u0026) int arr[32]; fooRef(arr); // T -\u003e int[32], fooRef(T\u0026) -\u003e fooRef((int[32])\u0026) // 当模板参数为值时，存在特殊规则 template \u003ctypename T\u003e void fooVal(T a) {} int\u0026 c = a; fooVal(c); // T -\u003e int, fooVal(T) -\u003e fooVal(int) const int\u0026 b = a; fooVal(b); // T -\u003e int, fooVal(T) -\u003e fooVal(int) int arr[32]; fooVal(arr); // T -\u003e int*, fooVal(T) -\u003e fooVal(int*) 现在来猜一猜，const char* const传入后会被退化成什么？\n答案是const char*，指针部分可以被修改，但是指针指向的值不能被修改。总之，传入的参数总会退化成自己可被修改的类型\n作为返回值的模板参数推导 可以额外增加一个模板参数用过返回值：\n1 2 3 4 template \u003ctypename T1, typename T2, typename Ret\u003e Ret Sum(T1\u0026 a, T2\u0026 b) { return a + b; } 或者使用高级一点的返回值推导\n在C++11中，你可以使用auto和decltype：\n1 2 3 4 template \u003ctypename T1, typename T2\u003e auto Sum(T1\u0026 a, T2\u0026 b) -\u003e decltype(T1 + T2) { return a + b; } 在C++14时，可以不使用decltype直接使用auto。\n默认模板参数 可以给模板参数以默认值，和函数参数一样，默认值要放到最后：\n1 2 template \u003ctypename T1, typename T2 = int\u003e void foo(); 注意typename在这里的新用法：\n1 2 3 4 5 6 7 8 9 10 struct NewStruct { using MyString = std::string; }; template \u003ctypename T1\u003e void foo() { typename T1::MyString* mystring; // here! /* ... */ } 为什么变量声明前要加上typename？这是因为这句话对应着两个可能的实例化，一个就是讲mystring实例化为指针，而另一个：\n1 2 3 struct NewStruct { static int MyString; }; 这个时候T1::MyString* mystring会变成一个乘法操作，编译器就会误判。\n所以为了防止这种情况发生，需要使用typename强制告诉编译器我要一个类型而不是其他什么的。\n模板函数重载 模板函数可以重载一模一样的非模板函数：\n1 2 3 4 void foo(int a, int b); template \u003ctypename T\u003e void foo(T a, T b); 在使用的时候会优先使用非模板参数，除非你加了模板限定符：\n1 2 foo(1, 2); // normal function call foo\u003c\u003e(1, 2); // template function call 但是当参数有所不同时，会优先使用更精确的那一个（无论是模板还是非模板参数）：\n1 2 3 4 5 6 7 8 void foo(int, int); template \u003ctypename T1, typename T2\u003e void foo(T1, T2); foo(1, 2); // call the normal function foo(1, 2.2); // call the template function 传值还是传引用 一般来说，按值传递更好：\n语法简单 编译器能够更好地优化 移动语义可以减少拷贝 某些情况下甚至没有移动和拷贝 对于模板函数来说有一些特殊情况：\n模板又可以用于简单类型，又可以用于复杂类型，所以选择值传递这种普通的方式更好 就算以普通方式传值，你也可以使用ref()和cref()传递引用 引用传递字符串字面量和普通数组会有问题（虽然按值传递也有，但是引用传递问题更大） 干嘛不用inline 其实在现在来看，由于编译器优化，inline这个关键字只剩下“让函数定义在头文件中”这一种用途。而模板函数自身就满足这个性质，所以没必要用inline（除了全特化的模板函数，因为那个时候他已经是普通函数了）\n类模板 很简单，类比函数模板，就是把模板参数用在类里面：\n1 2 3 4 5 6 7 8 template \u003ctypename T\u003e class Person { T info; std::string name; int height; public: T\u0026 GetInfo() { return info; } }; 主要的注意点在于，实例化模板类的时候并不是所有的成员函数都实例化，只是用到的成员函数会被实例化。所以即使你的类型不具备某种操作，只要不掉用包含那种操作的成员函数的话也可以实例化。\n友元函数 可以使用不同的模板参数进行友元的声明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template \u003ctypename T\u003e class Person { T info; public: Person(T value): info(value) {} template \u003ctypename U\u003e friend std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026, const Person\u003cU\u003e\u0026 p); }; template \u003ctypename T\u003e std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 o, const Person\u003cT\u003e\u0026 p) { o \u003c\u003c p.info; return o; } 或者先声明模板函数再友元：\n1 2 3 4 5 6 7 8 template \u003ctypename T\u003e class Person; template \u003ctypename T\u003e std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026, const Person\u003cT\u003e\u0026); // in class Person template \u003ctypename T\u003e class Person { friend std::ostream\u0026 operator\u003c\u003c \u003cT\u003e(std::ostream\u0026, const Person\u003cT\u003e\u0026); }; 这里注意Person类里面的opertor\u003c\u003c \u003cT\u003e()中的\u003cT\u003e，这其实是对这个函数模板的特化。\n类型推导 C++17前必须将所有的模板参数显式地写出来（除非有默认模板参数），从C++17开始编译器可以自动推导了。\n推断指引(Deduction Guides) 通过推断指引我们可以修正现有的模板推断规则：\n1 Person(const char*) -\u003e Person\u003cstd::string\u003e 这告诉编译器，当模板参数为const char*时自动推导为std::string。这语句必须出现在和模板类的定义相同的作用域或命名空间中。\n甚至对聚合类也可以做到这一点（聚合类是指无显式定义的，继承的构造函数，无private和protected的非静态成员，无虚函数，无virtual和protected,private父类的类）：\n1 2 3 4 5 6 7 8 9 10 template \u003ctypename T\u003e struct Value { T value1; std::string value2; }; Value(const char*, const char*) -\u003e Value\u003cstd::string\u003e; // use Value value = {\"hello\", \"template\"}; 缺少了上面的推断指引将不能够这样使用，因为没有这样的构造函数供模板完成类型推断。\n非类型参数 即模板参数不是一个类型，而是一个值：\n1 2 template \u003cint ID\u003e void GetID() { return ID; } 注意：GetID\u003c1\u003e和GetID\u003c2\u003e不是一个函数，和将ID作为参数不同，他们是两个函数！\n偏特化和全特化 偏特化指将模板参数中的一些（非全部）类型固定：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 template \u003ctypename T, typename U\u003e class Test { T a; U b; }; template \u003ctypename T\u003e class Teset\u003cT, int\u003e{ T a; int b; }; ```file:///Users/visualgmq/Documents/blog/source/_posts/C++ Templates 5-完美转发.md 而全特化则是将所有模板参数的类型固定，这个时候函数会**被视为普通的全局函数**： ```cpp template \u003c\u003e void foo\u003cint, float\u003e(int , float b); 注意：模板函数不能偏特化，只有类可以偏特化。两者都可以全特化\n处理字符串常量和裸数组 处理这两个东西头疼的点在于模板参数到底是使用T还是T\u0026，因为这涉及到decay的问题。\n当你使用T时，参数会退化，这就会造成你分不清传入的到底是数组还是指针。而如果是T\u0026的话，则会有更加麻烦的事情：\n1 2 3 4 5 template \u003ctypename T\u003e void concat(T\u0026 arr1, T\u0026 arr2); // call: concat(\"hello\", \"world!\"); // ERRO! 这里会出现错误，因为hello是const (char\u0026)[5]而world!是const (char\u0026)[6]。这会导致参数不匹配，所以模板无法实例化。\n解决的办法是在内部使用指针：\n1 2 T* a1 = arr1; T* a2 = arr2; 这样不管传入的是数组还是指针都会变为指针。\n或者对指针和数组类型编写两个不同的模板函数（这里可以使用enable_if配合is_array）：\n1 2 3 4 5 6 template \u003ctypename T, typename = std::enable_if_t\u003cstd::is_array_v\u003cT\u003e\u003e\u003e void foo(T\u0026 a); // 为数组编写的函数 template \u003ctypename T\u003e void foo(T\u0026 a); // 为非数组的函数 ","description":"","tags":["cpp"],"title":"C++ Templates 1-基础知识","uri":"/posts/c++-templates-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"本文说明了程序热加载的原理。\n热加载原理很简单，就是让程序在运行时打开动态库，并且获得里面的新函数。\n这个技术也可以用在软件更新的时候，可以只将更新的动态库发布，用户下载之后在客户端重新打开库即可，这就不需要重新下载整个软件了。\n这里我们来实战一下：\nWindow上的函数是：\n1 2 3 void* LoadLibraryA(libname); // 加载动态库 void* GetProcAddress(handle, funcname); // 从动态库内获得函数 void FreeLibrary(handle); // 释放动态库 Linux上则是：\n1 2 3 void* dlopen(const char *filename, int flags); // flags为RTLD_NOW即可 void* dlsym(void *handle, const char *symbol); int dlclose(void *handle); 我这里直接用SDL给我封装好的函数了（编译平台是Linux）：\n1 2 3 void* SDL_LoadObject(const char *sofile); void* SDL_LoadFunction(void *handle, const char *name); void SDL_UnloadObject(void *handle); 首先我们写个库，这个库只有简简单单一个函数：\n1 2 3 4 5 6 7 8 9 10 11 12 // script.cpp #include \u003ciostream\u003e extern \"C\" { void ScriptSay() { std::cout \u003c\u003c \"script say 1\" \u003c\u003c std::endl; } } // 编译指令 // g++ script.cpp -shared -fPIC -o libscript.so 这里我用的C++编译，C++编译会将函数的符号导出成其他的，所以我们要加上extern \"C\"来确保其导出正确。。\n然后我们来写调用的此库的主程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // main.cpp #include \u003ciostream\u003e #include \u003cstring\u003e #include \"SDL.h\" using namespace std; // 库的句柄 void* MyHandle = nullptr; // 要获得的函数指针类型 using MyFunc = void(*)(); int main(int argc, char** argv) { std::string str; // 加载库 MyHandle = SDL_LoadObject(\"./libscript.so\"); if (!MyHandle) { std::cout \u003c\u003c \"load lib failed: \" \u003c\u003c SDL_GetError() \u003c\u003c std::endl; } // 从库中导入需要的函数 MyFunc myFunc = (MyFunc)SDL_LoadFunction(MyHandle, \"ScriptFunc\"); while (cin\u003e\u003estr) { if (str == \"reload\") { // 如果输入reload，我们就重新加载库和函数 SDL_UnloadObject(MyHandle); MyHandle = SDL_LoadObject(\"./libscript.so\"); MyFunc myFunc = (MyFunc)SDL_LoadFunction(MyHandle, \"ScriptFunc\"); } if (!myFunc) { std::cout \u003c\u003c \"load func failed: \" \u003c\u003c SDL_GetError() \u003c\u003c std::endl; } else { myFunc(); // 调用函数 } } SDL_UnloadObject(MyHandle); // 释放库句柄 return 0; } // 编译指令 // g++ main.cpp -o main.out `sdl2-config --libs --cflags` 这样就写好了，注意不需要在编译指令中加上链接库，那种方法是编译时连接。\n然后我们运行main.out，随便输入一些东西后程序会输出\n1 script say 1 这个时候不要关闭程序，再次打开script.cpp修改其输出为script say 2，编译，然后我们在程序中输入reload，他就会输出script say 2了。\n","description":"","tags":["SDL2"],"title":"程序热加载原理","uri":"/posts/%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"本文介绍了如何在不使用SDL_mixer的情况下，只使用SDL2进行声音的播放和录制。\n我在移植我的引擎到安卓平台的时候发现SDL_mixer的CMake有问题，而且这个玩意经常整些bug。于是翻了翻SDL的wiki，百度了之后决定使用SDL2进行一个音频的播放。\n播放音频的原理 SDL2播放音频的原理非常底层：首先需要打开一个音频设备，然后对这个设备写入音频数据就可以播放了。\n示例 在进行SDL_Init(SDL_INIT_AUDIO)初始化Audio模块后，我们首先载入一个WAV文件：\n1 2 3 4 5 6 7 Uint8* soundData = nullptr; Uint32 soundLen = 0; SDL_AudioSpec soundSpec; if (!SDL_LoadWAV(\"assets/pickup.wav\", \u0026soundSpec, \u0026soundData, \u0026soundLen)) { SDL_Log(\"wav load failed: %s\", SDL_GetError()); } SDL本身只能通过SDL_LoadWAV函数载入WAV格式文件。如果你想要加载Ogg可以使用libvorbis或者stb_vorbis。其他的格式找对应的库就行了。\n读入之后我们获得了声音的数据soundData以及数据的大小soundLen，和音频的格式soundSpec。不要忘记SDL_FreeWAV()来释放soundData。\n接下来我们打开一个音频输出设备。这里有两种方法：\n使用SDL_OpenAudio打开 这是推荐的方法，这个方法的优点是不易用错，缺点是只能打开一个音频设备，如果你电脑上有多个音频设备你想要打开，可以使用SDL_OpenAudioDevice。\n1 2 3 if (SDL_OpenAudio(\u0026soundSpec, nullptr) \u003c 0) { SDL_Log(\"open audio deivce failed: %s\", SDL_GetError()); } 第一个参数是我们希望的AudioSpec，第二个参数是它有的AudioSpec，是一个输出参数。我们这里不需要这个参数，直接给NULL。\nSDL会自己帮我们从soundSpec转换为设备的格式，所以不需要担心。\n在文件结束的时候不要忘记SDL_CloseAudio()关闭设备。\n使用SDL_OpenAudioDevice打开 使用SDL_OpenAudioDevice的话，可以打卡多个音频设备。但是也会打开一些不存在的音频设备。在我的Mac电脑上就打开了不存在的音频设备，导致没办法输出声音。但是我看别人的视频确实是有成功的。\n这个函数原型如下：\n1 2 3 4 5 6 SDL_AudioDeviceID SDL_OpenAudioDevice( const char *device, int iscapture, const SDL_AudioSpec *desired, SDL_AudioSpec *obtained, int allowed_changes); device：要打开的设备的名字，为NULL就是打开一个默认的。 iscapture：要打开的设备是否是录音设备。在SDL2.0.5及之后，SDL可以打开录音设备来录音。 desired和obtained：和SDL_OpenAudio()的参数一样，一个是我们希望打开的设备格式，一个是设备真正的格式 allowed_changes：是否允许改变设备的某些格式。一般直接给0表示不允许。 这个函数返回的是一个设备ID，如果ID \u003c 0就是打开失败了。其实ID总是大于等于2的。\n使用这个方法打开设备后，后面所有对设备操作的函数都要加上Device，比如SDL_CloseAudioDevice()，SDL_PauseAudioDevice()等。 不要忘记使用SDL_CloseAudioDevice(id)来关闭。\nSDL_AudioSpec 打开音频我们需要一个SDL_AudioSpec，这里我建议你直接传通过SDL_LoadWAV得到的spec，这样不需要进行音频的格式转换。\n不过我们这里还是看一下初始化它时需要填充的各个成员，以便于后面讲格式转换：\nchannels：声道数 1： 单声道 2： 双声道（立体声） 4： 四声道 6： 5.1声道，是用于影院的那种。 format：设备接收的音频数据的格式，这里AUDIO_F32是指32位浮点数格式 freq：播放频率，即每秒送往音频设备的声音帧数。44100是CD频率，48000是DVD频率。不建议高于48000，这会造成更多的内存和CPU损耗。 samples：音频采样帧中的音频缓冲区大小，只能是2的倍数，一般给个4096就行了。 callback：回调函数，当音频设备没有音频播放的时候就会调用这个函数。我们可以在这个函数里面给他音频数据 userdata：用户自定义数据。 在回调函数中写入音频数据 接下来我们要配置回调函数，让其在音频空闲的时候写入数据。为此，我们需要一个结构体来封装我们需要的音频数据信息：\n1 2 3 4 5 struct Sound { Uint8* data; // 音频的数据 Uint32 len; // 数据的大小 Uint32 curPos; // 当前播放到的位置 }; 然后配置AudioSpec的userdata:\n1 2 3 4 Sound sound; sound.data = soundData; sound.len = soundLen; sound.curPos = 0; 然后编写回调函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 这里的stream就是音频设备的缓冲区了，要往里面写入音频数据。len是这个缓冲区的大小 void AudioCallback(void* userdata, Uint8* stream, int len) { Sound* sound = (Sound*)userdata; // 得到我们的Sound结构体 if (sound-\u003edata \u0026\u0026 sound-\u003ecurPos \u003c sound-\u003elen) { // 当我们的音频数据存在，且没有播放完这个音频时进行播放 SDL_memset(stream, 0, len); // SDL要求首先设置为0 int64_t remaning = sound-\u003elen - sound-\u003ecurPos; // 算一下剩下的音频长度 if (remaning \u003e len) { // 使用SDL_MixAudio对音频进行混合。这里因为我们只有一个音频，最后的参数就给SDL_MIX_MAXVOLUME来让此音频以最大声音播放。 // 如果你有多个音频，需要对这个参数进行调整来确定不同音频的播放声音(0~128) SDL_MixAudio(stream, sound-\u003edata + sound-\u003ecurPos, len, SDL_MIX_MAXVOLUME); sound-\u003ecurPos += len; } else { SDL_MixAudio(stream, sound-\u003edata + sound-\u003ecurPos, remaning, SDL_MIX_MAXVOLUME); sound-\u003ecurPos += remaning; } } } 这里我是让音频只播放一遍。你也可以选择让他循环播放。\n最后，我们要让音频设备开始工作：\n1 SDL_PauseAudio(0); 这个函数参数如果是1则是暂停音频设备。\n至此，所有的工作就完成了。然后你可以选择Delay个1.5秒来听听播放的声音。\n整个代码实例在这里\n音频格式的转换 当你打开的音频设备的格式和你的音频文件格式不一样的时候，你需要进行音频格式的转换。\nSDL2新推出了SDL_AudioStream，而老的SDL_AudioCVT不再推荐使用。\n这里有SDL的官方教程\n这里就简单说一下吧。首先创建一个AudioStream：\n1 2 3 4 5 6 7 8 9 10 SDL_AudioStream* stream = SDL_NewAudioStream(soundSpec.format, soundSpec.channels, soundSpec.freq, audioSpec.format, audioSpec.channels, audioSpec.freq); if (!stream) { SDL_Log(\"create audio stream failed: %s\", SDL_GetError()); } 前三个参数是关于音频的各种格式，后三个是音频设备的各种格式。\n然后我们要把音频数据送给stream进行转换：\n1 2 3 if (SDL_AudioStreamPut(stream, soundData, soundLen) \u003c 0) { SDL_Log(\"resample sound failed: %s\", SDL_GetError()); } 然后得到转换后的数据大小(字节为单位)：\n1 int avali = SDL_AudioStreamAvailable(stream); 然后我们拿出数据：\n1 2 3 4 5 Uint8* cvtData = new Uint8[avali]; if (SDL_AudioStreamGet(stream, cvtData, avali) \u003c 0) { SDL_Log(\"get converted audio failed: %s\", SDL_GetError()); } 这样数据就拿出来了。如果你分多次放入数据，你必须多次拿出数据，因为每次使用SDL_AudioStreamPut时SDL会将你的数据大小记下来，等到拿出来时也只是给你这一块数据的转换结果。\n录制声音 原理和播放声音一样：打开录音设备，然后从设备中读取音频信息即可。\n打开录音设备要使用SDL_OpenAudioDevice()。\n这里给个录音的回调函数作为例子：\n1 2 3 4 5 6 7 8 9 10 11 12 struct Record { Uint8 buffer[1024 * 1024]; Uint32 len; }; void RecordCallback(void* userdata, Uint8* stream, int len) { Record* record = (Record*)userdata; memset(record-\u003ebuffer, 0, sizeof(record-\u003ebuffer)); memcpy(record-\u003ebuffer, stream, len); record-\u003elen = len; } 然后你就可以对这个音频数据为所欲为了，比如传给播放设备播放出来，或者保存到本地等。\n","description":"","tags":["SDL2"],"title":"SDL播放/录制声音","uri":"/posts/sdl%E6%92%AD%E6%94%BE%E5%A3%B0%E9%9F%B3/"},{"categories":null,"content":"这里说一下如何将SDL编译为App。参考文档是SDL源码下的docs/README-android.md。\n前期准备 需要准备：\nandroid sdk工具和ndk工具 JDK8（更高的应该也可以） SDL2的源代码（这里使用的是SDL2_2.0.14版本） make，CMake（如果你用的Android Studio或者Gradle就不需要CMake和make） Gradle（最新版本就行，我这里是7.2） Android SDK和NDK工具的配置 不会的看这里。\n最近MacOS上好像不能用sdk-manager了，直接下载SDK和NDK解压，然后设置环境变量就行了。\n要求 SDK \u003e= 26, NDK \u003e= r15c\n要设置如下四个环境变量：\n1 2 3 4 5 6 \u003e echo $ANDROID_NDK_HOME $ANDROID_NDK_ROOT $ANDROID_SDK_ROOT $ANDROID_HOME /Users/visualgmq/Library/Android/sdk/ndk/21.0.6113669/ /Users/visualgmq/Library/Android/sdk/ndk/ /Users/visualgmq/Library/Android/sdk/ /Users/visualgmq/Library/Android/sdk/ 再给出目录结构，按照这个配就行了，用sdk-manager安装更方便：\n1 2 3 4 5 6 7 8 9 10 11 sdk | |-- android-ndk-r20b |-- ndk | |-- 21.0.6113669 |-- platform-tools |-- build-tools | |-- 27.0.3 |-- tools | ... 配置安卓工程 使用SDL自己的脚本自动生成 进入SDL源码下的build-scripts/，里面有个androidbuild.sh。执行这个文件就可以帮你自动生成工程了。\n这个文件有两个执行方法：\n1 2 androidbuild.sh com.yourcompany.yourapp \u003c sources.list androidbuild.sh com.yourcompany.yourapp source1.c source2.c ...sourceN.c 第一个参数是你的包签名。后面的参数是你的源文件（你也可以将文件名称写在sources.list中然后用第一条命令给他）。\n源文件我建议将头文件和源文件都给他，不然它会找不到头文件。\n执行结果：\n1 2 3 4 \u003e ./androidbuild.sh com.visualgmq.test ../mysrc/main.c To build and install to a device for testing, run the following: cd /Users/visualgmq/Documents/program/playground/SDL2-2.0.14/build/com.visualgmq.test ./gradlew installDebug 它会给你提示，说在../build/下面已经生成了com.visualgmq.test工程了，进去后./gradlw installDebug就可以了。\n这里的gradlw命令会编译之后直接真机运行，如果你只是想编译打包成APK，那么请使用gradlw build。\n手动配置工程 自动生成的方法只有拥有Bash环境才能执行，Windows下不行。而且我们也需要搞清楚到底发生了什么，以便于更好地自定义工程。\n首先将SDL源码根目录下的android-project目录拷贝出来，这个就是你的Android工程目录（可以随意改名）。 然后将SDL源码link到Android工程目录下的app/jni目录下，或者直接将SDL源码下的include,src,Android.mk文件拷贝到app/jni/SDL目录下。 这是基本配置，然后你要根据使不使用CMake来进行配置:\n不使用CMake的工程 打开app/jni/src/Android.mk\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := main SDL_PATH := ../SDL LOCAL_C_INCLUDES := $(LOCAL_PATH)/$(SDL_PATH)/include # Add your application source files here... LOCAL_SRC_FILES := YourSourceHere.c LOCAL_SHARED_LIBRARIES := SDL2 LOCAL_LDLIBS := -lGLESv1_CM -lGLESv2 -llog include $(BUILD_SHARED_LIBRARY) 将SDL_PATH := ../SDL修正为你刚刚link的SDL源码目录。\n增加你的源文件和头文件：Android.mk中的LOCAL_SRC_FILES变量就是你的源文件名称。这里改成你自己的源文件。头文件的搜索目录要加到LOCAL_C_INCLUDES中。\n注意源文件要放在app/jni/src目录下。\n使用CMake的工程 打开app/build.gradle，将里面的ndkBuild部分注掉(2024行，4345行)，然后将cmake部分解注(2530行，4648行)。 编辑app/jni/CMakeLists.txt来适配你的工程。这里有一些注意点： 注意11行add_subdirectory(SDL)指定了你刚刚link或copy过来的SDL源码目录，要改成一样的名字。 你真正的工程CMakeLists在app/jni/src下。 编译工程，生成APK，真机调试 如果你使用Android Studio，那你直接用AS打开工程就可以了。\n如果你用的gradle，那：\n1 2 3 4 gradlw build # 编译工程并生成APK gradlw clean # 清理工程 gradlw installDebug # 编译生成APK，然后将Debug APK真机调试 gradlw installRelease # 编译生成APK，然后将Release APK真机调试 其他对工程的DIY 自定义App名称和包名 将app/src/main/AndroidManifest.xml中的package=\"org.libsdl.app\"一行设置为你自己的包名。\n然后在app/src下创建一个和包名一样的路径以及一个java文件（例如com/gamemaker/game/MyGame.java)\n在MyGame.java中增加如下内容：\n1 2 3 4 5 6 7 8 9 package com.gamemaker.game; import org.libsdl.app.SDLActivity; /** * A sample wrapper class that just calls SDLActivity */ public class MyGame extends SDLActivity { } 改AndroidManifest.xml中的\u003cactivity android:name=\"SDLActivity\"中的SDLActivity改为你的类名（这里是MyGame）。\n更改App的图标 替换app/src/main/res下所有文件夹中的ic_launcher.png就可以了。\n使用STL 如果你要使用C++ STL，在app/jni/Application.mk中解注APP_STL := c++_shared一行。\n编码的注意事项 资源加载 在app/src/main/assets文件夹下的东西会被视为资源一并打包到APK中。可以使用SDL_rwops.h中声明的函数来读取。\n暂停App 如果你设置了SDL_HINT_ANDROID_BLOCK_ON_PAUSEHint，这样当App暂停时事件循环也会自动暂停。\n当App继续执行时，SDL将尝试自动恢复GL上下文。 在现代设备(Android 3.0及以上)中，这将最有可能获得成功。但是在一些老设备上会失败。\n窗口的创建和大小 创建窗口的正确姿势：\n1 2 3 4 5 SDL_CreateWindowAndRenderer(0, 0, 0, \u0026window, \u0026render); // 或者 SDL_CreateWindow(\"\", 0, 0, 0, 0, SDL_WINDOW_SHOWN); 总之你不应该给窗口标题和大小。窗口的大小是由你的设备屏幕决定的，你应当在窗口创建成功后使用SDL_GetWindowSize()来获得大小。\n退出程序的正确姿势 在main函数中返回。 可能有什么操作导致你的程序要关闭，这个时候会发送一个SDL_QUIT事件给你。 注：不要使用exit()函数退出！这不是合法的退出方法。\n设置横屏 App默认是竖屏显示，使用SDL_SetHint(SDL_HINT_ORIENTATIONS, \"LandscapeLeft LandscapeRight\")即可横屏显示。\n加载第三方库 这里只说明如何通过CMake加载。\n打开app/jni/CMakeLists.txt，可以发现他已经给我们写好了：\n1 2 3 4 # Compilation of companion libraries # add_subdirectory(SDL_image) # add_subdirectory(SDL_mixer) # add_subdirectory(SDL_ttf) 意思就是说你要用什么库，就将这些库的源代码放在app/jni下，然后对相应的行解注（放置方法就和SDL一样，你也可以link过来）。\n需要注意的是，第三方库的代码请从github上的sdl-org用户下进行下载，那个是SDL最新的代码。在liblsdl.org/projects/下下载的代码中有些不包含CMakeLists.txt。\n","description":"","tags":["SDL2"],"title":"在Android中嵌入SDL2","uri":"/posts/%E5%9C%A8android%E4%B8%AD%E5%B5%8C%E5%85%A5sdl2/"},{"categories":null,"content":"本文简述了shared_ptr aliasing constructor。\n这是shared_ptr的一种独特的用法，主要是这个构造函数：\n1 2 template\u003c class Y \u003e shared_ptr( const shared_ptr\u003cY\u003e\u0026 r, element_type* ptr ) noexcept; 这里第一个参数是个shared_ptr，第二个参数是个raw pointer。\n官方最这个用法的解释是：\nAdditionally, shared_ptr objects can share ownership over a pointer while at the same time pointing to another object. This ability is known as aliasing (see constructors), and is commonly used to point to member objects while owning the object they belong to. Because of this, a shared_ptr may relate to two pointers:\nA stored pointer, which is the pointer it is said to point to, and the one it dereferences with operator. An owned pointer (possibly shared), which is the pointer the ownership group is in charge of deleting at some point, and for which it counts as a use.\nGenerally, the stored pointer and the owned pointer refer to the same object, but alias shared_ptr objects (those constructed with the alias constructor and their copies) may refer to different objects. 翻译过来就是：\n另外，shared_ptr对象可以共享指针的所有权，同时指向另一个对象。这种能力被称为别名(参见构造函数)，通常用于在拥有成员对象时指向它们所属的对象。因此，shared_ptr可能与两个指针相关:\n一个存储的指针，也就是它要指向的指针，它使用操作符*进行解引用。 拥有的指针(可能是共享的)，它是所有权组在某些时候负责删除的指针，并将其视为使用。 通常，存储的指针和拥有的指针引用相同的对象，但别名shared_ptr对象(使用别名构造函数及其副本构造的对象)可能引用不同的对象。 这里的意思是，新的shared_ptr指向r，负责r指向对象的内存管理。但是他不会管理ptr，但他使用的时候却被暴露成ptr。\n给个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 struct Value { int value = 0; }; int main(int argc, char** argv) { auto valuePtr = std::make_shared\u003cValue\u003e(); std::shared_ptr\u003cint\u003e valueAliasing(valuePtr, \u0026valuePtr-\u003evalue); std::cout \u003c\u003c valuePtr.use_count() \u003c\u003c std::endl; std::cout \u003c\u003c valueAliasing.use_count() \u003c\u003c std::endl; auto anotherPtr = valuePtr; std::cout \u003c\u003c valuePtr.use_count() \u003c\u003c std::endl; std::cout \u003c\u003c valueAliasing.use_count() \u003c\u003c std::endl; valuePtr-\u003evalue = 12; std::cout \u003c\u003c *valueAliasing \u003c\u003c std::endl; valueAliasing.reset(); std::cout \u003c\u003c valuePtr.use_count() \u003c\u003c std::endl; std::cout \u003c\u003c valueAliasing.use_count() \u003c\u003c std::endl; return 0; } // 结果 2 2 3 3 12 2 0 这说明valueAliasing是管理valuePtr的，并且同时也会增加减少valuePtr的ref-counnt。valueAliasing是管不着value的，value是由valuePtr管理的。但是valueAliasing本身又是被视为value 。\n其实就是变项延长value的生命周期。\n","description":"","tags":["cpp"],"title":"shared_ptr aliasing constructor","uri":"/posts/shared-ptr-aliasing-constructor/"},{"categories":null,"content":"本文翻译了部分的Pimple Idiom文章，其讲述了C++中Pimpl的用法。\nPimpl Idiom（Pimpl习语），也被称为compilation firewall（编译防火墙）和Cheshire Cat technique（切西尔猫技术），是一个“私有实现”的技术，仅用于C++和静态编译类型语言。\n优点：\n当改变类的私有成员时不需要重新编译依赖这个类的文件。这会使编译速度提高，并且可以缓和脆弱二进制接口问题。 头文件中不需要#include任何在类私有成员中使用的类，所以可以增加编译速度 这有点像SmallTalk自动处理类的方式...更纯粹的封装 缺点：\n开发者要为此做更多的工作 对protected和public这种子类可以接触到的成员不管用 可能会使代码更难阅读，因为有一些信息会不在头文件中 由于要使用指针间接指向类的实例，所以运行时性能略有降低，特别是调用虚函数的时候(CPU的分支预测可能无法起到作用)。 如何做：\n将所有的private成员放到一个结构体中 将这个结构体的定义放在.cpp文件中 在头文件中，给出这个结构体的前置声明 类的构造函数需要创建这个结构体的实例，并且在析构函数中析构他（如果你没有使用智能指针的话） operator=和拷贝构造函数要能够正确地拷贝这个结构体，或者直接禁用这些函数 接下来是译者举的例子（原文中莫得例子）\n首先来看一个类一般的实现方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Person.hpp class Person { public: Person(const std::string\u0026 name, int age, float height); ~Person() = default; inline const std::string\u0026 GetName() const { return name_; } inline int GetAge() const { return age_; } inline float GetHeight() const { return height_; } private: std::string name_; int age_; float height_; }; 如果我们想要给Person增加一个school成员，这样就会修改Person类，也就是修改了Person.hpp文件，这样所有包含了Person.hpp文件的文件就需要重新编译。\n但是使用Pimpl技术可以避免重新编译：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // Person.hpp struct Data; // 私有成员结构体的前置声明 class Person { public: Person(const std::string\u0026 name, const std::string\u0026 school, int age, float height); ~Person() = default; const std::string\u0026 GetName() const; const std::string\u0026 GetSchool() const; int GetAge() const; float GetHeight() const; private: std::unique_ptr\u003cData\u003e pimpl_; // 使用指针指向私有成员的结构体 }; // Person.cpp // 定义私有成员结构体 struct Data { std::string name; int age; float height; std::string school; }; // 实现Person的成员函数 Person::Person(const std::string\u0026 name, const std::string\u0026 school, int age, float height) { // 首先给pimpl_分配内存 pimpl_ = std::make_unique\u003cData\u003e(); pimpl_-\u003ename = name; pimpl_-\u003eschool = school; pimpl_-\u003eage = age; pimpl_-\u003eheight = height; } const std::string\u0026 Person::GetName() const { return pimpl_-\u003ename; } // 其他的Getter和Setter函数一样实现，就不在此赘述了 这样由于你每次修改Person的private成员的时候，其实都是修改Data成员，而Data成员是在.cpp文件中的，其他包含了Person.hpp的文件无法看到，所以不会重新编译。\n下面节选了一些网友的评论：\n来自JohnCarter的评论：\n有一个更好的理由去使用这项技术：在创建单元测试的时候。假设你有一个包含了很大成员的对象：\n1 2 3 4 5 class A { private: BigScaryMonster orc; BiggerScarierMonster troll; }; 如果你包含了A.h，你需要编译和连接这大的吓人的东西，尽管他们是私有的的。这会导致你链接BigScaryMonster.o和BinggerScarierMonster.o以及这个文件。\n你可以创造一个不含这两个成员的MockA来代替A进行测试。然而，如果你在单元测试中不小心包含了其他的包含了BigScaryMonster.h和BiggerScarierMonst.h的头文件时，他仍会拖慢你的编译速度。而你的单元测试其实只需要看到MockA就够了。\n这个时候就可以用Pimpl:\n1 2 3 4 5 6 7 struct AImp; class A { public: // Same public interface as A, but all delegated to concrete implementation. private: AImp * pimpl; }; 这样就可以避免上述问题带来的编译时长。\n来自FernandoRamos的评论：\n还有一件事使它成为一个非常有用的习惯用法，那就是它为您提供了一种从第三方库继承功能而不向类用户传递任何对该库的依赖关系的方法。只需让您的XImpl类继承第三方库类。因为依赖项仅在.cpp文件中，而不是头文件中。\n","description":"","tags":["cpp"],"title":"Pimpl Idiom(译)","uri":"/posts/pimpl-idiom-%E8%AF%91/"},{"categories":null,"content":" 这几天做游戏的时候要用到GUI。但是SDL2本身是没有GUI组件，所以得自己做一个。\n上面的视频就是目前完成的东西，有窗口，滚动条，按钮，Label和输入框。因为在输入框这里卡了很久，所以打算写一篇博客记录一下如何实现。\n封装UTF8 String 首先要注意的是，SDL2中用户输入的字符是UTF8类型，所以我们需要首先封装一份针对UTF8编码的string。\n关于UTF8编码的说明可以参考这篇文章，这里直接把实现的代码给出来了encoding.hpp,encoding.cpp。\n简单介绍一下utf8string，它的接口仿照std::string，可以将std::string，char*中的每个UTF8编码抽取出来独立存储。这样utf8string的基本字符就是UTF8字符，方便我们对每一个UTF8字符进行操作。\n为什么不使用Unicode Unicode以16位为一个字符，会涉及到大小端问题（高8位和低8位的顺序）。而UTF8则和大小端无关，转换起来较为方便。\n为什么不使用wstring wstring中的wchar_t的位数最低是16位，具体由编译器决定，这意味着没有办法保证wchar_t能够装下最长能到达4Byte的UTF-8编码。而且如果你用\n1 std::wstring s = L\"中文\"; 这里的s内装载的是Unicode字符，而不是UTF8。\n当然你可以不使用UTF8编码而使用Unicode，这样你就不需要封装一个utf8string而是使用wstring。至于将UTF8转换成Unicode，你可以借助libiconv库转换。\n我这里因为已经实现了utf8string了，所以我就用UTF8编码了。\n实现InputBox 注：以下所有代码都是将我工程中的代码进行简化的结果（去除了不相干的类和函数），所以可能无法直接运行，这里主要是要有代码才好说明。\n首先来看看InputBox类的声明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class InputBox { public: InputBox(int id, int lenPixel); ~InputBox(); void EventHandle(const SDL_Event\u0026); void Render() override; private: utf8string text_; // encoding.hpp 中的对UTF8操作的string SDL_Texture* textTexture_ = nullptr; SDL_Rect rect_; // InputBox所在的矩形 /* Black和White是预先定义的`constexpr SDL_Color`， 分别是黑色(0, 0, 0, 255)，和白色(255, 255, 255, 255) */ SDL_Color borderColor_ = Black; SDL_Color bgColor_ = White; SDL_Color textColor_ = Black; int cursor_ = 0; // 当前光标在哪个字符上 int lineX_ = 0; // 当前光标应该绘制的x坐标（相对于InputBox） // 这三个函数后面会解释 void tryGenTextures(); void resetTextTexture(); int getUTF8FontWidth(TTF_Font* font, const utf8string::OneUTF8\u0026 c); }; 整个的难点和解决方法在于：\nSDL2是如何接收输入的。这一部分很多人搞不清，官方的API文档也没怎么说。 解决方法：这里附上官方教程，后面也会提到。 SDL2接收输入的是UTF8编码，存在char*中，这样当我们按下退格键或左右移动光标时，必须得判断当前光标所在的文字所占char的个数。 解决方法：使用utf8string 判断当前是否在使用输入法条。如果在使用输入法条，那么退格键和左右键将不能删除输入框中的字符和移动光标。 输入法框的位置问题。如不调用SDL_SetTextInputRect()函数，输入法的提示框会在屏幕左上角。 解决方法：调用SDL_SetTextInputRect() SDL2的输入问题 想要开启SDL的文字输入，必须调用SDL_StartTextInput()函数。并且需要配合SDL_StopTextInput()进行关闭。\n开启输入后，每次你输入时，SDL根据情况都会发送两个事件：\nSDL_TEXTINPUT:成功输入文字，比如输入法在英文模式下输入英文，或者在中文模式下按下空格确认文字时。简单来说，就是当你的输入法条出现时，不会发送这个事件。只有当你在输入法条中完成了每个词的拼写，按下空格/回车时（输入法条会消失）才会触发这个事件 SDL_TEXTEDITING:编辑文字时。在输入法条中选词/编辑词时。这个时候每按下按键都会触发这个事件。 SDL_TEXTINPUT事件发生时：\nevent.text.text中将会记录下输入的字符串(UTF8编码)。 SDL_TEXTEDITING事件发生时：\nevent.edit.text中会记录你现在正在编辑的字符串 event.edit.start中会记录你输入法条的中的光标在第几个字符处。 这里我不打算绘制正在编辑的字符串，那样会将事情搞得更复杂（你可以自己尝试，不难，就是有点烦）。而且输入法条中本身就会显示正在编辑的字符串：\n基于此，就可以实现一部分EventHandle()函数了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void InputBox::EventHandle(const SDL_Event\u0026 e) { // 当鼠标在InputBox内并且按下了按键，我们就打开输入，否则关闭 if (e.type == SDL_MOUSEBUTTONDOWN) { SDL_Point mousePoint = {e.motion.x, e.motion.y}; if (SDL_PointInRect(\u0026rect_, \u0026mousePoint)) { SDL_StartTextInput(); } else { SDL_StopTextInput(); } } if (e.type == SDL_TEXTINPUT) { text_ += e.text.text; // 得益于utf8string，它会自动将std::string的UTF8转换。 } } 记录光标所在字符序号 当用户按下左右键时，可以移动光标。\n光标所在的字符用cursor_变量表示。cursor_ = 0表示没有字符，cursor_ = 1表示输入框内的第一个字符。\n输入字符的实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 void InputBox::EventHandle(const SDL_Event\u0026 e) { ... if (e.type == SDL_TEXTINPUT) { char* inputText = e.text.text; text_ += inputText; // 得益于utf8string，它会自动将std::string的UTF8转换。 // 在cursor_处插入字符 utf8string str(inputText); text_.insert(text_.begin() + cursor_, str); cursor_ += str.size(); } } 判断当前是否在使用输入法条 接下来需要实现按下左右键进行移动光标。但是这里有个问题。如果现在用户在编辑输入法条中的问题，按下左右键其实是移动了输入法条中的光标，输入框本身的光标不应该移动。\n这就导致我们必须判断用户现在是否在使用输入法框。\n方法是使用isEditing的全局变量记录是否在使用输入法框，具体的代码如下：\n1 2 3 4 5 6 7 8 9 10 if (e.type == SDL_TEXTEDITING) { if (strlen(e.edit.text) == 0) { context.isEditing = false; } else { context.isEditing = true; } } if (e.type == SDL_TEXTINPUT) { context.isEditing = false; } 当接收到SDL_TEXTEDITING时用户是在使用输入法条。接收到SDL_TEXTINPUT就是不在使用输入法条。但是注意当你将输入法条内的所有字符删掉之后，他仍然会给你发一个SDL_TEXTEDITING，这个时候其text的长度为0，所以还要对这一点进行判断。\n进行光标的移动和退格键删除字符 这一点就比较容易了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void InputBox::EventHandle(const SDL_Event\u0026 e) { ... if (type == KEYDOWN) { const auto\u0026 key = e.key.keysym.sym; if (key == SDLK_BACKSPACE \u0026\u0026 !isEditing) { // 按下退格删除字符 if (cursor_ != 0) { text_.erase(text_.begin() + (-- cursor_)); } } if (!isEditing) { if (key == SDLK_LEFT) { // 按下左键左移光标 if (cursor_ \u003e 0) { cursor_ --; } } if (key == SDLK_RIGHT) { // 按下右键右移光标 if (cursor_ \u003c text_.size()) { cursor_ ++; } } } } } 绘制光标的注意事项 需要注意的是，如果你绘制文字的字体不是等宽字体的话，中文和英文的宽度是不一样的，这意味着不能简单地通过如下代码得到光标的位置：\n1 int cursorLineX = rect.x + cursor_ * FONT_PT; 一般而言，中文的宽度是英文的两倍。但是这里我提出一种通用的解决方法，就是使用lineX_变量记录当光标的X坐标，每次移动光标，删除/增加字符的时候都判断一下修改的字符所占的Pixel，然后修改lineX_。\n这里可以通过TTF_SizeUTF8()来判断字符串生成图像的大小，而不需要真正的生成图像。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 void InputBox::EventHandle(const SDL_Event\u0026 e) { ... if (e.type == SDL_TEXTINPUT) { char* inputText = e.text.text; // 得到字符的宽度 int w; TTF_SizeUTF8(font, inputText, \u0026w, nullptr); lineX_ += w; text_ += inputText; // 得益于utf8string，它会自动将std::string的UTF8转换。 // 在cursor_处插入字符 utf8string str(inputText); text_.insert(text_.begin() + cursor_, str); cursor_ += str.size(); } if (type == KEYDOWN) { const auto\u0026 key = e.key.keysym.sym; if (key == SDLK_BACKSPACE \u0026\u0026 !isEditing) { // 按下退格删除字符 if (cursor_ != 0) { // 减去删除字符的长度 lineX_ -= getUTF8FontWidth(GuiContext.font, text_[-- cursor_]); text_.erase(text_.begin() + cursor_); } } if (!isEditing) { if (key == SDLK_LEFT) { // 按下左键左移光标 if (cursor_ \u003e 0) { // 减去左边字符的长度 lineX_ -= getUTF8FontWidth(GuiContext.font, text_[-- cursor_]); } } if (key == SDLK_RIGHT) { // 按下右键右移光标 if (cursor_ \u003c text_.size()) { // 增加右边字符的长度 lineX_ += getUTF8FontWidth(GuiContext.font, text_[cursor_ ++]); } } } } } 而这里的getUTF8FontWidth()的实现如下：\n1 2 3 4 5 6 7 // OneUTF8是std::array\u003cchar, 4\u003e，是utf8string的基本单位。 int InputBox::getUTF8FontWidth(TTF_Font* font, const utf8string::OneUTF8\u0026 c) { auto str = UTF8ToString(c); // 将UTF8转化为std::string，在`encoding.hpp`中有声明 int w; TTF_SizeUTF8(font, str.c_str(), \u0026w, nullptr); // 得到宽度 return w; } 让输入法条在输入框的下方 如果不使用SDL_SetTextInputRect()函数，输入法条将会出现在左上方。这里只要将输入框的rect_传给他就行了。\n","description":"","tags":["SDL2"],"title":"在SDL中实现一个输入框","uri":"/posts/%E5%9C%A8sdl%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BE%93%E5%85%A5%E6%A1%86/"},{"categories":null,"content":"今天看《C++ Templates》中遇到的，一开始没看懂，就探究一下。\n参考cppreference pointer\n指向非静态的成员变量的指针 C++中有专门对指向非静态成员变量指针的类型定义：S C::*，其中S是成员变量的类型，C是类名称。\n比如如下代码：\n1 2 3 4 5 6 7 struct Node { int value; Node* left; Node* right; Node(int value): value(value), left(nullptr), right(nullptr) {} }; 那么int Node::*就是可以指向value的指针，而Node* Node::*就是可以指向left和right的指针。\n有了指针，我们可以通过成员指针访问运算符 .*和-\u003e*来访问：\n1 2 3 4 5 6 7 8 9 int Node::* value = \u0026Node::value; Node* Node::* left = \u0026Node::left; Node* Node::* right = \u0026Node::right; Node* root = new Node(1); root-\u003eleft = new Node(2); root-\u003eright = new Node(3); cout \u003c\u003c root-\u003e*left-\u003e*value \u003c\u003c endl; // 输出root的左节点的值，是2 这也能在继承中生效，指向父类的成员指针，如果用子类去调用，会隐式转换到子类指针：\n1 2 3 4 5 6 7 8 class Parent { int value; }; class Child: public Parent {}; int Parent::* valuePtr = \u0026Parent::value; Child child; child.value = 1; cout \u003c\u003c child.*valuePtr \u003c\u003c endl; // 输出1 从子类到父类的转换可以通过static_cast或者显示转换，转换总能成功。如果父类不存在对应的成员，调用时会产生未定义行为。\n最玄幻的是，你还能自己包含指向自己类成员的指针：\n1 2 3 4 5 6 7 struct A { int m; int A::* p; }; // 这样声明p的指针: int A::* A::* ptr = \u0026A::p; // 即(int A::*) A::* ptr 需要注意的是，\u0026(S::C*)这种格式不是上述这种指针\n指向静态成员的指针 就和普通的指针一样，无论是指向成员变量还是函数：\n1 2 3 4 5 6 7 8 struct A { static int value; static void Func(); }; int* p = \u0026A::value; using F = void(*)(void) F p = \u0026A::Func; 指向成员函数的指针 格式上和指向成员的变量一样：\nstruct A { void Func(); }; using F = void(A::*)(void); F f = \u0026A::Func; 用法也是用.*或-\u003e*:\n1 2 A a; (a.*f)(); // 调用 ","description":"","tags":["cpp"],"title":"C++指向成员的指针","uri":"/posts/c++%E6%8C%87%E5%90%91%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88/"},{"categories":null,"content":"这里说明了Nim如何使用OpenGL\nNimble换源 因为我们要下载SDL2和OpenGL的支持，所以可以考虑将Nimble换成国内源。方法如下：\n首先到Nimble官网clone他的代码下来。\n然后进入到src/nimblepkg/download.nim文件中，将\n1 2 if modUrl.contains(\"github.com\") and modUrl.endswith(\"/\"): modUrl = modUrl[0 .. ^2] 换成\n1 2 3 4 if modUrl.contains(\"github.com\"): modUrl = modUrl.replace(\"github.com\",\"github.com.cnpmjs.org\") if modUrl.endswith(\"/\"): modUrl = modUrl[0 .. ^2] 其实就是将github换成国内的镜像网站github.com.cnpmjs.org，顺便说一句，平时github登不上去了也可以上这个网站访问。\n然后重新编译nimble，到nimble的根目录下执行\n1 nimble build 就会生成nimble可执行文件了。然后将文件放到/usr/local/bin/下就可以执行了。\n我的习惯是重命名为nimble-zh然后再放。\n以后每次下载包使用这个nimble就会很快了。\n使用OpenGL 我是使用SDL2搭建窗口，你也可以使用你熟悉的库。\n首先安装SDL2和OpenGL的包，OpenGL包的官网在这里\n1 nimble install sdl2 opengl 然后OpenGL的API是什么，在Nim中就怎么用就行了，这里给个清屏的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import sdl2 import opengl if isMainModule: sdl2.init(INIT_EVERYTHING) defer: sdl2.quit() # 设置OpenGL版本 discard glSetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3) discard glSetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3) discard glSetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE) let window = sdl2.createWindow(\"test SDL2\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 400, 300, SDL_WINDOW_SHOWN or SDL_WINDOW_OPENGL) defer: sdl2.destroyWindow(window) var glContext = glCreateContext(window) defer: glDeleteContext(glContext) # 根据OpenGL包的文档，这一句必须加在创建窗口后，加载拓展前 loadExtensions() if glContext.isNil: raise newException(Exception, \"gl context create failed\") var shouldClose = false var event = sdl2.defaultEvent; while not shouldClose: while sdl2.pollEvent(event): case event.kind: of sdl2.QuitEvent: shouldClose = true else: discard # 清屏 glClearColor(0.1, 0.1, 0.1, 1) glClear(GL_COLOR_BUFFER_BIT) # 绘制屏幕 glSwapWindow window delay 30 参考教程 SCIFX\n","description":"","tags":["OpenGL"],"title":"Nim使用OpenGL","uri":"/posts/nim%E4%BD%BF%E7%94%A8opengl/"},{"categories":null,"content":"这里介绍了传统Roguelike游戏开发中的几种处理时间消耗的算法。\n参考网站是RogueBasin\n时间消耗系统和算法 像Roguelike这种回合制游戏，生物每次行动都需要消耗一定量的时间，这样就必须有一个通过消耗时间确定生物行动顺序的系统。\n简单的时间管理系统(elegant time management system) 这个系统很简单，需要一个循环链表：\n1 2 3 4 5 6 7 8 9 struct Entity { int Update() { /*.. your update ..*/ } // 返回物体行动消耗的时间 int speed; int action_points; }; struct ETMSystem { std::list\u003cEntity*\u003e entities; // 含有物体链表 }; 因为是循环链表，我们得定义一个头节点，这里默认就在下标0处吧。\n然后这个算法的核心就是：每次看头结点的物体action_points是否大于0，如果大于0，就执行其Update()函数进行更新，并且将action_points减去消耗的时间。如果没有，就加上物体的speed，然后继续看下一个物体。 整个流程的代码大致如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct ETMSystem { std::list\u003cEntity*\u003e entities; // 含有物体链表 void RegistEntity(Entity* entity) { entities.push_front(entity); // 新增加的放在头部 } void Tick() { // 这个函数在游戏主循环中被调用，每帧调用过一次 if (!entities.empty()) { auto\u0026 entity = entities.front(); std::rotate(entities.begin(), ++entities.begin(), entities.end()); // 这里为了方便用rotate将所有元素循环左移了一位 entity-\u003eaction_points += entity-\u003espeed; if (entity-\u003eaction_points \u003e 0) { entity-\u003eaction_points -= entity-\u003eUpdate(); } } } }; 如果你想要给你的游戏加上动画，这里有一个锁机制可以帮助你：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 struct ETMSystem { void RegistEntity(); void Tick(); void Lock() { lockNum++; } void Unlock() { lockNum--; } int lockNum = 0; }; // 然后在调用Tick的时候判断，如果锁上了就不掉用Tick if (etm.lockNum == 0) { etm.Tick(); } /* 每一次动画开始时都需要Lock，然后动画播放完成就Unlock */ 这种算法适合将Update函数写死在物体内的游戏。\n基于优先队列的回合管理系统(a priority queue based turn scheduling system) 这个很简单，就是将事件推入到优先队列中，然后每次从队列中取出需要耗费时间的最短的事件去处理，并且将余下的所有事件的剩余时间全部减掉。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 struct Event { int costTime; int id; // 为了辨别Event // 定义operator\u003c，优先队列需要 bool operator\u003c(const Event\u0026 e) { return costTime \u003c e.costTime; } }; struct PriorityQueue { std::vector\u003cEvent\u003e events; void Push(const Event\u0026 event) { int i = 0; while (i \u003c events.size() \u0026\u0026 events[i + 1] \u003e event) { i++; } events.insert(event, events.begin() + i); } Event Pop() { Event e = events[0]; events.erase(events.begin()); return e; } void DecCostTime(int time) { for (auto\u0026 e : events) e.coseTime -= time; } }; struct TurnSchedule { PriorityQueue q; Event NextEvent() { Event e = q.Pop(); q.DecCostTime(e.time); return event; } }; 这里STL的优先队列不能满足我们的需求，我就写了个简单的。在每次的游戏循环中，都需要调用NextEvent()函数获得Event并处理。\n这种算法适合基于事件或者命令机制的游戏。\n","description":"","tags":["算法"],"title":"Roguelike里的几种时间系统","uri":"/posts/roguelike%E9%87%8C%E7%9A%84%E5%87%A0%E7%A7%8D%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"这里是我对何时使用智能指针的思考🤔。\n何时使用智能指针 智能指针一共有三个unique_ptr,shared_ptr和weak_ptr。其中weak_ptr是为了弥补shared_ptr所造成的循环指向而诞生的，使用的场景很明确，所以不予讨论。\nunique_ptr的意义是一个人独占的所有权，不可分享的所有权。而与之对立的shared_ptr则是可以共享的所有权。\n但是很多时候所有权这个东西的定义很模糊，比如说给函数式编程中的函数（不改变参数，也没有副作用）传递参数时，比如下面的sum函数：\n1 2 template \u003ctypename T\u003e T Sum(const T\u0026 t1, const T\u0026 t2); 你说我这是将t1,t2的所有权给Sum函数了，这显然说不过去。但是你说我是和Sum函数共享这两个变量，好像也不太对。这里函数对于这两个变量的使用情况应该属于借用，借一下，用完就还给你的这种。\nRust将借用这种语义放在了语言里（通过编译器来进行安全性的保证）。而函数式编程则可以通过返回值返回处理后的结果（某种意义上也是借用，先获得所有权，然后创造个新的同类型东西给你，相当于给你原来的东西进行加工）。但是在OO思想中好像没有什么方法，这个时候使用unique_ptr和shared_ptr就会显得很尴尬，所以我认为在这种所有权模糊不清的情况下应该直接使用裸指针。\n有人说啊这里直接传递智能指针的引用不就行了，那如果是这样的情况呢：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Entity { public: // 这里的T应该是什么类型呢？ T GetAttackComp() const { return attackable_; } T GetDefenceComp() const { return defencable_; } T GetHealComp() const { return healable_; } private: unique_ptr\u003cComponent\u003e attackable_; unique_ptr\u003cComponent\u003e defencable_; unique_ptr\u003cComponent\u003e healable_; }; // 这里的T应该是什么类型呢？ void DoAttack(T attackComp) { // do your attack } 对于ECS系统，Component应当被其Entity所拥有。这个时候我需要获得某个组件，显然我不能够返回unique_ptr\u003cComponent\u003e，这样所有权就不再在Entity身上了。但是返回shared_ptr也是很荒唐的，因为Entity想要独占Component的所有权。\n在调用DoAttack函数时同样是面临着借用的情况。而处理这种借用的情况我总结出了以下解决方法：\n使用裸指针。因为所谓借用，就是借你的东西用一会，这个使用时间很短，使用的时间一定在变量生命周期之内的（即不会出现智能指针已经释放了而借用仍然存在的情况，如果出现这种情况，应当使用shared_ptr，因为shared_ptr就是在不知道多个操作中哪个操作何时结束的情况下用来延后指针释放的时间的）。 对于函数的借用，可以学习函数式编程，参数传递智能指针，返回值返回同样的类型。 ","description":"","tags":["cpp"],"title":"何时使用智能指针","uri":"/posts/%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"categories":null,"content":"本文介绍了如何使用emscripten来将SDL程序编译成网页。\n准备工作 什么是emscripten？ emscripten是一个用于WebAssembly的一套编译工具，基于LLVM。\nWebAssembly(wasm)，即网页汇编，说白了，就是用在Web上的汇编语言。WebAssembly的优点是速度快，他可以将C/C++代码转换成wasm代码，所以能够提升不少效率。\n不过我这里主要是为了将C++代码变成网页啦，不管效率。\n安装emscripten 安装方法见官网\n编写一个Demo wasm的SDL和普通SDL的区别 编写wasm的SDL程序和平时的不太一样，我们需要在程序内部指定我们的游戏主循环，这样Web端才能帮我们更新游戏:\n1 2 3 4 5 6 7 8 // 首先包含emscripten的头文件 #include \"emscripten.h\" // 这是主循环的函数声明 void mainloop(); // 使用这个函数来设置主循环，这个循环是异步的 emscripten_set_main_loop(mainloop, -1, 1); 其中最主要的就是这两个函数：\n1 2 void emscripten_set_main_loop_arg(em_callback_func func, void* arg, int fps, int simulate_infinite_loop); void emscripten_set_main_loop(em_callback_func func, int fps, int simulate_infinite_loop); 看参数名字就知道他们是什么意思了。fps如果是负数，则使用浏览器的requestAnimationFrame机制来更新。simulate_infinite_loop总应当是1，以便于浏览器执行循环。\n如果你要给mainloop传参，就用第一个函数，别忘了改变mainloop的声明：void mainloop(void* args);\n每个程序只能有一个主循环。如果需要用其他的主循环，需要先将前面的关闭。\n有关这个函数的详细说明，请看这里\nDemo Demo的文件在这里\n编译的方式有两种，第一种是用emscripten自带的SDL：\n1 em++ wasm_sdl_demo.cpp -s WASM=1 -s USE_SDL=2 -o index.html 注意输出的是html。USE_SDL=2代表要使用SDL2。\nemscripten会自己去下载对应的SDL，如果你觉得太慢的话也可以将SDL的源码自己clone下来，然后看他docs/README-emscripten.md文件来自己手动编译成wasm所需的SDL。编译的过程还挺快的。\n编译好的网页在这里Demo\n常用的编译选项 再看一个完整的Makefile：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 CXX = em++ SDL_DEP = -s WASM=1 -s USE_SDL=2 SDL_IMAGE_DEP = # -s USE_SDL_IMAGE=2 -s SDL2_IMAGE_FORMATS='[\"png\", \"jpg\", \"bmp\"]' ASSET_PRELOAD = --preload-file assets SRC = $(wildcard ./*.cpp) index.html: $(SRC) $(CXX) $^ ${SDL_DEP} ${SDL_IMAGE_DEP} ${ASSET_PRELOAD} -o $@ -std=c++17 .PHONY:clean run clean: -rm index.html -rm *.wasm -rm *.js -rm *.o run: emrun --port 8080 . 想要使用其他SDL库，请使用-s USE_SDL_XXX=2。这里第三行设置了SDL_image依赖。\n第四行则是预加载资源文件，这里预加载assets资源文件夹。\n运行命令使用emrun --port 8080，它会开启一个本地服务器然后运行你的网页。如果不开启服务器直接运行网页，且你没有预加载资源，那么资源可能无法被读取。\n将网页放到Hexo上 这里有个坑，但不是所有的主题都是这样：在发布页面的时候请静止Hexo渲染含有wasm的页面，不然wasm会失效。\n另一个完整的小游戏 舞狮是一个完整的小游戏，你可以将此作为参考。源码下载\n","description":"","tags":["SDL2"],"title":"将SDL程序变为网页（使用emscripten）","uri":"/posts/%E5%B0%86sdl%E7%A8%8B%E5%BA%8F%E5%8F%98%E4%B8%BA%E7%BD%91%E9%A1%B5%E4%BD%BF%E7%94%A8emscripten/"},{"categories":null,"content":"本文介绍了如何对UTF-8编码的字符串进行Warp。\nText Warp是游戏和GUI开发中不可或缺的一个技术，说白了就是自动换行：给定一个长度，当你渲染的字符串超过这个长度时需要自动从下一行开始渲染。\n对ASCII码组成的字符串进行Warp很简单，但是对于UTF-8的编码就会麻烦一点。\n首先要了解UTF-8编码的编码方式。它是不定长编码，编码方式如下：\n字符所在的十六进制区间 编码方式 0x0000 0000 - 0x0000 007F 0xxx xxxx 0x0000 0080 - 0x0000 07FF 110x xxxx 10xx xxxx 0x0000 0800 - 0x0000 FFFF 1110 xxxx 10xx xxxx 10xx xxxx 0x0001 0000 - 0x0010 FFFF 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx 第一个区间就是普通的ASCII码，因为ASCII码总是小于127，即最高位是空着的，所以就使用最高位是否为1来表示编码是否为UTF-8.\n举个栗子，“中”字的UTF-8码是\n1 E4 B8 AD 转换成二进制就是\n1 1110 0100 1011 1000 1010 1101 这个长度是表格中的第三行（其实只要看最左边4位就可以判断），我们从中将所有的标志位去掉，就是：\n1 2 3 4 1110 0100 1011 1000 1010 1101 去掉标志位： 0100 11 1000 10 1101 = 0100 1110 0010 1101 = 0x8F2B 显然0x8F2B位于区间0x0800 - 0xFFFF中，这就验证成功了。\n有了这些基本知识，我们就可以从一串字符串中得到UTF-8编码了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 这个函数从str的idx位置处解析一个UTF-8字并返回 std::string ParseOneUTF8(const std::string\u0026 str, int idx) { std::string result; if ((str[idx] \u0026 0xF0) == 0xF0) { result.push_back(str[idx++]); result.push_back(str[idx++]); result.push_back(str[idx++]); result.push_back(str[idx++]); } else if ((str[idx] \u0026 0xE0) == 0xE0) { result.push_back(str[idx++]); result.push_back(str[idx++]); result.push_back(str[idx++]); } else if ((str[idx] \u0026 0xC0) == 0xC0) { result.push_back(str[idx++]); result.push_back(str[idx++]); } else { result.push_back(str[idx++]); } return result; } 这样Text Warp也就好做了:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 这里最后的参数是表示一行的最大字符数 std::vector\u003cstd::string\u003e WarpUTF8(const std::string\u0026 str, int maxCharNum) { int size = 0; int idx = 0; std::vector\u003cstd::string\u003e result; std::string line; while (idx \u003c str.length()) { auto utf8Char = ParseOneUTF8(str, idx); line += utf8Char; idx += utf8Char.length(); size++; if (size \u003e= maxCharNum) { result.push_back(line); line.clear(); size = 0; } } if (!line.empty()) result.push_back(line); return result; } Unicode也是一样，只要找到了其编码方式就可以解析。\n关于编码，推荐个B站视频：\n{% bilicard BV1gZ4y1x7p7 %}\n","description":"","tags":["杂项"],"title":"Text Warp (for UTF-8)","uri":"/posts/text-warp-for-utf-8/"},{"categories":null,"content":"Nim的主要口号是：\n高效、优雅、富有表现力\n官网的介绍是：\nNim 是一种静态类型的、编译型、系统编程语言。 它结合了其他成熟语言的成功概念。 （如 Python、Ada 和 Modula）\n特点有如下：\n直观、干净的语法\n多操作系统支持\n可以编译为C,C++,Js，并且可以简便地和C/C++/Obj-C交互\n提供包管理器\nNim确实有着很多的优点，作为一个拿Nim来搞游戏开发的，我认为其最大的优点在于其运行速度和语法的简洁。Nim可以编译成C/C++，这意味着他的效率和C/C++差不多。而Nim本身的语法又有些像Python等脚本语言，写起来无压力，而且其本身还带有一个GC系统，我们不需要关心本身的内存操作。\n上一个没有内存管理的编译型语言还是Rust，不过Rust里面许多东西都和C++差不多，本身学起来的难度也比较大。\nNim的话非常容易学习，我只花了一天的时间就把Nim官方的教程和其推荐的教程都看完了，还顺便看了下Nim+SDL。\n然后我就想着：Nim这么简单，那我不如把我的Grogue游戏换成Nim开发咯。\n然后我就这样开发了四天，最后撑不住了，又换回C++了。\n我体会到的Nim缺点主要如下：\n官方的工具较少：Nim最新推出的补全和查错工具是NimSuggest，并且有vscode的集成插件。但是插件不行，每次保存了才能帮我识别，而且只能识别当前保存的文件。这就是说我改动了文件后没办法知道是否在其他文件中也有错误，只有将其他文件都保存一遍才能显示错误。 Nim本身的知名度很低：Nim比起Rust，Kotlin这种，Nim背后没有金主爸爸支持。Nim的开发是Nim社区的人们自己自愿开发的，背后没有什么公司，不像Rust背后是Mozilla，Kotlin背后是谷歌，所以Nim的知名度很低，这也就导致除了官方文档，我几乎找不到什么其他的资料。出了错误也只能去官方的Manual手册里面一点一点看，而且没有人给Nim做Vim补全插件，搞得我还得去vscode上写码。讲真我感觉要是Nim有个支持的公司什么的，或者加大力度宣传，应该会发展的很好。 语言本身还有些缺点：比如不能够进行类的前置声明，这样遇到类的循环引用就没什么好办法解决。 社区的支持不够：不论是QQ群还是Nim的IRC，我在里面问问题都没人回答，不知道是我问的太垃圾了了还是怎么地，伤心。 就像其官方说的，比起C++，Rust等语言，Nim和开发者们玩的很好。确实，我相信如果你接触到了Nim，一定会喜欢去使用他，通过这几天的使用我也觉得Nim用起来很顺手。但是说实话，Nim的资料实在是太少太少了，我这几天大部分时间都花在看Nim的Manual，和Nim里面的一些语法作斗争去了。如果Nim的资料更多，讨论的人更多的话，我也会一直使用Nim的。\n我以后应该不会用Nim写一些大东西，可能会把Nim当Python一样作为脚本语言来写一些工具什么的。\n","description":"","tags":["Nim"],"title":"Nim语言使用感想","uri":"/posts/nim%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E6%84%9F%E6%83%B3/"},{"categories":null,"content":"这里是本博客安装的一些Hexo插件，主要是记录下来要怎么用和一些坑，防止后面忘了。\nhexo-github 吧github仓库上面某一个提交的时间线拉出来：\n{% github VisualGMQ TinyRenderer3D 00fcea51034d52f2e8ffd7ad63949fba654a2039 %}\nhexo-filter-optimize 可以加快打开博客页面的速度，确实，安了后秒开。就是每次开新页面会闪一下。。。\nhexo-admonition !!! warning 这是警告 这是警告的内容\n用空行结束这个内容 这里是普通文字\nhexo-bilibili-card 增加Bilibili卡片：\n{% bilicard BV1kX4y1K7Sa %}\nhexo-bilibili-bangumi 可以给网站增加一个追番列表。当自己的追番列表变化了之后要用\n1 hexo bangumi -u 进行本地的数据更新\nhexo-filter-flowchart 制作一些流程图:\nst=\u003estart: 开始 inputA=\u003einputoutput: 输入用户名密码 opA=\u003eoperation: 数据库查询子类 conditionA=\u003econdition: 是否有此用户 conditionB=\u003econdition: 密码是否正确 opB=\u003eoperation: 读入用户信息 e=\u003eend: 登录 st-\u003einputA-\u003eopA-\u003econditionA conditionA(yes)-\u003econditionB conditionA(no)-\u003einputA conditionB(yes)-\u003eopB-\u003ee conditionB(no)-\u003einputA hexo-filter-sequence 可以制作一些UML图：\nAlice-\u003eBob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob--\u003eAlice: I am good thanks! ","description":"","tags":null,"title":"安装的一些Hexo插件（用法备忘）","uri":"/posts/%E5%AE%89%E8%A3%85%E7%9A%84%E4%B8%80%E4%BA%9Bhexo%E6%8F%92%E4%BB%B6%E7%94%A8%E6%B3%95%E5%A4%87%E5%BF%98/"},{"categories":null,"content":"对于Bresenham算法的解释\nBresenham算法 Bresenham算法是一种绘制直线和曲线的方法。这里主要是介绍如何绘制直线。\n带有浮点数的Bresenham算法 首先我们讨论直线斜率在$[0, 1]$之间的情况：\nBresenham的思想是这样：\n因为计算机是基于像素的，所以将每个像素视为一个格子，并且理想直线从起点到终点，穿过这些格子。\n这里由于格子的长度为1，所以黄色所标记的那一段是斜率$k$。\n然后定义直线和每个格子的竖直方向交点到下面格子的距离是$d$。\nBresenham的算法思想就是通过判断$d$的值来判断下一个点是取直线上方的点还是下方的点。\n如果$d \u003e= 0.5$，那么我们要取直线上方的点。如果$d \u003c 0.5$那么我们要取直线下方的点。\n而且显然，在起点处的$d_0 = 0$，然后我们每次迭代的时候令$d_{i+1} = d_i + k$，这样就可以获取到下一个交点到起点所在横线的距离。但是$d$是可能大于1的，所以在$d$大于等于1的时候我们要减去一，这样我们就有了如下的递推式：\n$$ \\begin{matrix} d_0 = 0 \\ d_{i+1} = d_i + k \\ 如果 d_i \u003e= 1 那么 d_i = d_i - 1 \\end{matrix} $$\ny的变化情况就是这样：\n$$ y = \\begin{cases} y + 1, d_i \u003e= 0.5 \\ y, d_i \u003c 0.5 \\end{cases} $$\n这样我们就可以写出Bresenham的伪代码表示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // k在[0, 1]的Bresenham算法 void Bresenham(int x1, int y1, int x2, int y2) { float d = 0; float k = (y2 - y1) / (x2 - x1); while (x1 != x2) { plot(x1, y1); // 绘制点 x1 += 1;\t// x1向后移动一个像素点 d += k; if (d \u003e= 1) d -= 1; // 计算y的下一个值 if(d \u003e= 0.5) y1 += 1; } } 将所有的浮点数转换为整数 Bresenham之所以比中点画线和DDA算法要好，就是因为它的算法内没有任何的浮点数运算。显然我们还需要改进。\n第一个改进的点就是令$e = d - 0.5$，这样的话我们只需要判断$e$是否大于等于0，如果是，则y+1，否则y不动：\n$$ y = \\begin{cases} y + 1, e \u003e= 0 \\ y, e \u003c 0 \\end{cases} $$\n初值为\n$$ e_0 = -0.5 $$\n递推式变成:\n$$ e_{i+1} = d_{i+1} - 0.5 = d_i - 0.5 + k = e_i + k = e_i + \\frac{y2 - y1}{x2 - x1} = e_i + \\frac{\\Delta y}{\\Delta x} $$\ne的更新式子:\n$$ 如果e \u003e= 0 那么 e = e-1 $$\n然后这里的$e_0$是-0.5这点不行，并且在迭代式中还有个可能是浮点数的k，所以我们令\n$$ e' = 2e\\Delta x $$\n这样就有了新的初值和递推式：\n$$ \\begin{matrix} e'0 = 2e_0\\Delta x = 2\\times -0.5 \\times \\Delta x = -\\Delta x \\ e'{i+1} = 2e_{i+1}\\Delta x = 2(e_i + k)\\Delta x = 2e_i\\Delta x + 2k\\Delta x = e_i + 2\\Delta y \\end{matrix} $$\n即\n$$ \\begin{matrix} e'0 = -\\Delta x \\ e'{i+1} = e_i + 2 \\Delta y \\end{matrix} $$\n$e'$的更新式子:\n$$ 如果e' \u003e= 0那么e' = e' - 2\\Delta x $$\n新的y改变规则就出来了：\n$$ y = \\begin{cases} y + 1, e' \u003e= 0 \\ y , e' \u003c 0 \\end{cases} $$\n这下所有的变量都是整数，没有任何的浮点数计算了。\n那么代码表示如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // k在[0, 1]的Bresenham算法 void Bresenham(int x1, int y1, int x2, int y2) { int dx = abs(x1 - x2), dy = abs(y1 - y2); // 这里由于dx,dy只是用于e中，所以我们可以简单取正 int e = -dx; while (x1 != x2) { plot(x1, y1); x1 += 1; e += 2* dy; if (e \u003e= 0) { e -= 2 * dx; y++; } } } 这样就完成了。\n推广到所有象限 首先，如果$\\Delta y \u003e \\Delta x$，那么我们需要将式子中的$\\Delta x$和$\\Delta y$互换。\n其次是x和y的步进问题，这里我们这样：\n1 2 3 4 int sx; if (x1 \u003e x2) sx = 1; else if (x1 == x2) sx = 0; else sx = -1 y也是同理，这样完整的程序就是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void Bresenham(int x1, int y1, int x2, int y2) { int dx = abs(x1 - x2), dy = abs(y1 - y2), sx = x1 \u003e x2 ? 1 : x1 == x2 ? 0 : -1, sy = y1 \u003e y2 ? 1 : y1 == y2 ? 0 : -1 int e; if (dx \u003e= dy) e = -dx; else e = -dy; while (x1 != x2 \u0026\u0026 y1 != y2) { plot(x1, y1) if (dx \u003e= dy) { x1 += sx; e += 2 * dy; if (e \u003e= 0) { e -= 2 * dx; y += sy; } } else { y1 += sy; e += 2 * dx; if (e \u003e= 0) { e -= 2 * dy; x += sx;\t} } } } 完整的Nim实现在这里\n","description":"","tags":null,"title":"Bresenham算法","uri":"/posts/bresenham%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"本文讨论了何时C++会自动进行移动操作，并且说明了复制消除，RVO和NRVO优化。\n移动操作主要参考了cppreference 的这个说明, 优化部分的主要的参考来自于stack overflow 的这篇文章。\n移动操作 移动操作有关的函数 和移动操作相关的类函数有两个：\n移动构造函数：\n1 A(A\u0026\u0026 rhs); 移动赋值运算符：\n1 A\u0026 operator=(A\u0026\u0026 rhs); 注意这两个函数的参数类型都不是const，这也是C++默认会生成的函数声明。\n移动构造函数用于在构造类型的时候使用：\n1 2 3 4 5 6 A a1; // 使用std::move强制进行移动 A a2 = std::move(a1); 或 A a2(std::move(a1)); 而移动赋值运算符就是在赋值的时候进行移动：\n1 2 3 A a1; A a2; a1 = std::move(a2); // 使用move进行强制移动 何时自动声明移动构造函数和赋值移动构造函数 隐式的移动构造函数将会在可以被生成且满足如下所有条件的情况下自动生成：\n没有用户声明的 复制构造函数 没有用户声明的 复制赋值运算符（即operator=(const A\u0026)这类） 没有用户声明的 移动赋值运算符（即operator=(A\u0026\u0026)这类） 没有用户声明的 析构函数 所谓可以被生成的意思是满足以下所有条件：\n类中没有不能移动的非静态成员 继承时，基类可以被移动 继承时，基类的构造函数可以被访问 而移动赋值运算符的产生条件也差不多，只不过将没有声明的 移动赋值构造函数改成没有用户声明 移动构造函数即可。\n总之，这两个函数生成的条件就一句话：除了普通的构造函数外（指默认构造函数和带其他参数的构造函数），不得声明任何其他的构造函数，operator=函数和析构函数。\n何时自动移动 使用std::move是一种强制的，显式的移动。但是C++很多时候为了效率会自动帮我们移动。主要的规则其实就是所有的右值都会进行移动，如果不能移动，进行拷贝。但是为了严谨，我们还是摆出cppreference上的规则：\n初始化的时候使用std::move()：T a = std::move(b)或者T a(std::move(b));这种。这里要加上std::move()，不然会调用复制构造函数。 函数实参传递的时候使用std::move() ：func(std::move(a)) 函数返回时，如： 1 2 3 4 5 6 7 8 9 class A {}; A CreateA() { return A(); } // call A a = CreateA(); 的时候，使用A()产生的变量会首先移动到CreateA()函数产生的返回值中，这个时候这个返回值是一个临时变量（我们记为temp），接下来就是执行这段代码：A a = temp，然后temp是临时变量， 会再次调用A的移动构造函数给a变量。\n前两个是属于显式的移动，最后一种就是隐式移动。移动赋值运算符的规则也是一样，只有等号右边是临时变量就会自动调用。\n复制消除，RVO和NRVO 虽然C++对移动操作定义的很明确，但编译器却并不总是按照这个定义去做。因为编译器中有三个重要的优化经常会减少拷贝，甚至是移动操作。\n在GCC和Clang下可以添加-fno-elide-constructors选项来关闭这三种优化。\n复制消除 来看一看下面代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class C { public: C() {} C(const C\u0026) { std::cout \u003c\u003c \"A copy was made.\\n\"; } C(C\u0026\u0026 rhs) { std::cout \u003c\u003c \"A move was made.\\n\"; } }; C f() { return C(); } int main() { std::cout \u003c\u003c \"Hello World!\\n\"; C obj = f(); } 这里建议在C++17标准下编译，因为C++17起所有的复制消规则除被写在语言规范内，大部分编译器应该都会做这件事。我的Clang++ 12.0.5上的执行结果仅仅是输出了一行Hello World:\n1 Hello World! 按照上面的规则，函数在返回的时候会进行移动，也就是说在f()的调用内，会先移动给临时变量，然后临时变量再移动给obj，但是这里什么都没发生，没有任何的移动和拷贝，obj就像凭空出现了一样。\n在C++17起，复制消除是强制执行的，而C++11中是看编译器心情。\n在如下条件下会进行复制消除：\n在return语句中，return的值是和函数返回值类型一样的右值。类型一样是为了防止隐式转换，否则会产生新的变量从而阻止移动，右值是因为C++自动移动只能对右值操作。 在变量初始化的时候，初始化表达式是右值。如: 1 2 3 4 5 6 class A{}; A f() { return A(); } // 这里是第一种情况，会自动复制消除 // call A a = f(); // 这里函数返回值的临时变量到a的过程中的移动也会被消除 这也就解释了为什么上面的代码没有调用任何的拷贝，移动函数了。\nRVO和NRVO RVO是Return Value Optimization（返回值优化）的简写，而NRVO是Named Return Value Optimization（命名返回值优化）的简写。这两个优化是复制消除的常见形式。\n通过他们的名字就可以看出，这是在函数返回的时候做的优化。\nRVO是指在函数返回一个临时变量时的优化，具体的优化如下：\n1 2 3 4 5 6 7 8 9 10 11 // 原本的函数 T CreateT(int value) { return T(value); } T a = CreateT(10); // 优化后的函数（伪代码）： void CreateT(T\u0026 v, int value) { v.T::T(value);\t// 直接在内部进行构造 } 即通过将要接收函数返回值的对象以引用的形式放入函数内部初始化，这样就避免了一次移动/拷贝。\n而NRVO则是更加宽泛的RVO。对于如下的代码可以执行NRVO：\n1 2 3 4 T CreateT(int values) { T t(value); return t; } 编译器也会优化成上面RVO优化的样子。\n","description":"","tags":["cpp"],"title":"C++移动操作，以及复制消除，RVO和NRVO","uri":"/posts/c++%E7%A7%BB%E5%8A%A8rvo%E5%92%8Cnrvo/"},{"categories":null,"content":"\nXenEngine是我的本科毕业设计，是一个基于OpenGL的游戏引擎，仓库在这里\n这次就来说一说我制作这个引擎的心得\n心得体会 这个引擎是我花费了将近20天制作的，其实也算是一个速成引擎，里面还有不少的bug。\n以前写过渲染器，但是写的比较垃圾。这次本来想把PBR和曲线绘制加进来的，但是时间实在是不够了，就写了个小的。总的来说不是很满意。\n因为之前没有写过游戏引擎，这次一开始是跟着Cherno的视频一步一步做的，前期基本就是跟着视频一步一步抄代码，毕竟我也不知道他后面会讲什么，所以不敢擅自改动，怕后面代码结构不一样自己变来变去还麻烦。但是他只讲到了2D部分，后面的3D部分是我自己独立完成的。\n不得不说大佬就是不一样，代码的结构非常的清晰，从中学到了不少。\n技术细节 如何跨平台和允许用户指定渲染API 首先是关于跨平台的事情，Cherno一开始就打算让引擎跨平台，需要支持多种渲染API，并且还提供给用户自己选择API的权利。也就是说，你可以通过如下代码来指定引擎使用的API：\n1 2 3 Renderer::Init(RendererAPI::API::OpenGL); // 选择OpenGL Renderer::Init(RendererAPI::API::Vulkan); // 选择Vulkan Renderer::Init(RendererAPI::API::DX11); // 选择DirectX11 具体的做法是这样，首先对API进行抽象，比如顶点缓冲，索引缓冲和纹理等都做一个高层次的抽象:\n1 2 3 class VertexBuffer; class IndexBuffer; class Texture; 然后让具体的API去实现这些抽象类：\n1 2 3 class OpenGLVertexBuffer: public VertexBuffer {} class OpenGLIndexBuffer: public IndexBuffer {} class OpenGLTexture: public Texture {} 然后在Renderer::Init()方法中让用户指定API：\n1 2 3 4 5 6 7 8 9 10 11 12 13 enum class RendererAPI { None, OpenGL, Vulkan, DX11 }; class Renderer { public: static void Init(RendererAPI api) { api_type_ = api; } inline static RendererAPI GetAPI() { return api_type_; } ... private: static RendererAPI api_type_; }; 最后在抽象类中使用工厂方法，根据API的不同来创建不同的子类：\n1 2 3 4 5 6 7 8 9 10 11 std::static_cast\u003cVertexBuffer\u003e VertexBuffer::Create() { switch (Renderer::GetAPI()) { case OpenGL: return std::make_shared\u003cOpenGLVerteBuffer\u003e(); case Vulkan: return std::make_shared\u003cVulkanVerteBuffer\u003e(); case DX11: return std::make_shared\u003cDirectX11VerteBuffer\u003e(); } return nullptr; } 这样就达到动态指定API的方法了。\n我在其上做了点改进，因为不是所有的平台都有OpenGL或者Vulkan的，我们需要检测平台有没有，如果没有的话就不应该让用户指定对应的API。这一点可以让CMake帮我们搞定：\n1 2 3 4 5 6 7 8 9 10 find_package(OpenGL QUIET) # 先让CMake寻找库 add_library(XenEngine) # 添加target if (OpenGL_FOUND) # 如果找到了，我们就给一个宏定义HAS_OPENGL target_compile_options( XenEngine PUBLIC HAS_OPENGL ) endif() 有了这个宏定义我们就可以在工程中指定了：\n1 2 3 4 5 6 7 8 9 10 enum class RendererAPI { None, #ifdef HAS_OPENGL OpenGL, #endif #ifdef HAS_VULKAN Vulkan, #endif ... }; 这样就可以做到避免不存在的API指定。\n智能指针的广泛使用 其次让我感到新奇的是它对智能指针的广泛使用。在他的工程里面几乎没有使用过new和delete操作符，都是使用智能指针代替。\n其实我也很熟悉智能指针，只是没有这么广泛地用过，因为很难确定unique_ptr和shared_ptr的使用场景，经常要在两者之间来回切换。这一次我是见识到了智能指针的威力，以及何为“RAII”。这种不用操心内存释放的事情简直太美妙了。\n其实总的来说，shared_ptr的使用比unique_ptr广得多，毕竟有很多变量都是共享的，需要当做参数传来传去。我好像就没有用unique_ptr。\n但是智能指针也有不是很管用的情况，就是在使用ODE的时候，ODE需要在程序结束的时候调用dCloseODE()，而在调用这个函数前必须将所有的ODE引擎对象全部使用Destroy函数删掉。这就造成了一个问题：因为ODE是纯C的库，我在上面又封装了一层C++，并且仿照了Cherno的做法使用工厂函数返回shared_ptr。一旦我返回了shared_ptr，这意味着我将变量的析构交给了系统，按道理来说我是完全不需要操心的。但是由于ODE的这个特性，我不得不将每一个产生的shared_ptr记录下来，最后再ODE关闭前全部手动清除。讲真这样我还不如不用智能指针，我自己写一个管理类都好一些。\n这里顺便吐槽一下ODE：你居然自己不在关闭的时候自动释放。我怀疑他就没有追踪他分配的这些内存。。。\n着色器方面的细节 我之前一直为着色器的uniform变量困扰过，以冯氏光照为例，有些模型是有镜面贴图的，有些没有。我以前的做法是直接写两个着色器，一个有uniform Sampler2D specular_map，一个没有。因为不适用的uniform着色器会自动移除，所以如果你写了不用的话会在光照计算方面带来错误。\n但是显然这样非常麻烦。后面还有视差贴图和法线贴图等，不能总是每多一类贴图就多写一个着色器。\nCherno给了个很好的解决方案：如果你不适用镜面贴图，直接给一个黑色的1x1的贴图就行了。简直天才。同理，不适用的法线贴图可以给一个纯蓝色的1x1纹理。\n而且这些纹理不需要从文件读取，直接glTexImage()传给GPU就行了，美滋滋。\n用这个方法只需要写一个着色器就行了。\n对未来的展望 通过这次毕设，我学到了很多，也充分认识到了自己的不足。虽然是因为时间关系没有加一些新东西，但是说真话，就算加了PBR和曲线我也依然没有办法想出这么好的代码设计和处理一些疑难杂症的方法。而且我也看了别人写的引擎，比我的牛逼多了。我感觉我在计算机图形学方面还是刚刚入门。现在我越来越坚信我二战是正确的选择，我希望我能成功上岸图形学的研究生，花个两三年时间好好研究研究这方面。\n","description":"","tags":["game engine"],"title":"XenEngine制作心得","uri":"/posts/xenengine%E5%88%B6%E4%BD%9C%E5%BF%83%E5%BE%97/"},{"categories":null,"content":"\nTinyrenderer3D和Tinyrenderer2D的编写心得 这几天写了3D和2D的渲染器，原本是只打算编写一个2D渲染器的，但是在写的过程中发现2D能写的很少，用不到我学的所有东西，所以就在2D的基础上编写的3D的渲染器。\n渲染器地址：2D，3D\n2D渲染器的心得 2D的话我打算写一个比SDL强一些的渲染器的，主要是想要这种五彩斑斓的多边形：\n而且确实也写成了。这个渲染器给我的收获就是让我明白了SDL的渲染器是如何构建的，虽然说我没有看过SDL的源码，但是我参考着SDL的API，将渲染器部分重要的API都实现了一遍。这种五彩斑斓的五边形的API设计是参考SFML的。\nSDL本身是有两种渲染器，在SDL1的时候是软渲染，渲染用不到GPU，完全的软件，所以这个时候用的是SDL_Surface用来代表图像，并且可以直接通过成员获得其图像数据和格式。但是在SDL2时出现了基于OpenGL和DX的渲染器，使用SDL_Texture表示图像，充分利用了GPU。所以SDL_Texture是不能直接获取图像数据，图像格式的，因为他们都保存在了GPU中，其加载图片时执行了类似这样的代码：\n1 2 3 4 5 6 int w, int h; unsigned char* data = load_image(filename, \u0026w, \u0026h); glBindTexture(GL_TEXTURE_2D, texture); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGB, GL_UNSIGNED_BYTE, data); glBindTexture(GL_TEXTURE_2D, 0); free_image(data); 将图片数据传给GPU之后就可以将内存中的数据删除了，所以每次调用GetPixel()这样的数据的话必须问GPU要像素，很耗时间。\n至于可以将Texture作为渲染器的目标，这是使用了帧缓冲做出来的。\n3D渲染器的心得 到了3D渲染器这方面就裂开了，因为之前没有深入用过3D引擎的经历，只用过一点Pandas。而且市面上一般都是3D游戏引擎，纯写渲染器的好像都是用于建模软件的静态渲染器，也没找着什么源码来参考。当时在写的时候参考了一下Irrlicht引擎的API，然后从头开始自己摸索组织代码。\n这一部分跟着Learning OpenGL的教程来实现的，其实这个教程我之前走过，当时是每个部分分开写的，所以感觉没什么难度。这一次我得把所有的东西全放到一起，感觉难度瞬间就上来了。\n错误处理 首先最令人头疼的就是OpenGL的错误处理，这一点我只能说Vulkan验证层牛逼。原本的教程中没说这方面，我去B站搜了视频才知道方法。主要有两个方法：\n首先是最原始的glGetError()函数。OpenGL会把错误放入到队列中，任何一个函数出错了，它会将错误信息放入队列，然后可以通过这个函数从队列里面拿一个错误出来。如果队列是空就会返回GL_NO_ERROR。所以跟着视频我编写了这样的函数：\ninline void GLClearError() { while (glGetError() != GL_NO_ERROR); } inline void GLPrintError(const char* function, int line) { GLenum error; while ((error = glGetError()) != GL_NO_ERROR) { printf(\"[OpenGL Error](%s - %d): %s\\n\", function, line, ErrorCode2Str(error).c_str()); } } #define GLCall(x) \\ do { \\ GLClearError(); \\ x; \\ GLPrintError(__FUNCTION__, __LINE__); \\ } while(0) 这样的的话每次调用函数都得裹上一层GLCall宏来判断错误。这个东西的好处就是所有版本OpenGL都支持，缺点就是他只返回一个错误码，要知道什么错误还得去查码。\n或者使用GL_ARB_debug_output拓展，这个拓展会自动在出错的时候在控制台上输出信息，类似于Vulkan的验证层，不过很可惜的是我电脑不支持这个。。。\n这些错误中最令人头疼的就是GL_INVALID_OPERATION，这个错误说你的操作在当前状态下不行。意思就是说我也不知道为什么错了，你自己查去。\n每每遇到这个错误，都要花费我好长时间去调试，现在总结起来，一般都是调用glBufferData,glVertexAttribPointer这类需要缓冲的函数时，当前绑定的缓冲不存在或者是0，这样由于当前OpenGL状态不正确，所以会报错。\n有东西没画出来 第二令人头大的是程序也没报错，但是窗口上就有些该出现的东西没出现，有些东西画不出来。主要有两个原因：\n着色器问题：可能存在uniform类型变量没有赋值，或者直接被删了。这里比较坑的是如果一个uniform变量你在着色器中没有使用，它会给你删了，然后在使用glGetUniformLocation()函数的时候直接返回-1。\n而且比较坑的是，如果你想这样定义了一个函数：\n1 2 3 4 5 6 uniform sampler2D shadow_map; float CalcShadow() { // use shadow_map ... } 在函数里面用了uniform变量，但是你却没有调用过这个函数的话，这个变量默认还是会被删除！所以可以推测在编译着色器程序的时候，OpenGL会将没用到的变量，函数都删了。\n视角问题：有时候MVP矩阵可能会出错，导致将物体移到了未知的地方。解决办法就是提前确保MVP矩阵没错，然后加一个可以自由移动视角的摄像机，这样当视野中没显示的时候可以转动摄像机看看。或者在绘制物体的时候输出物体变换后的坐标。\n面剔除问题：可能物体的顶点不符合当前设置的面剔除规则，OpenGL帮你剔除了。解决办法就是关闭面剔除再转一遍。\n而且在绘制阴影的时候，也比较难确保阴影究竟有没有绘制成功，这个时候需要将阴影贴图画出来看一看。\n综上所述，通过这些经验我可以做一个简单的单元测试框架，来查看发生问题的原因（当时着急赶进度没写，现在后悔了😭），这个框架的主要功能是：\n禁用面剔除，模板测试（有些时候模板测试也会带来一些问题）\n物体的位置永远在(0,0,0)以便于更好地判断位置问题\n多种绘制模式：\n只绘制线框 只绘制颜色 绘制贴图 并且可以通过按键来自由调控，这样的话就可以判断到底是在哪个阶段出了问题。\n如果是线框出问题，那可能是顶点没有传输到GPU中或者VAO,EBO有问题。\n如果是颜色没画出来，那可能是片段着色器出问题，或者颜色没传到GPU中。\n如果是贴图没画出来，就要检查贴图方面的问题，贴图加载是否成功，有没有传到GPU中，纹理格式设置对不对等。\n其实针对光照和其他的功能还得写针对的框架，这里就不赘述了。\n着色器 第三个令人头疼的是着色器，以前跟教程的时候都是每个章节新开一个着色器，着色器中就那么点功能。但是现在我的着色器又要绘制纯色，又要绘制纹理，又要光照，还得在有没有法线纹理之间来回切换。有些需要将顶点和颜色一起通过layout传入，有些只要传入顶点，但是需要纹理。\n我第一个解决办法是将着色器分类，比如纯色的着色器放一个文件，贴图的着色器放一个文件。但是当我写到光照贴图部分的时候就不行了，因为我的API是这样设计的：\n1 2 3 4 5 6 plane_.material.ambient = {0.6, 0.6, 0.6}; plane_.material.diffuse = {0.6, 0.6, 0.6}; plane_.material.specular = {0.6, 0.6, 0.6}; plane_.material.shininess = 32; plane_.material.diffuse_texture = texture; 每个物体都有环境光，漫反射和镜面三种属性，你可以通过数值直接指定，或者给他贴图。当有贴图的时候相应的数值部分就不再发挥作用。\n这就导致我没得办法将着色器分类，我总不能为纯色写一个，为有漫反射贴图的写一个，再给镜面光的写一个吧，这样着色器数量也太多了。\n最后没得办法，只能把所有的着色器并成一个，然后在里面使用bool类型的uniform变量指定是否存在贴图。\n结果就是着色器很长，而且我认为那些bool变量没什么必要，还让我的uniform数量减少了（我电脑上最多一次性支持50个uniform），将这些变量去掉我能多加一些光源呢。但是目前我没更好的办法，只能这样将就一下。\n天空盒子 以前我写天空盒就遇到过坑：天空盒的六个图像大小必须一样。\n这次又遇到一个：图像边长必须为2的倍数。\n总结 这次编写渲染器不仅仅让我复习了OpenGL，也让我欣赏到了凌晨三四点的风景，让我在半夜看着屏幕血压飙升，以及连续5天中午吃泡面的艰辛历程。\n","description":"","tags":["OpenGL"],"title":"游戏渲染器的编写心得","uri":"/posts/%E6%B8%B8%E6%88%8F%E6%B8%B2%E6%9F%93%E5%99%A8%E7%9A%84%E7%BC%96%E5%86%99%E5%BF%83%E5%BE%97/"},{"categories":null,"content":"OpenGL中的错误处理方法有两种，一种是所有版本都能用的glGetError()，这个函数每次调用只会返回一个错误值，如果没有错误会返回GL_NO_ERROR。而4.3及之后的版本中有glDebugMessageCallback()函数，通过这个函数给OpenGL注册一个回调函数，可以在每次发生错误的时候OpenGL以人类可读的方式在屏幕上打印出错误。\n这里使用glGetError()函数来进行错误处理，首先可以编写函数来清空所有的错误：\n1 2 3 void GLClearError() { while (glGetError() != GL_NO_ERROR); } 然后可以编写一个函数来对每个错误值输出：\n1 2 3 4 5 6 void GLPrintError() { GLenum err; while ((err = glGetError()) != GL_NO_ERROR) { cout \u003c\u003c \"[OpenGL Error]:\" \u003c\u003c err \u003c\u003c endl; } } 最后可以编写一个宏来帮助我们在每次调用OpenGL函数时都捕捉错误并输出：\n1 2 3 4 5 6 #define GLCall(x) \\ do { GLClearError(); x; GLPrintError(); } while(0) 这样我们每次通过GLCall()调用OpenGL函数就可以检测到错误了：\n1 GLCall(glBindTexture(GL_TEXTURE0, 0));\t// will print error code ","description":"","tags":["OpenGL"],"title":"OpenGL中的错误处理","uri":"/posts/opengl%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"},{"categories":null,"content":"这里是我学习完Vulkan基本操作后的一个总结，主要讲述了各个部分的功能。\n对Vulkan各个部分的解释 整个Vulkan其实就下面两张图：\n首先是这个不包含渲染管线的图，其中的各个步骤解释如下：\nVkInstance：这个是Vulkan最基本的，需要最先创建的结构，包含了Vulkan的所有信息 VkPhysicalDevice：这个结构体对应着物理硬件显卡，一般我们需要从众多显卡中挑选一个适合的显卡来工作。显卡可以做两个工作：图形渲染(Graphic)和GPU计算(Compute)。 VkDevice：在挑选完显卡后，我们需要根据现有的显卡创建一个软件上的逻辑显卡，这是因为我们没有办法直接操纵显卡（只有着色器可以直接运行在显卡上，我们的代码不行），而是需要先在逻辑设备上完成一些事情，让逻辑设备和显卡沟通。 VkQueue：这个在创建逻辑设备的同时会被创建，是一个命令队列，用于将我们的命令缓冲提交给显卡，显卡再从命令缓冲中将命令拿出来执行。 VkCommandPool：命令池，这个就和线程池和内存池一样，就是为了更好地利用内存而诞生的。 VkCommandBuffer：命令缓冲，可以从命令池创建，是一个缓冲，用于记录一些的命令，到时候可以被命令队列提交到显卡去执行。 VkSwapchain：交换链，交换链中有很多的图像，GPU可以对其中的图像进行操作，并且交换链本身也可以将图像交给显示屏渲染（主要就是交给显示屏渲染）。 VkImage：存储在内存中的图像。 VkImageView：VkImage不能直接访问其属性，需要VkImageView来得到其属性（包括Image的大小，色彩空间，色彩格式等） 一般来说，Vulkan的步骤就是创建好上面的东西之后，通过将命令放入命令缓冲，然后将命令缓冲提交到命令队列，命令队列再将其提交到GPU中执行就可以了。\n至于GPU中究竟如何执行，第一是看你的命令，第二如果你是图形方面的命令，还要看渲染管线怎么设置：\n渲染管线指定了我们需要如何渲染一个图像。其中最后边的是其渲染流程，从顶点输入到颜色混合，每个阶段都是可由代码指定的。另外还有三个阶段分别对应三个着色器（顶点着色器，细分着色器，片段着色器）。\n在管线状态中：\ndynamic state是用来确定uniform变量数据的阶段 vertex input state则是从内存输入顶点到着色器的阶段，这个阶段会看layout关键字指定的着色器数据，并且将顶点数据给着色器 input assembly state则是告诉GPU需要将输入的点都按照什么样的形状连在一起（三角形，直线，点） rasterization state则决定如何光栅化 color blend state决定如何进行颜色混合（是不是用透明色，颜色空间如何） viewport state则指定了屏幕的视口和大小 depth stencil state会对图像进行深度和模板测试 最后是多重采样，指定如何使用采样和抗锯齿。 ​\t显然，渲染管线内定义了这么多阶段，但是就是没有定义这些阶段需要用在什么图像上。这里渲染通道（Renderpass）就是干这个事情的，它会做两件事：\n指定渲染管线工作的图像集(VkFramebuffer)。 指定图像从CPU到GPU，在从GPU到屏幕之间的数据格式的转变(pipeline layout)。 而framebuffer，从图中也可以看出，是会存储多个VkImage的缓冲区（就是一组VkImage）。正如图中所示，不管是深度缓冲还是模板缓冲，颜色缓冲，都需要在VkImage上进行操作。如果你需要对一个可显示的图像使用深度缓冲的话，你就需要一个存储颜色数据的VkImage和一个存储深度信息的VkImage，如果你想要加上模板缓冲的话还得加一个存储模板缓冲信息的VkImage。Framebuffer就是将这些缓冲对应的VkImage存储在一起，告诉管线：“你在做颜色混合，深度和模板缓冲的时候用这些VkImage”。\n小结 Vulkan的确很麻烦，但是不是很难，因为其将所有的阶段全部展现出来了，让我能够更加清楚地了解到渲染的整个过程，弄懂了这些过程，感觉用起来就比较简单了😁。\n","description":"","tags":null,"title":"对Vulkan各个结构的解释","uri":"/posts/%E5%AF%B9vulkan%E5%90%84%E4%B8%AA%E7%BB%93%E6%9E%84%E7%9A%84%E8%A7%A3%E9%87%8A/"},{"categories":null,"content":"什么是IMGUI 我们平常使用的GUI，像是QT和wxWidgets这种，属于保留型GUI(Retianed Mode GUI，简称RMGUI)，即它们将和GUI有关的状态都保存在内部，如果你想要改变状态的话，需要使用一系列的Set函数去更改。\n而本文要介绍的是另一种老旧的，在CLI时代就存在的绘制GUI的方法：立即型GUI(immediate Mode GUI，简称IMGUI)。这类GUI不采用OO方式实现，而是过程式编程，并且也不会保留内部的状态，在每次绘制的时候都需要用户传入状态。这种类型的更多的适用于显示区域实时刷新的程序里面，例如游戏和CAD等。\n举个栗子，如果是RMGUI创建按钮，并且在按钮按下设定事件的代码类似这样：\n1 2 3 4 5 6 Button* button = Button::Create(\"button1\", Point(100, 100), Size(64, 40)); window-\u003eSetChild(button); button-\u003eShow(); button-\u003eBind(EVENT_CLICK, [](Event\u0026 event){ // 绑定事件 // your click processing }); 这种就是控件所有的状态都在内部，是典型的OO设计。\n如果是IMGUI，则可能是这样的代码：\n1 2 3 4 5 6 Point button_position = {100, 100}; Size button_size = {64, 40}; int event = Button(ID_BUTTON1, button_position, button_size); // draw button if (event == EVENT_CLICK) { // your click processing } 没有关于button的对象或者结构体，只有一个Button函数用于绘制Button（控件即是函数），并且返回触发在button上发生的事件。如果你不想显示button只需要不调用Button函数即可。\n有关IMGUI最火的库就是Dear IMGUI，可以先去试着用一用。\nIMGUI在目前游戏的应用属于“文艺复兴”，因为这种GUI方式最早是在CLI界面中使用的，直到后面的OO出现才被用的比较少。但是仍旧很有应用价值。\n一般的RMGUI虽然好用，但是存在如下的缺点：\n一般都很很庞大 自己从0开始造轮子的话很困难，当游戏中只需要一些小的GUI时，花时间去造RMGUI费时费力。 存储额外的，重复的状态。比如我要共享一份文本在各个TextEditor中，我就需要调用每个TextEditor的SetText方法让他们将这份文本拷贝一份到自己的内部。 而IMGUI实现起来则非常简单（通过本文即可实现一个小的IMGUI），而且各个控件之间的耦合非常低（毕竟控件不存储状态，自然就不需要控件本身和其他控件主动交互，耦合度大大的低），很容易拓展。\n当然IMGUI也有缺点，那就是写的代码很杂乱：因为IMGUI自己不存储状态，这意味着所有的状态需要用户自己设置，写到最后代码中各种if让代码很凌乱。而且各种控件的代码摆在一起，让人头晕目眩。而且很难使用布局文件来自动布局。当然，用得好也是很强的，Unity的GUI就是IMGUI。\n我的建议是，如果你的游戏一开始并没有考虑到使用GUI，但是后面出现了不多的GUI需求，也找不到合适的RMGUI搭配游戏的话（我就是这样），可以自己造一个小的IMGUI。如果是确定游戏或引擎中有大量的GUI需求，还是推荐用RMGUI。\n开始编写IMGUI 对于IMGUI的介绍就到此为止，接下来我们着手用SDL2实现一个小的IMGUI。这部分内容也可以容易地使用其他绘图库实现。我这里用C++17作为编程语言，不过不会过多地涉及到C++的语法，大部分的语法是和C相通的（毕竟不使用OO），并且假设你对SDL2很熟悉。\n本文的参考教程是Sol:IMGUI Turorial，但是他是用SDL1写的。\nGUIState 首先我们需要一个GUIState结构体来存储整个IMGUI的状态：\n1 2 3 4 5 6 7 8 9 10 11 12 typedef unsigned int IDType; // 定义ID的类型 struct EventType { // 定义事件的类型 EVENT_NOTHING, EVENT_CLICK // 后面定义你需要的事件 }; struct UIState { SDL_Point mouse_position; bool mouse_down; IDType hot_item; IDType active_item; } uistate = {{0, 0}, false, 0, 0}; // 这是全局变量 里面包含了当前鼠标的位置，鼠标按键是否按下（我这里只检测鼠标左键，其他的按键请按需添加）。hot_item是当前鼠标悬浮在上面的控件ID，active_item是当前被按下的控件ID，不管鼠标现在是否在上面，只要在上面按下了没松开就记录下来。\n然后我们要在我们的游戏循环里设置这些值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 while (!is_quit) { SDL_SetRenderDrawColor(render, 200, 200, 200, 255); SDL_RenderClear(render); while (SDL_PollEvent(\u0026event)) { if (event.type == SDL_MOUSEMOTION) { uistate.mouse_position.x = event.motion.x; uistate.mouse_position.y = event.motion.y; } if (event.type == SDL_MOUSEBUTTONDOWN) { if (event.button.button == SDL_BUTTON_LEFT) { uistate.mouse_down = true; } } if (event.type == SDL_MOUSEBUTTONUP) { if (event.button.button == SDL_BUTTON_LEFT) { uistate.mouse_down = false; } } if (event.type == SDL_QUIT) is_quit = true; } SDL_RenderPresent(render); SDL_Delay(30); } 第一个控件，Button 现在我们来创建第一个控件：Button，这代表着一个按钮。\n1 EventType Button(SDL_Renderer* render, IDType id, int x, int y, int w, int h, SDL_Color color, SDL_Color press_color); 我们的Button有一个ID，标识其位置和大小的xywh，显示的颜色color以及被按下时显示的颜色press_color。\n这个函数的实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 SDL_Rect rect = {x, y, w, h}; SDL_SetRenderDrawColor(render, color.r, color.g, color.b, 255); if (SDL_PointInRect(\u0026uistate.mouse_position, \u0026rect)) { uistate.hot_item = id; // 如果鼠标悬浮在上面，就设置hot_item为id if (uistate.active_item == 0 \u0026\u0026 uistate.mouse_down) { // 如果鼠标按下，设置active_item为id uistate.active_item = id; } } if (uistate.active_item == id)\t// 如果按下了，就改变颜色 SDL_SetRenderDrawColor(render, press_color.r, press_color.g, press_color.b, 255); SDL_RenderFillRect(render, \u0026rect); if (uistate.active_item == id) return 1; return 0; 这个函数做了三件事：\n通过鼠标的状态更改了GUIState 绘制了Button 返回了触发的Button事件 那么这个时候我们就可以这样使用我们的button：\n1 2 3 if (Button(render, ID_BUTTON1 /*全局的enum*/, 100, 100, 64, 40, {200, 0, 0, 255}, {0, 200, 0, 255}) == EVENT_CLICK) { cout \u003c\u003c \"button clicked\" \u003c\u003c endl; } 这个时候窗口上会有一个button，按下之后会变成蓝色的。不过不会变回去。我们需要在游戏循环的开头和结尾进行一些处理：\n1 2 3 4 5 6 7 8 9 void imgui_prepare() {\t// 放在所有控件之前 uistate.hot_item = 0; } void imgui_finish() { // 放在所有控件之后 if (!uistate.mouse_down) { uistate.active_item = 0; } } 就完成了，效果如下：\n这里有个缺点：当一直按着Button的时候会一直输出\"button clicked\"。你可以在Button函数里对一直按下的情况作出处理。这里就不进行处理了。\n再来一个控件，SlidBar 通过上面的Button的例子，想必你已经了解了基本控件的编写方法，我们这里再编写一个滑动条作为例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 EventType SlidBar(SDL_Renderer* render, IDType id, int x, int y, int len, int min, int max, int\u0026 value) { const int h = 20;\t// 这个是纵向的滑动条，这里是滑动条的高度 const int button_len = 16; // 滑动条中按钮的边长 int draw_len = len - button_len; // 滑动条实际要绘制的长度 SDL_Rect rect = {x, y, len, h}; if (SDL_PointInRect(\u0026uistate.mouse_position, \u0026rect)) { uistate.hot_item = id; if (uistate.active_item == 0 \u0026\u0026 uistate.mouse_down) { uistate.active_item = id; } } if (uistate.active_item == id) { value = (uistate.mouse_position.x - x)/(float)(draw_len)*(max-min)+min; if (value \u003c min) value = min; if (value \u003e max) value = max; } // 绘制 SDL_Color bg_color = {100, 100, 100, 255}; SDL_Color button_color = {50, 50, 50, 255}; SDL_Color board_color = {0, 0, 0, 255}; SDL_SetRenderDrawColor(render, bg_color.r, bg_color.g, bg_color.b, bg_color.a); SDL_RenderFillRect(render, \u0026rect); SDL_SetRenderDrawColor(render, board_color.r, board_color.g, board_color.b, board_color.a); SDL_RenderDrawRect(render, \u0026rect); int pos_x = x+(value-min)/(float)(max-min)*draw_len; SDL_Rect button_rect = {pos_x, y+2, button_len, button_len}; SDL_SetRenderDrawColor(render, button_color.r, button_color.g, button_color.b, button_color.a); SDL_RenderFillRect(render, \u0026button_rect); return EVENT_NOTHING; } 效果如下：\n自动生成的ID 每次增加控件都需要声明一个全局的ID，着很麻烦。接下来就编写一个自动生成ID的宏：\n1 2 3 4 5 #ifdef START_ID #define GEN_ID() (IDType)((START_ID)+(__LINE__)) #else #define GEN_ID() (IDType)(__LINE__) #endif 这个宏使用__LINE__获得行号，然后将行号变为ID。如果你定义了一个START_ID，我们将从START_ID处开始计数，这个START_ID可以有效避免其他模块的ID的重复。\n这个限制就是不能在一行内使用多次GEN_ID()，不过对于我们这种简单的足够了。\n按键的处理 最后我们尝试添加按键的处理。首先需要在UIState中增加有关成员：\n1 2 3 4 // 增加如下字段 IDType kbd_item; SDL_Keycode key; } uistate = {{0, 0}, false, 0, 0, 0, SDLK_UNKNOWN}; kbd_item记录了按键焦点所在的item。key则记录了当前按键。\n然后在游戏循环中注册一下新的成员：\n1 2 3 4 5 6 if (event.type == SDL_KEYDOWN) { uistate.key = event.key.keysym.sym; } if (event.type == SDL_KEYUP) { uistate.key = SDLK_UNKNOWN; } 这里要注意一个缺点：如果帧率低的话会导致按键的遗漏（因为我们是在事件循环外面处理的按键）。\n然后更改一下SlidBar（这里不打算给Button添加按键事件了）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const int move_step = 1; // 按下一次按键移动的数值 // 这里改成这样 if (uistate.active_item == id) { value = (uistate.mouse_position.x - x)/(float)(draw_len)*(max-min)+min; } if (uistate.kbd_item == id) { if (uistate.key == SDLK_LEFT) value -= move_step; if (uistate.key == SDLK_RIGHT) value += move_step; } if (value \u003c min) value = min; if (value \u003e max) value = max; 效果如下：\n结束 本文到这里就结束了，如果需要更多的控件你可以自己再去编写。可以看到IMGUI写起来是很快的，我也十分乐意在游戏中去使用它。\n所有的代码 下面是本文涉及的所有代码，只用到了SDL2，没有用到其他附加库。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 #include \u003ciostream\u003e #include \"SDL.h\" using namespace std; constexpr int WindowWidth = 800; constexpr int WindowHeight = 600; #ifdef START_ID #define GEN_ID() (IDType)((START_ID)+(__LINE__)) #else #define GEN_ID() (IDType)(__LINE__) #endif typedef unsigned int IDType; enum EventType { EVENT_NOTHING, EVENT_CLICK }; enum { ID_UNKONOW = 0, ID_ANY, ID_BUTTON1, ID_SLIDBAR1 }; struct UIState { SDL_Point mouse_position; bool mouse_down; IDType hot_item; IDType active_item; IDType kbd_item; SDL_Keycode key; } uistate = {{0, 0}, false, 0, 0, 0, SDLK_UNKNOWN}; EventType Button(SDL_Renderer* render, IDType id, int x, int y, int w, int h, SDL_Color, SDL_Color); EventType SlidBar(SDL_Renderer* render, IDType id, int x, int y, int len, int min, int max, int\u0026 value); void imgui_prepare(); void imgui_finish(); int value = 20; int main(int argc, char** argv) { SDL_Init(SDL_INIT_VIDEO|SDL_INIT_EVENTS); SDL_Window* window = SDL_CreateWindow(\"sdl imgui\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, WindowWidth, WindowHeight, SDL_WINDOW_SHOWN); SDL_Renderer* render = SDL_CreateRenderer(window, -1, 0); bool is_quit = false; SDL_Event event; while (!is_quit) { SDL_SetRenderDrawColor(render, 200, 200, 200, 255); SDL_RenderClear(render); imgui_prepare(); while (SDL_PollEvent(\u0026event)) { if (event.type == SDL_MOUSEMOTION) { uistate.mouse_position.x = event.motion.x; uistate.mouse_position.y = event.motion.y; } if (event.type == SDL_MOUSEBUTTONDOWN) { if (event.button.button == SDL_BUTTON_LEFT) { uistate.mouse_down = true; } } if (event.type == SDL_MOUSEBUTTONUP) { if (event.button.button == SDL_BUTTON_LEFT) { uistate.mouse_down = false; } } if (event.type == SDL_KEYDOWN) { uistate.key = event.key.keysym.sym; } if (event.type == SDL_KEYUP) { uistate.key = SDLK_UNKNOWN; } if (event.type == SDL_QUIT) is_quit = true; } EventType event = Button(render, ID_BUTTON1, 100, 100, 64, 40, {200, 0, 0, 255}, {0, 200, 0, 255}); if (event == EVENT_CLICK) { cout \u003c\u003c \"button clicked\" \u003c\u003c endl; } SlidBar(render, ID_SLIDBAR1, 100, 300, 300, 0, 100, value); cout \u003c\u003c \"slid \" \u003c\u003c value \u003c\u003c endl; SDL_RenderPresent(render); imgui_finish(); SDL_Delay(30); } SDL_Quit(); return 0; } EventType Button(SDL_Renderer* render, IDType id, int x, int y, int w, int h, SDL_Color color, SDL_Color press_color) { SDL_Rect rect = {x, y, w, h}; SDL_SetRenderDrawColor(render, color.r, color.g, color.b, 255); if (SDL_PointInRect(\u0026uistate.mouse_position, \u0026rect)) { uistate.hot_item = id; if (uistate.active_item == 0 \u0026\u0026 uistate.mouse_down) { uistate.active_item = id; } } if (uistate.active_item == id) SDL_SetRenderDrawColor(render, press_color.r, press_color.g, press_color.b, 255); SDL_RenderFillRect(render, \u0026rect); if (uistate.active_item == id) return EVENT_CLICK; return EVENT_NOTHING; } EventType SlidBar(SDL_Renderer* render, IDType id, int x, int y, int len, int min, int max, int\u0026 value) { const int h = 20; const int button_len = 16; const int move_step = 1; int draw_len = len - button_len; SDL_Rect rect = {x, y, len, h}; if (SDL_PointInRect(\u0026uistate.mouse_position, \u0026rect)) { uistate.hot_item = id; if (uistate.active_item == 0 \u0026\u0026 uistate.mouse_down) { uistate.active_item = id; uistate.kbd_item = id; } } if (uistate.active_item == id) { value = (uistate.mouse_position.x - x)/(float)(draw_len)*(max-min)+min; } if (uistate.kbd_item == id) { if (uistate.key == SDLK_LEFT) value -= move_step; if (uistate.key == SDLK_RIGHT) value += move_step; } if (value \u003c min) value = min; if (value \u003e max) value = max; SDL_Color bg_color = {100, 100, 100, 255}; SDL_Color button_color = {50, 50, 50, 255}; SDL_Color board_color = {0, 0, 0, 255}; SDL_SetRenderDrawColor(render, bg_color.r, bg_color.g, bg_color.b, bg_color.a); SDL_RenderFillRect(render, \u0026rect); SDL_SetRenderDrawColor(render, board_color.r, board_color.g, board_color.b, board_color.a); SDL_RenderDrawRect(render, \u0026rect); int pos_x = x+(value-min)/(float)(max-min)*draw_len; SDL_Rect button_rect = {pos_x, y+2, button_len, button_len}; SDL_SetRenderDrawColor(render, button_color.r, button_color.g, button_color.b, button_color.a); SDL_RenderFillRect(render, \u0026button_rect); return EVENT_NOTHING; } void imgui_prepare() { uistate.hot_item = 0; } void imgui_finish() { if (!uistate.mouse_down) { uistate.active_item = 0; } } ","description":"","tags":["SDL2"],"title":"用SDL实现IMGUI","uri":"/posts/%E7%94%A8sdl%E5%AE%9E%E7%8E%B0imgui/"},{"categories":null,"content":"本文介绍了如何使用宏自动创建序列化和反序列化函数的方法。\n吐槽 在C/C++中进行序列化向来是个令人头痛的事情。虽然有ProtoBuf的支持，但在编写小软件的时候还是不想使用庞大的ProtoBuf啊。语言本身不支持序列化的原因主要还是没有反射。虽然说可以手写编译期反射的代码，但是网上哪些花里胡哨的模板元编程代码我压根看不懂。。。\n不过我这两天找到了使用宏自动创建序列化函数的方法，使用被称为xmacro的技术。\n正文 什么是xmacro X-MACRO是一种可靠维护代码或数据的并行列表的技术，其相应项必须以相同的顺序出现。它们在至少某些列表无法通过索引组成的地方（例如编译时）最有用。此类列表的示例尤其包括数组的初始化，枚举常量和函数原型的声明，语句序列和切换臂的生成等。X-MACRO的使用可以追溯到1960年代。它在现代C和C ++编程语言中仍然有用。\nX-MACRO应用程序包括两部分：\n列表元素的定义。 扩展列表以生成声明或语句的片段。 该列表由一个宏或头文件（名为LIST）定义，该文件本身不生成任何代码，而仅由一系列调用宏（通常称为“ X”）与元素的数据组成。LIST的每个扩展都在X定义之前加上一个list元素的语法。LIST的调用会为列表中的每个元素扩展X。\n这些定义可能较为难懂，没得事，看下面实现序列化代码的方法自然就懂了。\n实现序列化 目标 我们的目标是，通过编写这一段宏定义：\n1 2 3 4 5 #define serialize_name Student #define serialize_body \\ field_string(name, \"VisualGMQ\") \\ field_int(age, 22) \\ field_double(height, 170.0) 编译器可以自动帮我们产生\n1 2 3 4 5 6 7 8 9 // 结构体的定义 struct Student { char* name = \"VisualGMQ\"; int age = 22; double height = 170.0; // 以及序列化函数（这里就先序列化成一个描述结构体的字符串，要想序列化为二进制原理是一样的） string Serialize(); }; serialize_tool.hpp 首先我们需要定义一些工具宏，用于帮助我们定义结构体内的成员:\n1 2 3 #define field_int(name, ...) #define field_double(name, ...) #define field_string(name, ...) 这些宏是空宏，因为下文中我们还需要覆盖这些宏的功能。\nserialize_achieve.hpp 在这个文件中我们来完成代码的生成部分。\n首先要想生成代码，用户必须提前定义表示结构体名称的serialize_name宏，以及结构体内部字段的serialize_body宏:\n1 2 3 #if !defined(serialize_name) || !defined(serialize_body) #error \"please include serialize_tools.hpp,then define your serialize_name, serialize_body,then include this file\" #endif 如果用户没有定义，直接报编译时错误。\n接下来就是xmacro发挥用途的时候了。xmacro其实就是通过不断地#undef和#define宏，让相同的宏在不同的地方展开成不一样的代码。\n首先我们需要对field_int(name, ...)类宏展开成int name = {__VA_ARGS__}，我们可以\n1 2 #undef field_int\t// 首先nudef掉serialize_tool.hpp中的定义 #define field_int(name, ...) int name = {__VA_ARGS__};\t// 给出新的定义 我们这边的确更改了field_int宏的含义，但是我们需要再一次使用serialize_body才能展开：\n1 2 3 #undef field_int #define field_int(name, ...) int name = {__VA_ARGS__}; serialize_body\t// 现在会将serialize_body宏内的所有field_int展开为变量声明。 其他的field_xxx同理。\n接下来我们需要将field_int(name, ...)展开成ss \u003c\u003c name 的情况，这里ss是stringstream的实例。\n1 2 3 4 5 6 7 string Serialize() { // 在函数内展开 stringstream ss;\t// 创建ss #undef field_int #define field_int(name, ...) ss \u003c\u003c #name \"=\" \u003c\u003c name \u003c\u003c endl;\t// 定义展开，这里#name会将name变为字符串。 serialize_body\t// 展开serialize_body内的所有field_int } 这样序列化函数就完成了，反序列化也是同样的道理。\n最后不要忘记#undef serialize_body和#undef serialize_name以及#undef field_int，以免下一次用户定义失败。\n完整的代码 serialize_tool.hpp:\n1 2 3 #define field_int(name, ...) #define field_double(name, ...) #define field_string(name, ...) serialize_achieve.hpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u003csstream\u003e #include \u003cstring\u003e using std::stringstream; using std::string; using std::endl; // 如果用户没有定义基本的描述宏，报错 #if !defined(serialize_name) || !defined(serialize_body) #error \"please include serialize_tools.hpp,then define your serialize_struct,then include this file\" #endif // 开始生成 struct serialize_name { // 生成变量声明 #undef field_int #define field_int(name, ...) int name = {__VA_ARGS__}; #undef field_double #define field_double(name, ...) double name = {__VA_ARGS__}; #undef field_string #define field_string(name, ...) double name = {__VA_ARGS__}; serialize_body // 生成Serialize函数 string Serialize() { stringstream ss; #undef field_int #define field_int(name, ...) ss \u003c\u003c #name \"=\" \u003c\u003c name \u003c\u003c endl; #undef field_double #define field_double(name, ...) ss \u003c\u003c #name \"=\" \u003c\u003c name \u003c\u003c endl; #undef field_string #define field_string(name, ...) ss \u003c\u003c #name \"=\" \u003c\u003c name \u003c\u003c endl; serialize_body return ss.str(); } }; // undef 所有的宏 #undef field_int #undef field_double #undef field_string #undef serialize_name #undef serialize_body 注意这两个文件都不要加#ifndef XX,#define XX这种防止重复包含的宏。因为这个文件就是要重复包含的。\n然后是使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 产生第一个结构体 #include \"serialize_tools.hpp\" #define serialize_name Student #define serialize_body \\ field_string(name, \"VisualGMQ\") \\ field_int(age, 22) \\ field_double(height, 170.0) \\ #include \"serialize_achieve.hpp\" // 产生第二个结构体 #include \"serialize_tools.hpp\" #define serialize_name Foo #define serialize_body \\ field_double(value, 32.0) #include \"serialize_achieve.hpp\" int main(int argc, char** argv) { Student student; std::cout \u003c\u003c student.Serialize(); Foo foo; std::cout \u003c\u003c foo.Serialize(); return 0; } 运行结果如下：\n1 2 3 4 5 name=VisualGMQ age=22 height=170 value=32 参考 文章-宏的高级用法：X-MACRO\n视频-C++编译期反射\n","description":"","tags":["cpp"],"title":"利用xmacro的序列化和反序列化","uri":"/posts/%E5%88%A9%E7%94%A8xmacro%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":null,"content":"C++17新出了filesystem库用于对文件和目录进行操作。在以前使用C++的时候，一旦遇到要遍历目录的操作都得用Unix函数，而且还必须考虑和Windows的兼容性，可以说C++在这一方面做的很差。但是C++17中的filesystem解决了这个问题。\n其CppReference在这里\n使用需要包含的头文件等 首先，如果你的编译器支持C++17的话，可以直接包含filesystem:\n1 #include \u003cfilesystem\u003e 官方存在以下说明：\n使用此库可能要求额外的编译器/链接器选项。 9.1 前的 GNU 实现要求用 -lstdc++fs 链接，而 LLVM 9.0 前的 LLVM 实现要求用 -lc++fs 链接。\n我的是clang 10.0.0，测试不需要连接库。\n如果你的编译器不支持C++17，或者由于某种原因总是用不了的话，可以使用Boost库中的filesystem。因为C++17的filesystem就是从Boost库中拿过来的，所以用法都一样（不过要安装Boost库）。\n要想使用filesystem，需要使用命名空间（Boost库可能不一样）\n1 using namespace std::filesystem; 为了方便，在下面的代码中我都会有这个语句：\n1 namespace fs = std::filesystem; 用fs命名空间代替std::filesystem。\n使用方法 大体上包含这些内容：\n类：表示路径的path类，表示文件实体的directory_entry类，以及用于遍历目录的directory_iterator和recursive_directory_iterator类 对文件操作的函数：创建文件，创建链接，删除文件，移动文件，拷贝文件，复制文件，重设文件大小等 对目录操作的函数：创建目录，删除目录等 得到文件系统信息的函数 首先来看类\n文件系统异常类filesystem_error 文件系统的所有函数，基本上只会抛出这种异常。\npath类 path类用于表示一个路径（不一定要是存在的，其本质上是存储着字符串然后对字符串进行各种操作，所以其实和文件系统毫不相干，也不会提供检查文件存在等）：\n1 fs::path p(\"./\");\t//当前路径 想要得知path表示的路径是否存在，使用fs::exists()函数：\n1 2 if(!fs::exists(p)) cout\u003c\u003cp\u003c\u003c\" exists\"\u003c\u003cendl; 使用operator/()可以合并两个path或者path和字符串（自动在两者之间添加分隔符）\ndirectory_entry类 通过传入一个path类对象，可以得到一个directory_entry类。这个类是和磁盘上文件或文件夹实体对应的类。\n通过成员函数exists()来判断是否存在对应的文件/文件夹实体。通过is_XXX系列函数判断其指向的类型：\n函数 用途 is_block_file 检查 directory_entry 是否代表阻塞设备 is_character_file 检查 directory_entry 是否代表字符设备 is_directory 检查 directory_entry 是否代表目录 is_fifo 检查 directory_entry 是否代表具名管道 is_other 检查 directory_entry 是否代表其他文件 is_regular_file 检查 directory_entry 是否代表常规文件 is_socket 检查 directory_entry 是否代表具名 IPC 接头 is_symlink 检查 directory_entry 是否代表符号链接 通过file_size()得到文件大小（不可对目录使用），使用hard_link_count()得到文件对应的硬链接大小，使用last_write_time()得到文件最后修改时间。使用path()获得表示的路径。\n如果在操作的时候目录内容改动了，通过refresh()来更新类对象的内容。\n遍历文件夹下的文件和文件夹 如果想要遍历的话，可以使用directory_iterator（用于单层遍历）或recursive_directory_iterator（用于递归遍历）。这里用递归遍历做例子：\n1 2 3 fs::recursive_directory_iterator rec_it(p); for(auto it=fs::begin(rec_it);it!=fs::end(rec_it);it++) cout\u003c\u003cit-\u003epath()\u003c\u003cendl; 可以通过传递path或者字符串来构建一个类对象。通过fs::begin()和fs::end()获得其迭代器，迭代器中包含的是对应目录下文件或文件夹的directory_entry对象。\n对目录的创建，删除，拷贝等 创建文件没有直接的函数，因为你完全可以通过标准IO操作来创建文件，其他的操作如下：\n函数 功能 copy 复制文件或目录 copy_file 复制文件内容 copy_symlink 复制一个符号链接 create_directory/create_directories 创建新目录 create_hard_link 创建一个硬链接 create_symlink/create_directory_symlink 创建一个符号链接 remove 移除一个文件或空目录 removeall 移除一个文件或递归地移除一个目录及其所有内容 resize_file 以截断或填充零更改一个常规文件的大小 ","description":"","tags":["cpp"],"title":"C++17 filesystem","uri":"/posts/c++17-filesystem/"},{"categories":null,"content":"在C++17中出现了一些新的库，分别是：\nstring_view variant filesystem charconv 工具库中新增加了any 数学特殊函数cmath（这个是老库，但是加了新功能） 本文只列出一些常用方法或概述，具体用法见cppreference。\nstring_view库 位于string_view文件中，用于给字符串提供一个视图。也就是说你可以通过这个类来观察一个字符串，但是却不能更改字符串。\n使用string_view的好处是在不复制字符串的情况下对字符串进行更好的观测。\n在C++17之前我们一直使用const string或者const char*,const char[]来实现此类功能。但是现在我们有更加安全的string_view。\nstring_view通过构造函数传入字符串来创建视图:\n1 2 3 4 5 6 7 8 char buffer[12] = \"hello world\"; string str = \"this is string\"; string_view view1(buffer), view2(str), view3(buffer, 10); //取前10个字符 cout\u003c\u003cview1\u003c\u003cendl; cout\u003c\u003cview2\u003c\u003cendl; string_view还提供迭代器来观测字符，迭代器的使用方法和其他的STL容器一样（采用begin(),cbegin(),rbegin(),crbegin()获得迭代器开头），甚至可以使用逻辑运算符来比较字符串。\n需要注意的是：由于是字符串视图，所以在构造string_view的时候并不会将字符串拷贝到string_view的内存中。string_view只是提供一个观测字符串的方法。所以要时刻注意string_view对象观测的字符串失效的问题。最典型的错误如下：\n1 2 3 string_view ToStringView(const string str){ return string_view(str); } 你也可以使用operator=来重新设置视图。对视图所做的所有事情均不会影响原字符串。\nvariant 定义于variant头文件中。用于取代union联合体。\nvariant的用途和union简直一模一样：可以存储多个值，但是每一读时刻只有一个值是有用的：\n1 2 3 4 5 6 7 8 9 variant\u003cint, float, bool\u003e v; //v里面可以有int,float,bool三种类型的值 v = 2; //赋予int值 v = false; //赋予bool值 v = 3.123f; //赋予浮点数，最后必须加f因为字面量不加f的话C++默认转换为double cout\u003c\u003cstd::get\u003cfloat\u003e(v)\u003c\u003cendl; //获得float类型，输出3.123 //cout\u003c\u003cstd::get\u003cint\u003e(v)\u003c\u003cendl; 会抛出std::bad_variant_access异常，因为此刻只有float值是有效的 cout\u003c\u003cstd::get\u003c1\u003e(v)\u003c\u003cendl; //通过序号获得float值（int-0, float-1, bool-2） //cout\u003c\u003cstd::get\u003c0\u003e(v)\u003c\u003cendl; 同理获得int是不行的 variant不允许有引用，数组或者void类型的成员。空的variant也不行（你可以用variant\u003cmonostate\u003e代替空）\nfilesystem filesystem用于文件系统。有了这个再也不用用系统API了。\n这个库比较奇怪，官方说头文件是filesystem，但是我在experimental/filesystem下找到了。然而却不能用（就算链接了stdc++fs都不行）。所以这个库我其实也没用过，但是我看官方文档还是很简单的，大家上cppreference看一看吧。\n需要注意的是有些编译器使用这个库需要另外链接库，LLVM是-lc++fs, GUNC是-lstdc++fs。\ncharconv 这个库是在int,float,double和字符串直接转换。\n我这里用不了这个库的函数，我的库里面将其删除了，所以大家cppreference吧。\nutility中增加的any any类用于存储一个任意类型，或者什么都不存。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 any a = 2; //直接赋值即可 //通过type()获得其typeid 通过any_cast\u003c\u003e来将a转换为固定类型（any本身不能直接输出） cout\u003c\u003ca.type().name()\u003c\u003c\" \"\u003c\u003cany_cast\u003cint\u003e(a)\u003c\u003cendl; a = 3.1415; cout\u003c\u003ca.type().name()\u003c\u003c\" \"\u003c\u003cany_cast\u003cdouble\u003e(a)\u003c\u003cendl; //cout\u003c\u003cany_cast\u003cint\u003e(a)\u003c\u003cendl; 不能将double强制转换为int，抛出bad_any_cast错误 a.reset(); //清空a里面的值 if(a.has_value()) //判断a是否有值 cout\u003c\u003c\"any has value\"\u003c\u003cendl; else cout\u003c\u003c\"any don't has value\"\u003c\u003cendl; /*输出 i 2 d 3.1415 any don't has value */ cmath中增加的特殊数学函数 cmath中增加了一些计算特殊数学函数的函数，比如圆锥曲线积分啊，黎曼函数什么的。咱也不是搞数学的，也看不懂。有想要了解的请自行cppreference吧。\n","description":"","tags":["cpp"],"title":"C++17新库","uri":"/posts/c++17%E6%96%B0%E5%BA%93/"},{"categories":null,"content":"本文介绍如何通过config_file和option给工程进行额外配置。\n首先把例子给出来：\n目录结构\n1 2 3 4 -include -config - config.hpp.in CMakeLists.txt 然后我们在config.hpp.in中编写：\n1 2 3 #cmakedefine PROJECT_VERSION_MAJOR 1 #cmakedefine PROJECT_VERSION_MINOR 2 #cmakedefine PROJECT_ROOT_PATH @PROJECT_SOURCE_DIR@ 然后我们在CMakeLists.txt中增加如下代码:\n1 2 3 4 5 config_file(config/config.hpp.in include/config.hpp) option(PROJECT_VERSION_MAJOR \"major version\" ON) option(PROJECT_VERSION_MINOR \"minor version\" ON) option(PROJECT_ROOT_PATH \"project root path\" ON) 然后我们cmake .，可以在include文件夹下看到出现了config.hpp:\n1 2 3 #define PROJECT_VERSION_MAJOR 1 #define PROJECT_VERSION_MINOR 2 #define PROJECT_ROOT_PATH ~/Documents 产生了三个宏，分别表示工程的主版本，副版本和工程目录。这样我们就可以在源代码中#include \"config.hpp\"来得到这些量了。\n实际上cmake给出了两个命令config_file和option来像这样产生一些宏用于配置工程。首先config_file()命令常用格式如下：\n1 config_file(srcfile dstfile) srcfile用于指定你编写的配置文件的路径（这里是config/config.hpp.in），dstfile则是在cmake命令后，这个文件会被解析到哪个地方。\n然后是配置文件的编写，使用#cmakedefine即可：\n1 2 3 #cmakedefine VAR1 //不给初始值，这样产生之后是#define VAR1 #cmakedefine VAR2 2 //给初始值2，产生#define VAR2 2 #cmakedefine VAR3 @VAR2@\t//给初始值VAR2也就是2，产生#define VAR3 2 这里要注意，如果你想要把变量赋值，使用@@而不是${}，而且在CMakeLists.txt文件中存在的变量也可以赋值哦（就像例子里面的PROJECT_SOURCE_DIR一样）。\n仅仅写完配置文件还不够，如果你不告诉cmake使用这些变量的话，cmake只会为你产出\n1 /*#undef VAR1*/ 这种代码。你需要使用option()命令告诉cmake启用哪一个：\n1 2 3 4 5 6 option(VAR1 \"这里是对变量的描述，必须有，不影响产生的文件\" ON)\t#使用ON表示启用，默认为OFF if(VAR1)\t#启用了之后cmake里面也可以使用哦 option(VAR2 \"this is var2\" ON) set(VAR2 4)\t#重新设置VAR2的值 endif(VAR1) option(VAR3 \"this is var3\" ON) 这样就会产生\n1 2 3 #define PROJECT_VERSION_MAJOR 1 #define PROJECT_VERSION_MINOR 4 #define PROJECT_ROOT_PATH ~/Documents 这种控制工程的方法很舒服，比如在我们制作游戏的时候，图像一般放在工程的resources目录下，但是在build的时候一般我们直接会cd build;cmake ..;./game这样执行，这样如果你在游戏中使用的路径是resources/xxx.png的话就会找不到文件，必须先退回工程根目录才能找到，很麻烦。我们这个时候就可以将图像路径写一个配置文件，然后改变源代码为相对路径，就可以不用返回上级目录直接run了。\n","description":"","tags":["cmake\u0026make"],"title":"CMake给工程编写配置文件","uri":"/posts/cmake%E7%BB%99%E5%B7%A5%E7%A8%8B%E7%BC%96%E5%86%99%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"本文介绍了如何跟着Vim官方的教程快速入门Vim。\n需要准备的东西：Vim\n汉化教程文档 首先我们要汉化Vim官方的教程文档，上vimcdoc来安装对应平台的汉化教程。\n开始阅读官方教程 首先打开vim。\n然后输入:help并按下回车，进入Vim的教程。如果vimcdoc安装成功的话，你应该会看到中文的帮助:\n然后仔细阅读当前显示在屏幕上的信息，这些信息教你如何移动光标，跳转和退出Vim。这些都是阅读官方教程所必须的。\n学会这些之后向下移动光标，直到你看到入门:\n在vimtutor标签上跳转（按下Ctrl-]），这样你就可以到Vim的官方30分钟入门教程了。\n学完入门教程之后，Vim基本上也就入门了。\n","description":"","tags":null,"title":"如何跟着官方教程入门Vim","uri":"/posts/%E5%A6%82%E4%BD%95%E8%B7%9F%E7%9D%80%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B%E5%85%A5%E9%97%A8vim/"},{"categories":null,"content":"这里是《Clean C++》（C++代码整洁之道）的笔记。比起《Clean Code》来说，本书更多地讲述了如何使用C++技术来达到“Clean Code”的方法，我觉得很值得参考。本书和这里的所有代码，例子均在C++11及其以后的标准下编写。\n单元测试 单元测试是已经不需要再重复强调的技术了。无论是不是用TDD开发方法，做单元测试都是保证代码质量的一种良好手段。尤其是对于我这种喜欢先随便写然后再重构的人，单元测试更是保证重构正确性的一道坚固屏障。\n简单来说，单元测试可以带来这些好处：\n测试即文档。在编写单元测试的时候，你其实也在编写文档。只不过这份文档是以代码的方式表示出来的。当别人不知道某个接口或者类的使用方法时，通过观看和运行单元测试可以很好地学习到这个接口或类的使用方法。由于单元测试取代了文档，所以就不需要再花时间在文档的编辑上，这也就意味着不需要维护文档。这可以节省很多的时间，让程序员更加关注内容。而且要比起文档来说，代码就是最精确的文档，因为文档可能会出错，但代码绝对不会。 有利于重构后的功能检查，可以更快检查出代码更改后的错误。重构是在开发过程屡次出现的事情。重构的核心是只改变代码结构，而不改变代码功能。想要知道你重构是否改变了功能是很难的。但是如果有单元测试，在重构后只需要转一遍单元测试看看有没有什么错误就可以了。免去了因为重构而不小心改变程序功能的不良后果。 提升程序员的自信心。你的程序通过单元测试了，说明你的程序在你的预期下运行，这样说明你的程序有保障，你基本可以毫无后顾之忧地去继续写代码，而不是在之后出bug时屡次怀疑以前的代码是否有bug。 能够促进产品开发。在TDD中，编写单元测试意味着你同时也在明确你的软件设计。 那么关于单元测试，有哪些要注意的地方呢？\n单元测试的覆盖面应该尽可能地大。显然，如果你的单元测试只测试了一小部分代码，那么上面的那些优点显然无法体现。\n单元测试的命名：单元测试的命名应当以单元测试的前提条件_单元测试的API名称_单元测试的预期后果这种格式来命名。虽然看上去很长，但是这样更加有利于你和你的朋友在第一眼看到单元测试时就明白他是什么意思，而不是通过一句一句地琢磨你单元测试里的语句来揣摩你的意思。比如giveTwoComplexNumber_add_theSumOfNumbers一看就知道是需要传入两个复数变量给add函数，add函数会将其相加后返回相加的值。\n不要对简单函数进行单元测试。比如大部分类的Getter和Setter方法。这些方法通常只由一两条语句构成，内容极其简单，简单到不需要做单元测试。为这些函数做单元测试没什么卵用，反而会耗费精力。但是，如果你的Getter和Setter方法真的很复杂，那还是有必要整一下单元测试的。\n不要对第三方库做单元测试。第一，给第三方库做单元测试应该是第三方库开发者的事情，不是你的事情。第二，第三方库的API太多了，为其做单元测试会很累（不过你要是通过做单元测试的方式来学习的话可以忽略这一条）。如果你不信任你的库，请找带有单元测试的第三方库，那种库可能更有质量保障。\n单元测试必须独立：千万千万不要出现一个单元测试依赖另一个单元测试的情况，每个单元测试都应当可以单独拿出来编译并运行。\n一个测试一个断言：一个单元测试中只有一个断言。这不仅有利于单元测试的独立性，而且能够更好地为测试找个好名字。\n不要在意这会带来很多单元测试文件的后果。比起代码整洁来说，多一些不耦合的文件不算什么。\n测试必须快速执行：由于一个测试一个断言，会导致你拥有很多单元测试。这些单元测试必须快速执行。你我都不会想在等待单元测试的编译过程上花费很多时间（毕竟对于我这种喜欢重构的人来说，每几十分钟转一次单元测试是常有的事情）。\n如何处理来自网络，数据库等IO的访问：网络和数据库的依赖一般来说都会让代码变得很麻烦。单元测试讲究小巧简单。这个时候我们可以使用伪对象(fake object)来帮助测试。\n譬如我的模块依赖关系是这样：\n但是这个时候我想要对AccountSystem做单元测试的话，不可避免的会引入SQLDatabase类。而操作数据库是一件即麻烦，又很花时间的事情（磁盘操作）。这个时候，我们需要先抽象出接口，然后通过继承接口来得到我们自己的fake对象：\n这样就可以放心地利用fake_db对象做单元测试了。\n原则 这里提出了一些编码方面的一般原则。\nKISS保持简单和直接原则 任何事情都应该尽可能简单。能够使用C++标准库做到的事情就尽量使用标准库去做，而不是自己从头造轮子。不要因为会用，就在代码中加入一些花里胡哨的技巧。这里很典型的例子就是过度设计和乱用设计模式。\nYAGNI不需要原则 现在不需要的东西就一定不要提前写。等到真正有需要的时候再编写。\n这是因为有的东西你觉得以后可能会用到，但是真实情况却是根本没有用到。这样就多出了无用代码，使得代码更加复杂，同时也破坏了KISS原则。\nDRY不重复原则 这个原则已经是耳熟能详的了。不要滥用复制黏贴（最好不用），尽量减少程序中的重复代码。确切地说是确保一个系统内部，任何一个知识点都只有一个权威的，单一的，明确的称述。\n最常见的是函数的问题。如果有两个或者多个函数中出现了类似的代码，这就需要将公共部分提取出来放到新函数里面：\n1 2 3 4 5 6 7 8 class Creature{ void SetPosition(int x, int y); //... }; class Wall{ void SetPosition(int x, int y); }; 像上面这种代码，可以通过继承避免重复的SetPosition函数：\n信息隐藏原则 如果一段代码调用了另一段代码，那么调用者不需要知道被调用者的内部实现。也就是说，所有的代码都需要隐藏自己的信息，将自己变为黑盒子。\n这个原则是模块化设计的基础。看一下书上关于门的例子：\nState是AutomaticDoor的内部enum。这样，每次调用AutomaticDoor的getState()方法时，都会有类似如下代码：\n1 2 3 4 5 AutomaticDoor door; AutomaticDoor::State doorState = door.getState(); if(doorState == AutomaticDoor::State::closed){ //... } 如果这时我们想要删除AutomaticDoor的State枚举，那么所有调用getState的代码都需要更改，这样调用者就产生了对被调用者(door.getState())的依赖。所以这里并没有进行信息隐藏。\n更好的做法是为每个动作都设计一个函数：\n高内聚和松耦合原则 各个模块的内聚性应当尽量高（即模块之间的耦合应该尽量低），模块不应当或者应当很少知道其他模块的具体信息。\n这个原则可以更好地帮助我们建立抽象结构。比如书上关于开关和灯的例子：\n这里toogle()函数通过调用lamp的on和off函数来在开关灯之间切换。\n这里的耦合在于，Switch类和Lamp类是紧耦合的。从单元测试的角度来看，Switch类显然不能够单独拿出来测试。因为Switch类知道Lamp的事情。\n这里的改进方法是使用抽象的类接口，屏蔽Lamp类的具体细节：\n这样，开关不仅能够打开台灯。如果以后还想打开电风扇的话，我们依然可以建立电风扇类继承Switchable接口。\n小心优化原则 不成熟和优化和过早优化会产生问题。\n首先，过早优化会违反YAGNI原则。\n其次，你认为需要优化的地方可能并不是性能瓶颈，你的优化带来不了多少性能的提升。这里建议使用Profiler等工具帮助你找到真正的性能瓶颈。\n最后，优化意味着可能引入bug。而且现代编译器已经非常擅长优化了，大部分优化的事情都可以交给编译器去做。\nPLA最少惊讶原则 在用户界面和API设计中，不要出现让用户和调用者感到惊讶的事情。函数应该完全按照函数名暗示的意义执行，比如一个Getter函数不应当拥有副作用。\n童子军原则 即反破窗原则。即不容忍破窗行为。只要看到不好的东西就立刻修复。一般这个原则会伴随着大量重构过程。\n代码整洁的基本规范 良好的命名 首先，虽然书上没有说，但是我认为每个人都需要对自己的代码进行编码规则的约束。如果还没有良好的编码风格的话，我推荐看看Google C++开源项目编码风格指南。\n下面是一些基本命名规范\n任何具有名称的东西，其名称都应该有意义和有表现力。\n所谓有意义是指不要起一些和其内容不相干的名称，比如给class Customer的全局实例对象起名为c这种。\n有表现力是指要尽量将名称对应的实体的作用表示出来。所以对于Customer全局实例的起名，可以是aCustom或者customer这种。\n名称应当可以自解释**。意思是说，当一个不知道这段代码的人第一次看见这段代码时，他可以从名称一下就知道这段代码的大致作用是什么，而不是去查看文档或者逐语句查看。\n使用领域中的名称。如果你在编写某一领域内的代码，你应当使用这一领域内的特定术语。这样可以让领域内的工作人员很快地了解代码功能。\n避免冗余的名称。举个栗子，你在Movie类中定义了一个GetterGetMovieName()。显然这里的Movie是冗余的（在Movie类里面的Get方法不是返回Movie的名称那是返回什么呢？如果你说我这里还有不同专辑(category)的名称，我需要GetMovieName()和GetCategoryName()两种方法，那只能说你的Movie类和Category概念耦合了，需要解耦）\n不要用晦涩难懂的缩写。显然，如果缩写不是人尽皆知的话，看代码的人还得去猜你的缩写是什么意思，这就违反了需要具有表现力这一规范。\n不要用匈牙利命名法或者前缀。第一，现代IDE很智能，你将光标往变量上一放就能知道变量类型，这意味着前缀是多余的。第二，拥有前缀意味着你必须维护前缀，即当你改变变量类型的时候，必须将变量的名称一起改变。\n避免相同名称用于不同目的。显然，同一名称所表示的内容不一样让人困惑。\n注释 这里有一些对注释的讨论\n尽量少地使用注释。好的代码可以自解释。多处注释意味着你需要花功夫维护注释。不正确的注释还会误导他人 不要为易懂的代码写注释。既然代码的功能不言自明，你还写啥注释呢。 不要通过注释禁用代码。第一，这会造成代码的整洁度下降。第二，一般来说，注释掉为了以后再用的代码，其实以后都没有用到过。所以这里的建议是直接删除，如果不想删除，请使用版本控制系统。当然，短暂的测试可以通过注释代码完成。所以这句话的含义应该是不要在提交的代码中存在通过注释禁用的代码。 不要写块注释。在一些源代码中，我常常看到将自己许可证写在代码头部的情况（比如SDL）。现在来说，这些注释并不具有法律效益，所以完全没必要写。如果想要版权，可以将许可证写在License.txt文件中。也不要使用块注释代替版本控制。 特殊情况下的注释是有用的，比如Doxygen的从源代码生成文档的注释。不过请只对公共API进行注释，而不是连私有函数和保护函数都注释。 函数 函数如何做到整洁？\n只做一件事。一个函数应当只做一件事。如果一个函数做的事情太多，应当将其分解为多个函数。一个函数做了太多事情的“坏味道”有如下：\n函数代码量贼多。 为函数命名时，不可避免地需要用到“和”，“或”这种词时。 函数体用空行将代码分割为几个片段，这意味着这些片段需要单独拿出来组成新函数。 包含了太多的if-else,switch语句 函数的入参比较多（一般建议少于3个） 这里我先拿一个我自己的例子出来说一下，请看下面代码片段：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 void buildRoom(int x, int y, int width, int length){ SDL_Color color = {255, 255, 255, 255}; // draw horizontal walls; for(int i=0;i\u003cwidth;i++){ Solid* solid = new Solid(Names::WALL_HORI); solid-\u003eSetPosition(x+i, y); solid-\u003eSetColor(color); worldmodel.RegistObject(solid); worldmodel.GetLayer()-\u003eAddObject(solid); solid = new Solid(Names::WALL_HORI); solid-\u003eSetPosition(x+i, y+length-1); solid-\u003eSetColor(color); worldmodel.RegistObject(solid); worldmodel.GetLayer()-\u003eAddObject(solid); } // draw vertical walls; for(int j=1;j\u003clength-1;j++){ Solid* solid = new Solid(Names::WALL_VERT); solid-\u003eSetPosition(x, y+j); solid-\u003eSetPosition(x, i); solid-\u003eSetColor(color); worldmodel.RegistObject(solid); worldmodel.GetLayer()-\u003eAddObject(solid); Solid* solid = new Solid(Names::WALL_VERT); solid-\u003eSetPosition(x, y+j-1); solid-\u003eSetPosition(x, i); solid-\u003eSetColor(color); worldmodel.RegistObject(solid); worldmodel.GetLayer()-\u003eAddObject(solid); } // draw ground for(int i=1;i\u003cwidth-1;i++) for(int j=1;j\u003clength-1;j++){ Ground* ground = new Ground; ground-\u003eSetPosition(x+i, y+j); ground-\u003eSetPosition(area.x+i, area.y+j); ground-\u003eSetColor(color); worldmodel.RegistObject(ground); worldmodel.GetLayer()-\u003eAddObject(ground); } } BuildRoom函数会生成一个房间，这个房间有竖直的墙，水平的墙和地面三种物体。具体的方式是将这些物体new出来，设置好属性，放入worldmodel中，最后由worldmodel进行绘制和运行逻辑。\n首先，这个函数太长了，有40多行。其次，这里的函数违反了“只做一件事”的规则。咋一看，函数的确是用来创造一个房间，但是创造房间分为三个步骤“创建竖直墙，创建水平墙和创建地面”。所以这个函数其实一次性做了三个事情。这样我们就需要将这函数分解。下面是分解后的函数声明：\n1 2 3 4 5 void BuildVertWall(int x, int y1, int y2, SDL_Color color); void BuildHoriWall(int y, int x1, int x2, SDL_Color color); void BuildGround(SDL_Rect area, SDL_Color color); void BuildRoom(SDL_Rect area, SDL_Color color); 这样BuildRoom的实现就变为这样：\n1 2 3 4 5 6 7 void BuildRoom(SDL_Rect area, SDL_Color color){ BuildHoriWall(area.y, area.x, area.x+area.w, color); BuildHoriWall(area.y+area.h-1, area.x, area.x+area.w, color); BuildVertWall(area.x, area.y+1, area.y+1+area.h, color); BuildVertWall(area.x+area.w-1, area.y+1, area.y+1+area.h, color); BuildGround(area, color); } 显然整洁多了。\n接下来我要举一个“函数参数不多于3个”的例子，那就是Vulkan的API。Vulkan的创建型API本身需要很多的参数，但是为了整洁，开发者将这些参数打包为结构体。也就是说，在调用函数之前需要配置函数所需的结构体，而结构体的成员其实就是函数所需要的参数。这种方法叫做参数打包。一般来说当参数很多的时候就可以使用参数打包。\n这是Vulkan创建Instance的一段代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //配置需要创建的Application的信息 VkApplicationInfo app_info = {}; app_info.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO; app_info.pNext = nullptr; app_info.pApplicationName = \"Hello World\"; app_info.applicationVersion = VK_MAKE_VERSION(1, 0, 0); app_info.pEngineName = \"No Engin\"; app_info.engineVersion = VK_MAKE_VERSION(0, 0, 0); app_info.apiVersion = VK_API_VERSION_1_0; //得到SDL给与Vulkan的拓展 unsigned int count; const char** names = nullptr; SDL_Vulkan_GetInstanceExtensions(window, \u0026count, names); //配置Instance创建信息 VkInstanceCreateInfo create_info = {}; create_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; create_info.pApplicationInfo = \u0026app_info; create_info.enabledExtensionCount = count; create_info.ppEnabledExtensionNames = names; create_info.enabledLayerCount = 0; //创建实例 VkResult result = vkCreateInstance(\u0026create_info, nullptr, \u0026instance); 其实最后一行的vkCreateInstance理应需要一大堆参数。但是通过参数打包，现在只需要三个参数。\n让函数尽可能小。一般来说一个函数理想情况下是45行，最多1215行。超过20行就需要考虑考虑是不是要分解了。不用担心函数调用的开销。CPU调用函数很快很快的（至少比起IO操作要快得多，大部分性能瓶颈其实都在IO上）\n函数命名应当以动词开头，并且使用容易理解的名称。\n避免使用标志参数。因为如果你存在函数CreateCreature(Property prop, bool flag)，那么在你调用的时候CreateCreature(prop, true), CreateCreature(prop, false)，其他人不能够一下看出这里的true,false有什么用。这样函数的清晰度就不够了（显然当你看到这个函数时，你也不知道这里的flag是个啥），而且也违反了单一职责原则。这时应该分解函数为两个：\n1 2 CreateCreatureWithClothes(Property prop) CreateCreatureWithoutClothes(Property prop) 这样就能一眼看出了。\n避免使用输出参数。首先，调用者不能很好地区分输出参数和输入参数。其次，使用输出参数不能够形成链式调用。如果一定要返回多个参数，建议将返回值打包，或者使用tuple（不推荐）。\n不要给予或者返回nullptr。\n返回nullptr意味着调用者需要对返回值进行判断，这意味着代码整洁度下降。 返回nullptr会给调用者造成迷惑，你说我得到一个nullptr后是应该终止程序呢，还是打一个log呢，还是该怎么滴。也就是说，你将函数造成的后果推给了调用者。 如果调用者忘记给nullptr判空，那程序就直接崩溃。 返回或者传递指针，还意味着需要考虑指针所有权：我传进去的指针，是函数给我释放内存还是我得自己释放内存呢？对于函数返回的指针也有同样的道理。这显然违背了信息隐藏原则。 简单的办法是返回/传递一个空对象。\nC++中的C代码 在用C++时，应该尽量减少C风格的代码。尽量去使用C++标准库的内容。包括但不限于：\n使用标准库容器而不是自己写C容器。这遵循了KISS原则。 使用static_cast代替强制转换，因为static_cast可以在编译器做类型检查，更加安全。 使用string替代char*字符串 避免使用printf,sprintf这种函数。C++中有相关的替代函数和类。 现代C++中的高级概念 使用智能指针进行资源管理 资源管理总是C/C++中的一个大问题。所幸在C++11中我们存在智能指针。通过智能指针，我们可以使用RAII（资源申请即初始化），他们会帮助我们管理资源。\nunique_ptr unique_ptr指针会将资源独占，任何的operator=，Move语义，拷贝构造都会让原有的资源占有者将资源转移给新的占有者。\nshared_ptr shared_ptr通过引用计数的方式共享资源。当使用operator=，拷贝构造时会将引用计数加一，从而得到共享的方式。当计数为0的时候会自动释放资源。shared_ptr的缺点就是不能够解决环指向的问题。\nweak_ptr weak_ptr需要和shared_ptr配合使用。当某个对象只是想临时地占有资源，而不想成为资源的所有者时可以使用。其需要一个shared_ptr对象进行构造，并且在使用资源之前必须使用expired()函数检测资源是否还有效。如果有效，需要使用lock()成员函数获得资源本身。\n由于拥有了智能指针，所以我们需要尽可能地避免使用显式的new和delete。因为内存泄漏很可能存在含有new和delete的代码中。我们应当尽量使用栈内存，或者使用智能指针，或者使用标准容器。\nMove语义 Move语义的出现改变了很多C++中的编程习惯，并且极大地增强了C++的效率。\n三大原则和五大原则，零原则 三大原则指的是：\n类需要显式定义其析构函数，且应该总是定义拷贝构造函数和赋值构造函数。\n醉着Move语义的引入，“总是定义移动构造函数和移动赋值构造函数”的条件加入了三大原则，变为了现在的五大原则。\n之所以存在五大原则，是因为编译器给出的关于拷贝和赋值的函数总是浅拷贝的，这会为某些需要深拷贝的类带来隐患。而析构函数的定义则提醒你释放类中的资源。\n然而，总是定义拷贝构造函数和赋值构造函数是很麻烦的事情，所以现在出现了零原则\n实现类的时候，应该不需要声明/定义析构函数，也不需要声明/定义 Copy/Move 构造其和 Copy/Move 运算符。使用智能指针和标准库来管理资源\n这意味着编译器提供的函数可以很好地执行。这一原则的背后是KISS原则。\n恰当的错误处理机制 涉及关于涉及错误处理的API时，我们需要考虑三个方面：\n前置条件：在函数或者类方法被调用前必须总为真，如果违反前置条件，函数调用的结果就难以保证。 不变式：函数调用过程中必须为真的条件。如果违反了，函数调用后会导致不正确或者不一致。 后置条件：函数执行结束后立即返回真。如果后置条件不成立，说明函数执行出错了。 接下来是四个异常保障级别，这部分也在《More Effective C++》中提到：\n无异常安全：就是不提供任何异常安全保障。代码永远不应该提供这个级别的保障！\n基本异常安全：指可以保证在函数调用过程中，以下几方面的安全：\n如果函数调用过程中发生异常，确保无资源泄漏 调用过程中发生异常，所有不变式不变 调用过程中发送异常，不会有数据和内存的损坏，并且所有的对象都是良好和一致的状态。但不能保证调用后数据不变 一般来说这个级别是默认的安全级别，每一份代码都应当实现。\n强异常安全：发送安全的情况下，数据内容需要恢复到函数调用前的状态，即需要回滚。\n这个类别的异常安全需要耗费开发者很多时间，除了在一些对异常严格要求的程序外，其他的不要求这一级别异常\n保证不抛出异常：显然，最完美的异常就是没有异常。一般来说，以下函数和操作都必须达到这一级别：\n类的析构函数 Move操作 默认构造函数 swap函数 如果没办法保证异常恢复，则发生异常后应该尽快退出以避免更大的损失。\n面向对象 类设计原则 让类尽可能小 类必须像函数一样尽可能小。如果你的类很大，那么大概率需要解耦或搭建更多的抽象层次。\n单一职责原则SRP 一个类应当有且只有一个职责\n类和函数，应当只做一件事情。如果类做了多个事情，我们应当将其分解\n开闭原则OCP 对拓展开放，对修改关闭\n一般来说，支持这一原则的方式是使用继承。通过继承，我们可以在不改变父类的前提下拓展父类的功能。\n里氏替换原则LSP 使用基类指针或基类引用的函数，必须在不知道派生类的情况下使用\n这意味着派生类必须能够完全替换基类。LSP原则提出了以下规则：\n基类的前置条件不能在派生类中增强 基类的后置条件不能在派生类中被削弱 基类的所有不变量，在派生类中都不能违反 历史约束：即派生类不能提供改变父类不可变量的API 这里书上给出了“矩形和方形”问题：\n假设现在我们需要一些形状来帮助我们在屏幕上绘制图像：\n现在我们需要一个正方形。显然，数学告诉我们，正方形是特殊的矩形，所以我们的第一直觉是将正方形继承于矩形：\n这里正方形给出了不变式:width=height，并且提供了新的方法setEdge()来同时设置width和height。\n但是这个显然不是一个好的方法。\n首先我们仍然可以在Square中使用Rectangle的setEdges方法，这个时候，setEdges方法的两个参数就会导致迷惑性：对于一个正方形，为什么要设置两个边长度呢？对于setWidth，setHeigh方法同样如此。\n那这个时候有人就说了：那我将setEdges,setWidth,setHeight方法变为virtual的，然后在Square中重写为不就行了：\n1 2 3 void Square::setEdges(int a, int b){ throw runtime_error(\"square can't set edges\"); } 这显然是不好的设计，因为这种方法是“子类试图删除父类功能”的一种方法。违反历史约束。\n最好的方法其实是不使用继承，而使用组合。（不要忘记：组合优先于继承）：\nSquare类的所有方法都由Rectangle类代理（其实这里也使用了代理思想）。这就是利用里氏替换原则的例子。\n接口隔离原则ISP 接口和接口之间应该互相隔离，类中不应该存在不应该包含的接口\n书上的例子是鸟类的例子：\n现在我们有这样一个设计：\n然后我们要加个企鹅类。但是要注意到企鹅虽然也属于鸟类，但是且不会飞。这个时候，Bird接口就存在多余的接口函数，我们需要将设计变为如下：\n这就是接口隔离\n依赖倒置原则DIP A.高级模块不应该依赖低级模块，两者都应该依赖于抽象\nB.抽象不应该依赖于细节，细节需要依赖于抽象\n这里的“高级模块”指需要其他模块提供功能的模块，“低级模块”是提供功能的模块\n一般来说，存在环依赖总是不好的。因为这会造成编译的不通过。但是我们可以通过依赖倒置来解决这个问题。\n我们首先有这样的环依赖：\n我们可以通过给B增加一个接口来解决这个依赖：\n这个时候，原来A对B的依赖变为了A对B父类的依赖。这就是依赖倒置。\n我们还能做到更好的依赖倒置：\n这完美地诠释了“细节依赖抽象”。\n迪米特法则（不和陌生人说话） 一个类只能调用其邻居类对象的API，而不应该尝试调用离他较远的对象的API\n比如，下面的例子就破坏了迪米特法则：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class A; class B{ public: A\u0026 GetA(){ return a; } void OpOnA(){ a.op(); } private: A a; }; class C{ public: void OpOnA(){ b.GetA().op(); } //这一行违反了原则 private: B b; }; B类的邻居是A，C的邻居是B。那么C就不应该直接使用A的对象，而应当通过B提供的方法去简介使用A对象。\n","description":"","tags":["cpp"],"title":"Clean C++笔记","uri":"/posts/clean-c++%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"为什么要使用PkgConfig 有时候某些第三方库没有提供Cmake的支持，没有办法使用find_package命令找到。这个时候就可以尝试使用pkg-config。大部分的第三方库都会支持pkg-config。\n使用方法 首先让CMake找到PkgConfig模块：\n1 find_package(REQUIRED PkgConfig) 然后通过PkgConfig模块找到你想要找到的第三方库，这里我找一下SDL2：\n1 2 3 4 5 pkg_check_modules(REQUIRED SDL2 SDL2_image SDL2_ttf SDL2_mixer) pkg_search_module(SDL2 REQUIRED sdl2) pkg_search_module(SDL2_image REQUIRED sdl2_image) pkg_search_module(SDL2_mixer REQUIRED sdl2_mixer) pkg_search_module(SDL2_ttf REQUIRED sdl2_ttf) pkg_check_modules可以一次性检查所给的所有模块是否存在。\n接下来再使用pkg_search_module找到对应的模块。第一个参数是prefix，第二个参数我填了REQUIRED表示找不到就报错，第三个参数就是模块名字。\n找到之后，我们可以使用如下变量来得到模块信息：\n\u003cprefix\u003e_FOUND：如果找到模块，此变量为1 \u003cprefix\u003e_LIBRARIES：模块的链接库名称（不包含-l） \u003cprefix\u003e_LINK_LIBRARIES：模块的链接库名称（包含绝对路径） \u003cprefix\u003e_LIBRARY_DIRS：模块的链接库路径（不包含-L） \u003cprefix\u003e_INCLUDE_DIRS：模块的头文件路径（不包含-I） \u003cprefix\u003e_LDFLAGS：链接flags \u003cprefix\u003e_LDFLAGS_OTHER：额外的链接flags \u003cprefix\u003e_CFLAGS：所有的编译器cflags \u003cprefix\u003e_CFLAGS_OTHER：其他的编译器cflags 这里我这样写，以让我的工程得以编译：\naux_source_directory(src SRC) set(SRC ${SRC} main.cpp) include_directories(include ${SDL2_INCLUDE_DIRS} ${SDL2_image_INCLUDE_DIRS} ${SDL2_mixer_INCLUDE_DIRS} ${SDL2_ttf_INCLUDE_DIRS}) link_directories(${SDL2_LIBRARY_DIRS} ${SDL2_mixer_LIBRARY_DIRS} ${SDL2_ttf_LIBRARY_DIRS} ${SDL2_image_LIBRARY_DIRS}) link_libraries(${SDL2_LIBRARIES} ${SDL2_image_LIBRARIES} ${SDL2_mixer_LIBRARIES} ${SDL2_ttf_LIBRARIES}) ","description":"","tags":["cmake\u0026make"],"title":"CMake中使用PkgConfig","uri":"/posts/cmake%E4%B8%AD%E4%BD%BF%E7%94%A8pkgconfig/"},{"categories":null,"content":"这里介绍如何在Mac下使用IntelliJ来开发Adnroid程序。因为自己已经安装了IDEA了，所以就不打算再安装Android Studio了。\n第一步：下载安卓的SDK（使用sdkmanager） 要想开发安卓程序，必须首先下载安装安卓的SDK。这里我选择使用sdkmanager来安装。\n下载sdkmanager 首先到这个网站去下载（是国内的镜像网站，会快很多）。\n下载好之后解压出tools文件夹，放到你喜欢的地方，并且将环境变量PATH设置为tools文件夹的根目录和/bin目录，其中bin目录下面就有我们的sdkmanager.\n安装安卓SDK和其它工具 现在可以使用sdkmanager来安装安卓工具了。首先使用sdkmanager --list来查看现在可以安装的工具:\n这里Installed packages代表你已经安装的工具或SDK，Avaliable Packages代表可以安装 的工具。\n如果你只是使用IDEA+Java/Kotlin开发的话，那么只安装SDK就可以了，向下拉会看到以platforms打头的包：\nplatforms;android-10 | 2 | Android SDK Platform 10 platforms;android-11 | 2 | Android SDK Platform 11 platforms;android-12 | 3 | Android SDK Platform 12 platforms;android-13 | 1 | Android SDK Platform 13 platforms;android-14 | 4 | Android SDK Platform 14 platforms;android-15 | 5 | Android SDK Platform 15 platforms;android-16 | 5 | Android SDK Platform 16 platforms;android-17 | 3 | Android SDK Platform 17 platforms;android-18 | 3 | Android SDK Platform 18 platforms;android-19 | 4 | Android SDK Platform 19 platforms;android-20 | 2 | Android SDK Platform 20 platforms;android-21 | 2 | Android SDK Platform 21 platforms;android-22 | 2 | Android SDK Platform 22 platforms;android-23 | 3 | Android SDK Platform 23 差不多这样的，就是代表Android的SDK版本（每一个系统对应一个SDK），想要安装的话直接sdkmanager \"platforms;android-17\"即可（注意这里的双引号不能少，包名替换成你自己想要的包名）。然后sdkmanager就会帮你自动安装了。\n如果你想要使用C++的话还需要安装ndk，自己在sdkmanager --list里面找就行了。\n第二步：在IDEA中导入安卓配置 首先打开IDEA，在欢迎界面点这个：\n然后就会进入这个界面，点击左侧菜单栏的SDKs，然后点击+创建一个Android SDK配置：\n这个时候会弹出一个对话框让你选择SDK的位置。SDK是安装在tools同名的文件夹下，在platform里面。但是我们要选择tools和platforms所在文件夹，这样IDEA会自动找到这个文件夹下的所有SDK和sdkmanager，方便以后自动配置:\n然后你就可以选择你的SDK进行开发了：\n选好点击OK完成配置。\n第三步：开发安卓应用 这个时候再点击IDEA的create new project，并且选择Android即可开始开发。\n创建工程之后，在第一次配置可能会遇到这种错误：\nERROR: The newly created daemon process has a different context than expected. Java home is different. Expecting: '/Applications/IntelliJ IDEA CE.app/Contents/jdk/Contents/Home' but was: '/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home'. Please configure the JDK to match the expected one. Open JDK Settings 解决办法是关掉这个工程，然后再IDEA欢迎界面点击Import Project来导入你的安卓工程，在导入的时候会让你选择gradle，一定点击Use default gradle wrapper，然后OK即可：\n第四步安装安卓模拟器 到了这一步之后会发现没有办法转安卓模拟器。这个时候你需要安装插件genymotion，只需要在Reference-\u003ePlugin里面查找并安装即可。安装完毕后就可以创建和使用安卓模拟器了\n","description":"","tags":null,"title":"Mac下如何在IntelliJ上开发Android","uri":"/posts/mac%E4%B8%8B%E5%A6%82%E4%BD%95%E5%9C%A8intellij%E4%B8%8A%E5%BC%80%E5%8F%91android/"},{"categories":null,"content":"C++11提供了很多的随机数生成器，可以使用均匀分布，正态分布等方法进行随机。\n要想生成随机数，请包含random头文件\nC++11的随机数生成比C语言要麻烦，也好用地多。主要有以下概念：\n随机数生成器：用来生成随机数的类，相比于C语言，C++通过提供不同的随机数生成器来提供不同的随机数生成算法，让用户对随机数生成的底层算法有更好的选择。 随机数分布：用于按照一定的分布来产生随机数。本质上是通过限定或修改随机数生成器产生的随机数来得到结果的，所以需要一个随机数生成器。 一般来说，得到一个随机数的方式如下：\n首先得得到一个随机数生成器 [可选] 然后可以采用随机数引擎适配器来对生成器进行一些操作 最后将生成的随机数传入随机数分布来得到随机数。 比较典型的过程如下：\n1 2 3 4 5 default_random_engine engin; //得到一个随机数生成器 engin.seed(time(nullptr)); //传入种子 uniform_int_distribution\u003cint\u003e dist(1, 10); //得到一个随机分布 for(int i=0;i\u003c100;i++) cout\u003c\u003cdist(engin)\u003c\u003cendl; //随机分布利用随机数生成器生成随机数 随机数生成器 所谓的随机数生成器，其实就是生成随机数的底层算法。\n所有的随机数生成器都是要传入种子的，使用成员函数seed(t)即可传入，或者在构造时传入也行。\n一般预定义的随机数生成器用的比较多。\n随机数生成引擎 是一些通过特定算法生成随机数的类，一共有三个\nlinear_congruential_engine:实现线性同余算法 mersenne_twister_engine:实现梅森缠绕器算法 subtract_with_carry_engine:实现带进位减（一种延迟斐波那契）算法 这些类都是模板类，其模板参数是要生成的随机数类型和算法需要的一些参数（具体见cppreference)\n随机数引擎适配器 用于和随机数引擎搭配使用的适配器类，主要是修改引擎随机出来的随机数，一共有三个：\ndiscard_block_engine：舍弃随机数引擎的某些输出 independent_bits_engine：将一个随机数引擎的输出打包为指定位数的块 shuffle_order_engine：以不同顺序将随机数引擎的结果输出 都是模板类，其模板参数的第一个是随机数引擎的类型，其他的则是需要的参数。\n预定义的随机数生成器 这里定义了一些包装了比较流行的算法包的生成器，这里仅举例一些常用的：\nmt19937：32位梅森缠绕器算法 mt1993_64：64位梅森缠绕器算法 default_random_engin：默认随机数生成器 一般的用法如下：\n1 2 3 random_device d;\t// random_device下面会介绍 mt19937 m(d()); //初始化生成器 cout\u003c\u003c mt19937() \u003c\u003cendl; //产生一个随机数 非确定随机数生成器 可以说是真正意义上的随机数（不过具体的还是得看实现，Linux下是通过读取/dev/urandom文件来实现随机的，这就是真正的随机数。而Window则是偷懒直接使用rand_s()函数，这就还是伪随机数）\nrandom_device：非确定随机数生成器 一般由于random_device产生随机数的能力很强，我们一般用其产生的随机数当做其他随机数生成器或引擎的种子。\n随机数分布 通过限定或者修改随机数生成器的结果来达到一定程度的分布。所以一般参数都需要有一个随机数生成器。\n下面列举一些常用的：\nuniform_int_distribution/uniform_real_distribution：产生一个在区间*[a,b]*上的均匀随机数（分别产生整数和浮点数） binomial_distribution：二项分布 poisson_distribution：泊松分布 normal_distribution：正态分布 一般的用法如下：\n1 2 3 4 random_device d; mt19937 m(d());\t//先得到一个随机数生成器 uniform_int_distribution dist;\t//然后得到一个随机数分布 cout \u003c\u003c dist(m) \u003c\u003cendl;\t//将生成器传入分布，得到最后的随机数 ","description":"","tags":["cpp"],"title":"C++11随机数生成器","uri":"/posts/c++11%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":null,"content":"C++11为了表示时间，新增加了chrono库。这是一个比原本C库更加好用的时间表达库。 想要使用chrono，请包含chrono头文件并且使用命名空间chrono。\n一个最基本的例子 首先我们来通过一个基本的例子学习chrono库的操作，现在我想要测量下面这个函数运行的时间:\n1 2 3 4 5 void fillGreen(Window* window){ for(int i=0;i\u003cwindow-\u003ew;i++) for(int j=0;j\u003cwindow-\u003eh;j++) window-\u003epixel[i*window-\u003ew+j] = MakeRGB(0, 255, 255); } 首先，我们需要得到函数运行之间的时间：\n1 chrono::steady_clock::time_point start = chrono::steady_clock::now(); steady_clock是一个稳定时钟，最适用于测量时间，所以我们用这个时钟。它是一个静态类，直接通过其静态函数now()（也是唯一一个函数）以获得当前的时间点。\n注意now()返回的是时间点，而不是C语言通常意义上的时间。时间点用time_point模板类表示。\n所以我们的返回值是一个steady_clock::time_point类型，表示是steady_clock的时间点类型（不同的时钟时间点不一样，后面会说道）。\n然后我们可以如法炮制，得到函数运行后的时间:\n1 2 3 chrono::steady_clock::time_point start = chrono::steady_clock::now(); fillGreen(window); chrono::steady_clock::time_point end = chrono::steady_clock::now(); //得到运行后的时间 接下来我们需要得到经过的时间，方法是将两个时间点相减：\n1 chrono::duration\u003cfloat\u003e durationSeconds = end - start; 这里需要用一下常识：时间点和时间点相减，显然代表经过的时间段。时间段使用duration模板类表示，其模板参数为时间段秒数的数据类型。这里使用浮点型。\n最后我们输出经过的时间：\n1 cout \u003c\u003c durationSeconds.count() \u003c\u003c endl; 通过count()可以得到经过的秒数。\n深入chrono 从上面的例子中，我们可以得知chrono时间库的基本概念：\n时间点time_point：用于表示一个时间点 时间段duration：用于表示一段时间 时钟：时钟有三个，都是静态的 system_clock：系统时钟，通过调用其now()函数来得到当前系统时间 steady_clock：稳定时钟，最适用于测量时间间隔 high_resolution_clock：高精度时钟。不推荐使用，理由是不跨平台，而且通常的实现就是system_clock或者steady_clock。 接下来我们更加深入地看一看这些概念\n时钟 时钟的精确定义是：\n时钟由起点（或纪元）及计次频率组成。例如，时钟可以拥有 1970 年 1 月 1 日的纪元，和每一秒的计次。\n简单来说，时钟首先需要一个起点，比如1970年1月1日凌晨12点整。然后由于是时钟，需要计时的嘛，还得给一个计次频率，就是隔多长时间时钟的指针动一下。我们日常生活以秒计，那么计次频率就是1秒。而有些时候你可能需要以15分钟计，或者30分钟计，那计次频率就是15分钟或30分钟。\nchrono不允许我们定义时钟，我们只能用其定义的两个时钟之一（high_resolution_clock不做说明）。这些时钟都是静态类。\nsystem_clock 定义如下：\n大多数系统上，系统时间可以在任何时候被调节。它是唯一有能力映射其时间点到 C 风格时间的 C++ 时钟。\n不指定 system_clock 的起始时间，但多数实现使用 Unix 时间（即从协调世界时 (UTC) 1970 年 1 月 1 日星期四 00:00:00 开始的时间，不计闰秒）。\n注意，这是唯一有能力映射时间点到C风格(time_t类型)的C++时钟，这意味着steady_clock没办法做到和C时间相互转换。\nsystem_clock的计次频率不同机器不一样，一般都是一纳秒或者几纳秒。\n通过其now()函数得到当前的时间点，返回值类型为system_clock::time_point。\n例子-获得当前时间点：\nchrono::system_clock::time_point time = chrono::system_clock::now(); cout\u003c\u003ctime.time_since_epoch().count()\u003c\u003cendl; 注意这里的第二行获得时间的方式，time_point模板类可以通过time_since_epoch()的方式得到从时钟起始时间到当前时间点经过的时间间隔。这里其实就是返回系统当前的时间，和C语言的time()一样（而且比C语言还精确）。\n其和C语言时间转换通过其静态函数to_time_t()和from_time_t()实现。\nsteady_clock steady_clock是不随着系统时钟改变的时钟，最适用于记录时间间隔的时钟。\n意思就是说，在你使用steady_clock的使用修改了系统时间，这个时钟的结果是不会受到影响的。\n其只有一个静态方法now()用于得到当前时间点。\n时间点time_point 类模板 std::chrono::time_point 表示时间中的一个点。它被实现成如同存储一个 Duration 类型的自 Clock 的纪元起始开始的时间间隔的值。\n简单来说，time_point一般内含一个duration。\n现在我们来看一下其模板声明：\n1 2 3 4 template\u003c class Clock, class Duration = typename Clock::duration \u003e class time_point; 可以看到，其有两个模板参数，分别是时间点对应的时钟的类型，和时钟对应的时间段类型。所以不同的时钟是拥有自己的时间点的，不同时钟之间的时间点不能相互转换。\n使用time_since_epoch可以得到时钟起始时间到当前时间点之间的时间段。\n时间段duration 通过时间点之间的加减法（也没有其他运算法则），我们可以得到时间段。其模板定义如下\n1 2 3 4 template\u003c class Rep, class Period = std::ratio\u003c1\u003e \u003e class duration; 它由 Rep 类型的计次数和计次周期组成，其中计次周期是一个编译期有理数常量，表示从一个计次到下一个的秒数。\n存储于 duration 的数据仅有 Rep 类型的计次数。若 Rep 是浮点数，则 duration 能表示小数的计次数。 Period 被包含为时长类型的一部分，且只在不同时长间转换时使用。\n简单来说，Rep表示了计次数这个数据的类型，而Period则代表计次周期。如果你的Rep是int，那么duration只能记录一个计次周期，两个计次周期。若为float，则可以记录1.5个计次周期。\n所以可以看到，不同的时钟和时间点对应的时间段也不一样。同类型的时间段存在四则运算和自增，自减运算。不同时间段之间可以使用duration_cast()转换函数来转换。\n通过count()函数得到其记录的时间（实际是计次周期的计数）。\nchrono还给出了一些常用duration的typedef:\n1 2 3 4 5 6 std::chrono::nanoseconds\tduration\u003c/*至少 64 位的有符号整数类型*/, std::nano\u003e std::chrono::microseconds\tduration\u003c/*至少 55 位的有符号整数类型*/, std::micro\u003e std::chrono::milliseconds\tduration\u003c/*至少 45 位的有符号整数类型*/, std::milli\u003e std::chrono::seconds\tduration\u003c/*至少 35 位的有符号整数类型*/\u003e std::chrono::minutes\tduration\u003c/*至少 29 位的有符号整数类型*/, std::ratio\u003c60\u003e\u003e std::chrono::hours\tduration\u003c/*至少 23 位的有符号整数类型*/, std::ratio\u003c3600\u003e\u003e 总结 其实不需要自己定义时间点和时间段，但是深入理解他们的实现方式，有助于我们了解不同时间段和时间点之间的转换关系。\n","description":"","tags":["cpp"],"title":"C++11日期与时间🕒","uri":"/posts/c++11%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4/"},{"categories":null,"content":"这里记录了Java文件IO和控制台IO的使用方法。\nIO类图 IO分为两种：字节流和字符流。字节流就是每次读取以字节为单位。字符流就是每次读取都以字符为单位。\n字节流 所有的字节流IO的父类都是InputStream和OutputStream。\n字符流 所有的字符流的IO的基类全都是Reader和Writer。\n将IO流应用于控制台输入输出 输入 对于InputStream，其最重要的接口方法就是read()，那么我们可以这样写：\n1 2 3 4 5 6 7 8 9 InputStream stream = new DataInputStream(System.in); int a = 0; try { while ((a = stream.read()) != -1) { System.out.print((char) a); } } catch (IOException e) { e.printStackTrace(); } read()方法会返回当前读取的数据长度（0~255），没有数据返回-1.\n输出 输出的话我们有System.out.print()系列函数。\n将IO流用于文件 File类 首先我们需要有一个描述文件的类，就像C/C++文件句柄一样。File类就是这样一个类。可以给它一个路径来创建一个文件句柄:\n1 File file = new File(\"~/Documents/program\"); 但是这个类不会自己判断文件或者文件夹是否存在，你可以使用exists()函数判断。它还有很多其他实用的函数，比如getAbsolutePath()得到给定的路径的绝对路径，或者调用createNewFile()或者mkdir()来创建位于此路径的文件和文件夹。\n文件IO 有了File类，我们再对照上面的图，可以看到我们可以使用FileInputStream类对文件读，FileOutputStream对文件写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 File file = new File(\"./test.txt\"); if (!file.exists()) try { file.createNewFile(); } catch (Exception e) { e.printStackTrace(); } try { OutputStream ostream = new FileOutputStream(file); char[] b = { 'h', 'e', 'l', 'l', 'o' }; for (char c : b) ostream.write((int) c); } catch (Exception e) { e.printStackTrace(); } try { InputStream istream = new FileInputStream(file); int i = 0; while ((i = istream.read()) != -1) System.out.println((char) i); } catch (Exception e) { e.printStackTrace(); } } 这里先写文件再读文件。\n或者你也可以使用字节流，用法都一样，只不过换一个类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 File file = new File(\"./test.txt\"); if (!file.exists()) try { file.createNewFile(); } catch (Exception e) { e.printStackTrace(); } try { OutputStreamWriter ostream = new FileWriter(file); ostream.write(\"hello\"); ostream.flush();\t//这里使用flush表示立刻写入，不然可能再下面读取的时候还没有写入。 } catch (Exception e) { e.printStackTrace(); } try { InputStreamReader istream = new FileReader(file); char[] buffer = new char[10]; istream.read(buffer, 0, 10); System.out.println(buffer); } catch (Exception e) { e.printStackTrace(); } ","description":"","tags":["Java"],"title":"从C++到Java:IO","uri":"/posts/%E4%BB%8Ec++%E5%88%B0java_io/"},{"categories":null,"content":"这里记录了Java容器的使用\n和C++ STL一样。Java也带有了很多的容器，使用方法也很简单。\n容器之间的关系 要搞懂C++容器，首先要知道容器之间的关系，下面是各个容器的继承图：\n可以看到这个关系非常错综复杂。上面的大部分都是接口和抽象类，只有少部分的实体类。这些实体类就是我们要用到的。\n总体来说，容器分为两种：以Collection为根的容器和以Map为根的字典。\n容器的使用 其实容器的使用也很简单，严格按照图上的关系来使用就可以了。比如如果你想要使用线性表，你可以ArrayList\u003cInteger\u003e alist = new ArrayList\u003c\u003e();，或者List\u003cString\u003e alist = new ArrayList();都可以哦。然后就可以更具不同的容器进行不同的操作了。\n具体的各个容器的使用参考廖老师的教程\n","description":"","tags":["Java"],"title":"从C++到Java:容器","uri":"/posts/%E4%BB%8Ec++%E5%88%B0java_%E5%AE%B9%E5%99%A8/"},{"categories":null,"content":"这几天在复习Java，就顺便写一下C++和Java的区别，顺便记录一下如何从C++快速转到Java\nJava相较于C++的区别 首先Java不用为内存分配考虑了，自带垃圾回收的Java让你再也不用delete内存。\n然后Java取消了多继承，但是也可以通过接口实现多继承。\nJava没有重载运算符。。。\n好吧因为我不是专门学Java的，所以给我最大的感觉就是第一条：不用内存分配😂挺爽的，其他的我感觉没啥区别，都一样用😂。\n基础语法 Hello World 首先不打破老规矩，来一份Hello World:\n1 2 3 4 5 6 7 8 9 //HelloWorld.java package com.VisualGMQ; //import java.io.*; public class HelloWorld{ public static void main(String[] args){ System.out.println(\"Hello World\"); } } 这里来看一下Java和C++语法上的区别：\n第一行package语句：\n比起C++，Java可以更加灵活地控制自己的工程代码层级。package是包命令，这一行表示我现在的这个HelloWorld.java文件在com/VisualGMQ文件夹下。也就是说如果你的工程根目录在~/Documents下，那么你的这个文件就在~/Documents/com/VisualGMQ/HelloWorld.java。\n第二行被注释掉了，但同时展现了两个点：\n注释：和C++一模一样。以//表示行注释，以/** **/表示块注释 import语句：由于你可以用package来打包你的java文件，那么相应的你也可以通过import来引入文件，相当于C++的#include。这里引入的是Java标准IO，载入了Java_installation/java/io/文件夹下所有Java文件。 第五行的类声明：\n和C++一样类由class声明，不同的是类前面可以加上访问修饰符，这里public表示这个java文件是对所有工程，包括其他工程可见的（包外可见）。一个源文件只能有一个public类。类最后不需要加分号（结构体，枚举后面都不需要）。\n需要注意的是：Java的main函数所在的文件名称必须和类名一致。\n第六行main函数的声明：\n函数的声明也和C++一样（Java里习惯叫函数为方法），只不过每个方法前面都需要加上访问修饰符表示方法的访问权限（不加表示包内访问）。这里的public表示其他包可以访问。\n这里的String[] args其实和int argc, char** argv一样，只不过Java里面用String表示字符串，数组有length变量可以得到数组大小，所以没必要加上int argc，最后就简化成这样了。\n第七行System.out.println()是Java的控制台输出函数，println是print line的简写，也有我们熟悉的printf函数：System.out.printf()。\n为什么main函数要写在类中？🤔\n因为Java遵循万事万物皆对象的说法，不允许将方法或者变量（Java习惯称字段）的声明暴露在类外。当我们运行Java的时候，其实是Java虚拟机JVM调用HelloWorld.main()函数。在Java中，一切都是在类中运作的。\n变量的声明 普通变量 普通变量和C++一样，但是要注意一下基本数据类型的名称变化：byte,short,int,double,long,float,boolean,char，其中byte是表示8位字节的数据类型（也是整数类型中的一份子），取值-128~127。\nNull还是nullptr? 答案是都不是，Java为了表示空，定义了自己的类型null，千万别搞混了。\n静态变量 使用static\n常量 和C++不一样，使用final：\n1 2 3 final int a = 10;\t//直接赋值 final int a; a = 20;\t//延迟赋值 数组 数组就比较特殊了，需要使用new关键字创建：\n1 2 3 4 5 6 7 8 int a[] = new int[4]; int[] a = new int[4]; //方括号放在前面后面都可以，但是里面不能有东西 int[] a = {1, 2, 3, 4}\t//初值列初始化，不需要new int[] a; a = new int[4];\t//延迟初始化，在需要的时候使用new，在初始化之前a=null 这代码简直就像C++中利用指针创建数组：\n1 int* a = new int[4]; new一般是用来实例化类对象的，可能Java也将数组视为对象了吧。因为数组有length字符安可以得到数组的大小:\n1 int len = a.length; 二维数组也差不多：\n1 2 3 4 5 6 7 8 9 10 int[][] a = new int[2][3]; //也可以像指针一样，先new一维，再new剩下的 int[][] a = new int[2][];\tfor(int i=0;i\u003ca.length;i++) a = new int[3]; /*这里可以想象这段代码是这样的: int** a = new int[2]; for(int i=0;i\u003c2;i++) a[i]=new int[3]; */ delete呢？ Java中没有delete这种东西，因为根本不需要。\n在你使用new在内存中分配内存之后，Java虚拟机JVM会使用垃圾回收机制，在对象不再需要的时候自动回收内存。妈妈再也不用担心我没有delete了。\nArrays类 Java的java.util.Arrays类是一个静态类（所有的类成员都是静态的），专门用于对数组操作，比如Arrays.sort()用于排序，Arrays.fill()用于向数组里填充元素等。\n类的实例化 类的实例化也是使用new：\n1 String str = new String(\"haha\");\t//在new之后调用构造函数 和C++不一样的是，如果你调用的是默认构造函数，也得加上括号：\n1 2 String str = new String;\t//Error! String str = new String();//Right! 同样JVM会帮你回收内存，不需要delete\n函数（方法）声明 和C++一模一样，只是要注意方法前面的访问修饰符。\n传值还是传引用？ 由于Java将指针概念隐藏了起来，导致我们没有办法使用指针，那么就带来一个问题：函数参数什么时候传值，什么时候传引用呢？其实和Python差不多：\n八种基本数据类型都是传值的；数组，类，接口等其他数据类型是传引用的。\n那么这个时候就有人要问了：那我要将基本数据类型传引用岂不是无法？那也不是。Java给每个基本数据类型一个对应的类，称为闭包，只要你使用其相应的类对象传值就可以了。\n闭包 每一个基本数据类型对应的类称为闭包，比如int对应Integer，char对应Character。所有的闭包名称都是基本数据类名称的全称，并且首字母大写：\n1 2 3 4 5 6 7 8 int - Integer byte - Byte short - Short long - Long char - Character double - Double float - Float boolean - Boolean 每个闭包都可以通过传递基本数据类型来构造,并且也都可以像原本类型一样进行操作:\n1 2 Integer i = new Integer(i); i=i+2; 但是不能将不兼容类型放入来构造:\n1 Integer i = new Integer(3.3f);\t//不能将float传给int的闭包 强转的方法 Java的开发者很痛恨C/C++中使用(double)value;这种强制转换方式，所以在Java中一律去掉了这种转换法则。而且还规定，不同类型的数据之间不能相互转换。\n比如boolean就不能和数类(int, float等)转换。而作为最基础的整型提升还保留了下来（就是说int可以隐式转换为float这种）。\n如果想要转换的话，必须构建对应类型的闭包，使用闭包的方法转换:\n1 int i = new Double(3.3).intValue(); 一般转换的方法都是\u003ctype\u003eValue()格式。\n条件判断 和C++一模一样，都是短路的，不说了。\n循环结构 和C++一模一样，就是for循环多了一种foreach循环（Java8新增）：\n1 2 3 4 int[] a = {1, 2, 3, 4}; for(int i : a){ System.out.println(i); } 其实和C++11的foreach也一样，只不过Java中没有auto关键字，所以你必须显式地写上变量类型。\n枚举类型 和C++一样，使用enum关键字。但是由于Java的关系，没有办和和数型之间相互转换。而且枚举类型本身也属于类，所以在同一个文件中不能同时有public enum和public class。\n包 所谓包，其实如果你学过Python的话就非常好理解了，就像是Python里面的包一样，通过文件夹来将源代码分层。\n包的路径不使用/或者\\作为分割，而是.，也就是说，如果你的工程根目录在~/Documents，那么你的com.VisuaGMQ包就在~/Documents/com/VisualGMQ。\n使用package可以告诉Java当前文件在哪个包中，package语句必须是在代码的第一行 。\n再举个例子，如果你使用的是C++，那么你可能要这样管理你的工程：\n1 2 3 4 5 6 7 8 9 10 11 -MapEditor_Project -include - MapEditor.hpp -common - header.hpp - structs.hpp -src - MapEditor.cpp -common - structs.cpp - main.cpp 然后你得在MapEditor.cpp中写上#include \"include/MapEditor.hpp\"（假设你没有改变头文件搜索路径），在structs.cpp中写#include \"include/common/structs.hpp\"最后在main.cpp中以同样的方式包含你要的头文件。\n但是在Java中，你可以这样:\n1 2 3 4 5 6 7 -MapEditor_Project\t//Java文件可不分什么头文件源文件哦 -src - MapEditor.java - Main.java -common - header.java - structs.java 然后你得在MapEditor.java, Main.java中写package src;，在header.java, structs.java中写package src.common;，然后在Main.java中使用import src.common.header;来引用header.java文件(注意不能直接使用import common.header;必须指定包的全路径)\n实际上，包和C++的namespace一样开辟了新的命名空间，不同的包在不同的命名空间内，所以不同包内的类可以重名。\n访问修饰符 由于所有字段和方法都必须在类里面，所以先了解一下访问修饰符。\n和C++一样，存在public protected private三种访问修饰符关键字。但是访问权限却有四个，因为不写访问修饰符也是一种访问权限——包内访问\n注意不能在类前加protected\npublic让其他包的代码可以访问这个包内的类和方法。\nprotected不能让其他包访问这个包内的信息，同一个包内也不能访问，类内可访问，并且继承下去之后仍然是protcected。\nprivate包外包内都不能访问，继承之后仍为private。\n不写（默认）访问权限是包内访问，其他的包不能访问，同一个包可以相互访问。\n面向对象 类 使用class声明，类内的方法和字段全部必须加上访问修饰符，类末尾不需要分号：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Person{\t//包内可见 public Person(int age, String name){ this.name = name;\t//使用this来指代类中的字段和方法 this.age = age; } public String GetName(){ return name; } public String GetAge(){ return age; } public String toString(){\t//特殊方法 return name+\"'s age is \"+String(age); } public boolean IsMale(){ return isMale; } private String name; private int age; private boolean isMale = false; } 和Python一样，Java没有重载运算符，为了弥补这个缺陷，Java保留了一些特殊函数，这些函数有一定的作用，你可以重写来实现自己的功能，最常用的就是toString()方法，他会在类被输出的时候自动调用这个方法：\n1 2 System.out.println(new Person(\"VisualGMQ\", 20)); //输出VisualGMQ's age is 20 可能你已经注意到了第17行。在Java中，所有的变量都可以在声明时直接赋值，如果没有赋值，对象会是null，基本数据类型会是0，boolean变量会是false。\n构造函数 构造函数和C++一样的意义，没给构造函数的时候会默认给个空的。\n析构函数？ 有析构函数函数吗？没有，不过如果你硬要有一个的话，可以参考finalize()函数。\n继承 继承的话使用extends关键字：\n1 2 3 class Child extends Person{\t//等价于C++的 class Child:public Person //... } 没错你没办法像C++一样控制继承的权限，也就是说你每次继承都是public继承。\nJava取消了多继承，这意味着extends后面只能跟一个类名。\n所有类的基类 和Python一样，Java有着万类之根的类Object，这个类主要有一些RTTI的处理和定义toString()方法。任何不继承的类默认继承Object。\n无法继承的类 在类前面加上final可以防止类被继承，如果继承了会报编译时错误。\n重载 和C++一样，注意重载是不能改变访问权限的，比如你的方法在父类是public，到了子类必须仍然是public，不然会报编译时错误。\n在重载中如果想要调用父类的方法，需要使用super关键字，super关键字代指当前类的父类:\n1 2 3 4 5 6 7 8 9 class Child extends Person{ Child(String name, int age){ super(age, name);\t//调用父类的构造函数 } public String GetName(){ super.GetName();\t//调用父类的对应方法 } } 虚类 使用abstract来声明虚类和虚方法，如果一个类中有一个虚方法，那么这个类必须冠以abstract:\n1 2 3 4 5 6 7 abstract class Action{ public Action(){ System.out.println(\"Action!\"); } public void ShakeHands(); public void Bow(); } 接口 当虚类只有虚函数，没有字段的时候就变成了接口：\n1 2 3 4 public interface Action{ void ShakeHands();\t//接口的方法必须是public的，写不写都一样 void Bow(); } 接口使用interface关键字声明。和类的区别在于：接口的方法不能被实现。其实接口就是C++中没有成员变量的纯虚类。\n但是和C++纯虚类一样，嘴上说着不能实现函数，其实还是可以实现的，但是你要冠以default关键字:\n1 2 3 public default void ShakeHands(){ System.out.println(\"shake\"); } 这样如果你不想实现这个函数，就是使用这个默认函数。\n实现接口 接口可以被实现：\n1 2 3 4 5 6 7 8 9 class Child extends Person implements Action{ public void ShakeHands(){ System.out.println(\"child is shake your hand\"); } @Override\t//注解，可以不加，加了表示下面的函数是被重载的 public void Bow(){ System.out.println(\"Bow\"); } } 使用implements来实现接口，后面可以跟多个接口。所以我们可以通过接口来实现多继承。\n实现接口必须将接口所有的方法全部实现。这里推荐使用@Override注解，他可以帮你辨别方法是否是被重写的，以方便在编译时找出重写错误。\n静态方法和字段 当然是使用static来实现了。但是别的类在使用的时候，不是用::而是使用.:\n1 2 3 4 5 6 7 8 9 class Person{ static int PersonNum = 0; } class CalculatePerson{ public int calcu(){ return Person.PersonNum; } } 注解 注解是个新东西，详见廖雪峰老师的博客\n异常 处理异常 格式和C++一模一样：\n1 2 3 4 5 6 7 try{ //捕获异常 }catch(Exception e){ //处理异常 }finally{ //可选，不管异常出不出现都执行的代码块 } 但是Java中有一个至今我都感觉很烦的事情：如果一个方法可能会抛出异常（其方法体内有throw语句），那么你必须在使用这个方法的时候捕捉异常，不然会有编译时错误（除了RuntimeException,Error及它们的子类）。\n所以你常常会看见Java中存在大量的try..catch块，严重影响代码美观。\n一般而言Error是不需要捕获的严重异常（你就算写了try_catch块也不用对其进行处理），如果碰到了整个程序适合直接挂。Exception应当是可处理的异常。\n抛出异常 创建异常类 要抛出异常，你可以使用系统的异常类，或者自己创建。方法是继承Throwable类并且改写其中的方法(一般可以改写toString()方法以便找到错误所在)。\n而且你的函数内可能抛出什么异常，你就需要使用throws关键字指定函数要抛出什么异常：\n1 2 3 4 5 6 public void throwException(int type) throws IOException, NullPointerException{ if(type==1) throw new IOException(); else throw new NullPointerException; } 而且你不能写出这样的代码:\n1 2 3 4 public void throwException(int type) throws IOException, NullPointerException{ throw new IOException(); throw new NullPointerException; } 这样Java会认为一个函数不能同时抛出两个异常而给出编译时错误。\n使用throw抛出异常 这个很显然了，和C++一样：\n1 throw new Exception(); 断言 使用assert断言，会抛出AssertException。\n1 assert 1==false; 日志打印 Java自带了java.util.logging模块可以打印日志，或者你可以下载使用广受好评的第三方模块log4j。\n泛型 泛型的声明 和C++一样Java也拥有泛型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //泛型类 class Pair\u003cT1, T2\u003e{ public Pair(T1 value1, T2 value2){ first = value1; second = value2; } public T1 first; public T2 second; } //泛型接口 public interface Iterator\u003cT\u003e{ T next(); boolean hasNext(); } //泛型方法（在非泛型类中的方法或者静态方法） public static \u003cT\u003e void Function(T value){ //... } Java中免去了template这种关键字。泛型类和泛型接口直接在名称后面加上\u003cT1,T2,...\u003e即可，泛型方法则是在返回值前加上范型。\n而且要注意的是：静态方法是不受类的泛型类型影响的，也就是说你不能这样写：\n1 2 3 4 5 class A\u003cT\u003e{ public static void Say(T msg){ System.out.println(msg); } } 必须要将静态方法变为泛型方法才行:\n1 public static \u003cT\u003e void Say(T msg){} 当然这里的T和泛型类的T已经不是一个东西了。\n泛型的使用 1 2 Pair\u003cInteger, String\u003e pair = new Pair\u003c\u003e(21, \"ads\");\t//new后面的泛型可以不加，编译器会推导 Function\u003cString\u003e(\"abs\");\t//泛型方法的使用 泛型的继承 和C++一样：泛型类可以继承泛型类，非泛型类只能继承泛型类的特化类。也就是说可以这样写：\n1 2 3 4 5 class A\u003cT\u003e extends B\u003cT\u003e{ } class C extends B\u003cInteger\u003e{ } 需要注意的是泛型类型必须是类类型，导致这种情况是因为泛型擦除。\n泛型擦除及其他 泛型擦除的内容很多，参考廖雪峰老师的博客。extends和super通配符也一并参考。\n","description":"","tags":["Java"],"title":"从C++到Java:基本语法","uri":"/posts/%E4%BB%8Ec++%E5%88%B0java_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"这里通俗易懂地一步一步理解KMP算法。\nKMP算法 KMP算法是字符串匹配中必须掌握的快速匹配算法。给定一个字符串S1，和一个字符串S2，要求从S1中找到第一个匹配的S2的位置。即在S1中寻找字串S2第一次出现的位置。\n算法的基本思想是这样的（这一部分可以观看天勤的公开课，讲得很好）：\n假设存在ABBABBABABAAABABAAA这个串S1，要求从中找到子串S2：ABBABAABABAA，首先将串和串对齐，从第一位开始寻找：\n1 2 3 4 5 6 p1 | ABBABBABABAAABABAAA ABBABAABABAA | p2 P1指针指向S1的开头，P2指向S2的开头，然后P1和P2逐个向后移动，直到发生不匹配的情况：\n1 2 3 4 5 6 p1 | ABBABBABABAAABABAAA ABBABAABABAA | p2 这个时候，按一般的方法是将P1回到第二个位置，P2回到S2首部，P1和P2对齐后继续下一次匹配：\np1 | ABBABBABABAAABABAAA ABBABAABABAA | p2 但是KMP算法为了效率，不会这样简单地回溯。这里我们看一下P2指针之前的字符串：\nABBAB KMP的核心思想就来了：KMP会在P2指针的前面的字符串中找到相同的最长前缀和后缀。\n前缀是指在一个字符串中，从字符串开头到除了字符串结尾的所有字符串集合。也就是说，对于ABBAB，其前缀集合为${A, AB, ABB, ABBA}$。\n后缀是和前缀相对的概念，从字符串中间某个字符开始（不能是首字符），到字符串末尾的所有字符串的集合。对于ABBAB，后缀为${BBAB, BAB, AB, B}$\n然后KMP算法找出相同且最长的前缀和后缀，这里显然是AB。记录下其长度，长度为2。\n然后将P2移动到S2头部后公共前后缀长度的地方即可。这里长度为2，所以需要从S2头部往后移动2位：\np1 | ABBABBABABAAABABAAA ABBABAABABAA | p2 这样就不必回溯P1到第二位，P2到S2开头了。匹配效率大大增加。\n然后继续匹配直到发生不匹配字符：\np1 | ABBABBABABAAABABAAA ABBABAABABAA | p2 然后看P2前面的字符串ABBABA找到最长相等前后缀的长度，这里前后缀为A，长度为1，那么P2移动到距离S2开头1个长度的地方：\np1 | ABBABBABABAAABABAAA ABBABAABABAA | p2 这个时候S2的末尾已经超出S1了，显然匹配失败。\n如果没有失败，就一直按照这个方法进行下去，直到找到了字串或失败。\n初版的KMP算法 现在再来回头看一下上面的方法，其核心思想如下：\n假如现在遇到了不匹配字符串，记$l$为P2之前字符串的最长相同前后缀的长度，那么我们需要将P2移动到下标$l$处，即可开始新的匹配。\n由于P2在任意位置时，P2之前的字符串（其实就是S2的前缀）的最长相同前后缀的长度是一定的，在比较时不会发生改变的，所以我们可以预先求出所有的长度，存放在数组里面。对于这里的S2，我们的数组元素为：\nA B B A B A A B A B A A -1 0 0 0 1 2 1 1 2 1 2 1 第一个元素之所以为-1，是因为如果第一个元素就不匹配，那么P2不应当回溯，而应当和P1一同向后移动一个字符，所以这里给出了一个特殊值（当然你也可以直接判断P2是否为0，但是不推荐这样做，因为下文有依赖于这个-1的算法）。\n第二个元素恒为0，因为如果P2指向第二位就出错了，那显然P2只能回溯到0位置。你也可以理解“因为当P2=1时，P2前面的字符串只有一个字符，一个字符的字符串是没有前缀和后缀的，所以前缀后缀长度为0”。\n这个数组我们暂时称为dst数组吧，dst意味着距离S2开头的距离。\n那么这个时候我们就能写出KMP算法了，其实主要的难点就是求dst数组：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e //求dst数组 void GetNextArr(const char* s, int* dst, int len){ dst[0] = -1; dst[1] = 0; for(int i=2;i\u003clen;i++){ for(int j=0;j\u003ci-1;j++){ int comp1 = 0; int comp2 = i-j-1; for(;comp1\u003c=j;comp1++,comp2++) if(s[comp1]!=s[comp2]) break; if(comp1==j+1) dst[i] = j+1; } } //输出dst数组,以方便人工确认 for(int i=0;i\u003clen;i++) printf(\"%3d\", dst[i]); printf(\"\\n\"); } int KMP(const char* s1, const char* s2){ int p1 = 0, p2 = 0; int len1 = strlen(s1), len2 = strlen(s2); int* dst = (int*)malloc(sizeof(int)*len2); //得到dst数组 GetNextArr(s2, dst, len2); while(p2!=len2 \u0026\u0026 p1-p2+len2\u003c=len1){ //当s2还未超出s1的长度时，进行匹配 if(s1[p1]==s2[p2]){ //如果当前匹配的话，直接检查下一个字符 p1++; p2++; }else{ //如果不匹配，移动p2或者p2 p1一起移动 if(dst[p2]==-1){ p2++; p1++; }else p2 = dst[p2]; } } free(dst); //如果超出则匹配失败 if(p1-p2+len2\u003elen1) return -1; //否则返回匹配位置 return p1-p2; } int main(int argc, char** argv){ char buffer1[64] = {0}; char buffer2[64] = {0}; printf(\"input S1:\"); scanf(\"%s\", buffer1); printf(\"input S2:\"); scanf(\"%s\", buffer2); printf(\"result:%3d\\n\", KMP(buffer1, buffer2)); return 0; } 这样第一版本的KMP算法就完成了。\n这里的dst数组在KMP中被称为next数组，意思是S2应当向后移动\"已匹配长度-next[P2]\"个长度。也就是说我们得到这个公式： $$ P2 -= P2-next[P2]=next[P2] $$ 和我们上面思考的一样，所以也就不需要改动了。\n但是教科书上一般将next数组的第一个元素下标记为1，这个时候代码可能就需要进行相应的改动。不过我在编写代码的时候实在是想不明白空一个next[0]出来是要干嘛，简直浪费空间。所以我这里就直接以next[0]为首元素存储了。\n更加快速的计算next数组的方法 KMP算法的时间复杂度是O(m+n)，其中m是计算next数组的事件，也是S2的长度，而n则是S1的长度。n的来历很清楚：在匹配的过程中只用了一次i到n的循环。但是我们这里构造next数组的时间复杂度显然不止m，所以显然KMP算法中有更加好的计算next数组的方法。\n为了理解更快的算法，我们再来看一遍next数组的生成：\ncomp1 p2 | | A B B A B A A B A B A A | comp2 当P2=2时，comp1指针要和comp2指针进行比较，这个时候由于s2[comp1]!=s2[comp2]，所以next[p2]=0。\n然后P2向后移动，comp2向后移动：\ncomp1 p2 | | A B B A B A A B A B A A | comp2 这个时候本来要进行两次比较：\n假设前缀和后缀的长度均为1：这个时候comp1=0,comp2=2，然后我们发现s[comp1]!=s[comp2]，所以这种情况否定。 假设前缀和后缀长度均为2：这种情况是不可能的，因为在p2=2时，我们就知道s[0]!=s[1]，所以这种情况其实可以直接跳过。 也就是说，这一轮我们直接比较s2[comp1]是否等于s2[comp2]即可。\n然后P2向后移动，comp2向后移动：\ncomp1 p2 | | A B B A B A A B A B A A | comp2 这个时候分三种情况：\n假设前缀和后缀长度为1：这个时候s2[comp1]==s2[comp2]，所以next[p2]=1 假设前缀和后缀长度为2：不可能，因为如果长度为2，意味着我们需要比较s2[0],s2[2]，但是在p2=3时已经否定了这种情况。 假设前置和后缀长度为3：不可能，因为如果长度为3，一位置需要比较s2[0],s2[1]，这在p2=2是已经否定了。 然后P2向后移动，由于comp1比较成功了，所以向后移动，comp2向后移动：\ncomp1 p2 | | A B B A B A A B A B A A | comp2 这个时候由于我们已经知道s2[comp1]==s2[comp2]了，所以我们只需要判断s2[comp1]?=s2[comp2]即可。如果成功，我们可以得到长度为next[p2-1]+1。这里显然可以，所以next[p2]=next[p2-1]+1。\n这里我们不需要判断前后缀长度为1的情况，因为前后缀长度为2的情况已经成立了。我们也不需要判断前后缀为3，4的情况，因为p2=2,p2=3时就已经帮我们否定掉了。\n然后P2向后移动，comp1，comp2向后移动：\ncomp1 p2 | | A B B A B A A B A B A A | comp2 这个时候我们应当先判断s2[comp1]?=s2[comp2]，因为前后缀大于3的情况已经确定了，而如果前后缀长度为3的情况确定了，我们也就不用判断前后缀长度为2和1的情况了。\n这里显然B和A不一样。那怎么办？这里KMP算法中提出了很精妙的思想，在这种情况下会执行这个代码：\n1 comp1 = next[comp1]; 将comp1按照next值进行回溯。\n这里的道理是这样：\n其实比较前后缀的本质是字符串查找，即在s2[1:p2-1]（comp1当做指针）中找到s2[0:n]（comp2当做指针），使得n尽可能大。那么在匹配发生不了的时候怎么快速地进行下次匹配呢？显然KMP已经给了我们答案：让comp1根据next数组回溯。所以这里就有了这个代码。\n所以整个过程就比较简单了：comp1和comp2持续地向后移动并比较。如果s2[comp1]和s2[comp2]不相等，则根据next[conp1]回溯comp1，再次进行比较。如果还不行，则再次回溯。\n所以整个代码可以改成这样：\n1 2 3 4 5 6 7 8 9 10 11 12 void GetNextArr2(const char* s, int* next, int len){ int comp1 = -1; int comp2 = 0; next[0] = -1; while(comp2\u003clen-1){ if(comp1==-1 || s[comp1]==s[comp2]){\t//如果现在s[comp1]==s[comp2]，表示出现了最大值 next[++comp2] = ++comp1; }else{ comp1 = next[comp1]; } } } 这也是KMP中最让人摸不着头脑的代码。\n最终版本的KMP 最后改进获得next数组的函数后，我们得到最终的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e void GetNextArr(const char* s, int* next, int len){ int comp1 = -1，comp2 = 0; next[0] = -1; while(comp2\u003clen-1){ if(comp1==-1 || s[comp1]==s[comp2]) next[++comp2] = ++comp1; else comp1 = next[comp1]; } } int KMP(const char* s1, const char* s2){ int p1 = 0, p2 = 0; int len1 = strlen(s1), len2 = strlen(s2); int* dst = (int*)malloc(sizeof(int)*len2); //得到dst数组 GetNextArr(s2, dst, len2); while(p2!=len2 \u0026\u0026 p1-p2+len2\u003c=len1){ //当s2还未超出s1的长度时，进行匹配 if(s1[p1]==s2[p2]){ //如果当前匹配的话，直接检查下一个字符 p1++; p2++; }else{ //如果不匹配，移动p2 if(dst[p2]==-1){ p1++; p2++; }else p2 = dst[p2]; } } free(dst); //如果超出则匹配失败 if(p1-p2+len2\u003elen1) return -1; //否则返回匹配位置 return p1-p2; } int main(int argc, char** argv){ char buffer1[64] = {0}; char buffer2[64] = {0}; printf(\"input S1:\"); scanf(\"%s\", buffer1); printf(\"input S2:\"); scanf(\"%s\", buffer2); printf(\"mathcing...\\n\"); printf(\"result:%3d\\n\", KMP(buffer1, buffer2)); return 0; } 参考 天勤公开课\n","description":"","tags":null,"title":"KMP算法详解","uri":"/posts/kmp%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"coc.vim的补全有三种lsp：clangd, ccls, cquery。这里说明如何使用ccls补全。\nccls的配置 ccls是lsp(language server Protocal)（语言补全协议）中的一个，用于补全C/C++\n下载ccls ccls的GitHub地址在这里,你可以从源码下载并编译。\nMacOSX Mac下使用brew可快速安装:\n1 brew install ccls 配置ccls为补全插件 ccls官方提供了很多方法，这里我说明如何使在coc.nvim中进行补全。 打开VIM，输入:CocConfig后回车可打开coc的配置文件，然后输入:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"languageserver\": { \"ccls\": { \"command\": \"ccls\", \"filetypes\": [\"c\", \"cpp\", \"cuda\", \"objc\", \"objcpp\"], \"rootPatterns\": [\".ccls-root\", \"compile_commands.json\"], \"initializationOptions\": { \"cache\": { \"directory\": \".ccls-cache\" }, \"client\": { \"snippetSupport\": true } } } } } 即可配置完成。\n一些快捷键 在函数或变量上按shift+K可以显示函数或变量的原型。\n如何找到自定义头文件并补全 小程序的情况下使用.ccls 如果你的程序足够小，可以通过在工程根目录下编写.ccls文件来让ccls找到自己的头文件。 .ccls中的每一行都是一个编译指令:\n1 2 -Iinclude -std=c++11 但是注意不能够在里面使用``执行命令。\n然后每次打开vim，ccls都会检车这个文件，并且根据这个文件进行补全配置。\nMacOS的特殊情况 在MacOS下，ccls没办法找到系统头文件，这个时候你必须自己编写.ccls文件，在文件中加入如下内容帮助ccls找到头文件:\n-isystem /usr/local/include -isystem /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1 -isystem /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.1/include -isystem /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include -isystem /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk/usr/include 工程的情况下使用compile_commands.json 如果你使用的是大工程的话，可以考虑编写compile_commands.json文件：\n1 2 3 4 5 6 [ { \"arguments\": [\"c++\", \"-Iinclude\", \"-std=c++11\", \"main.cpp\"], \"file\": \"main.cpp\" } ] arguments通过将编译指令各个部分拆开称数组。file则指定了你要编译的文件。\n但是每次都编写compile_commands.json也很烦，有一些工具可以帮助你自动生成。\nCMake 如果你使用的是CMake，可以加上构建选项-DCMAKE_EXPORT_COMPILE_COMMANDS=YES让cmkae自动生成。\nbear bear工具可以帮助你生成，在MacOS上使用 brew install bear 安装之后即可使用。 bear可以根据多个构建工具来帮助你生成，如果你使用的是make，那么可以使用: bear make来自动生成。\n其他的构建工具 其他的构建工具见这里\n","description":"","tags":null,"title":"vim利用ccls进行补全","uri":"/posts/vim%E7%9A%84coc.nvim%E8%A1%A5%E5%85%A8%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%B4%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"《现代操作系统》的学习笔记，这一章是死锁。\n死锁 死锁发生的情况 假设现在有两个进程A和B，以及两个资源M和N。现在A进入临界区操控M，B在N的临界区操控N。这时，在临界区中的A需要使用N，但是由于N被B使用着，所以A必须等待。而巧的是，B这时也需要M，于是B等待A释放M，而A却等待B释放N，双方都在等待对方释放资源，从而无法继续执行进程，这就叫做死锁。\n书上的定义如下：\n如果一个进程集合中的每个进程都在等待只能由该进程集合中的进程才能引发的事件，那么该进程集合就是死锁的\n进程死锁需要以下四个条件：\n互斥条件：一个资源要么被分配给了一个进程，要么没被分配。 占有和等待条件：已经得到某个资源的进程可以要求新的资源 不可抢占条件：进程的资源不能被抢占，只能由进程主动释放 环路条件：死锁发生时，系统中一定有两个或者两个以上的进程组成环路。组成环路的进程是死锁的。 这里解释一下资源的可抢占性，资源分为两种：可抢占的和不可抢占的。可抢占的意思就是在进程使用这个资源的时候，另一个进程可以把资源抢过来而不经过原进程的同意。不可抢占的就是不能抢过来，只能由持有进程自己释放。显然可抢占资源并不会造成死锁。\n这里的环路条件也是我们判断进程是否死锁的方法：简单来说，我们需要一个进程资源图来表示系统中某一时刻的进程和资源的情况，比如下面这个：\n这里方的是进程，圆的是资源。从进程指向资源的箭头（橘色的）表示进程在请求这个资源。从资源指向进程的箭头（绿色的）表示这个资源被这个进程拥有。\n判断是否死锁的方式就是找图中有没有回路，显然B，C，S，R构成了回路，所以B和C死锁了。\n死锁的解决办法 大体上有两种解决办法：发生死锁想办法去解决它和直接避免死锁。\n死锁检测和死锁恢复 先来说明死锁发生之后再解决的方法。这叫做死锁恢复。那么显然，要死锁恢复的话必须先知道有没有死锁，所以得先了解死锁检测算法。\n死锁检测 每种类型一种资源 先考虑当每种类型的资源只有一个的时候，这个时候我们可以绘制出进程资源图，然后遍历这个图，如果遍历到了已经遍历过的节点，那么显然存在环路，也就存在死锁。\n每种类型多个资源 这个时候需要用矩阵来解决，首先存在$E$向量，是存放着不同种类资源的资源数目的向量：\n磁带机 绘图仪 扫描仪 CD-ROM E = [ 4 2 3 1] 然后存在一个$C$矩阵，是当前所有进程占用资源的情况： $$ C= \\begin{bmatrix} 0 \u0026 0 \u0026 1 \u0026 0 \\\\ 2 \u0026 0 \u0026 0 \u0026 1 \\\\ 0 \u0026 1 \u0026 2 \u0026 0 \\\\ \\end{bmatrix} $$ 列是和E相对应的资源，行是进程。也就是说，第一行$\\begin{bmatrix}0 \u0026 0 \u0026 1 \u0026 0\\end{bmatrix}$就是进程1所占用的资源，分别是0个磁带机，0个绘图仪，1个扫描仪和0个CD-ROM。\n然后通过C矩阵和E向量，我们可以很快速得到当前剩余资源向量A： $$ A= \\begin{bmatrix} 2 \u0026 1 \u0026 0 \u0026 0 \\end{bmatrix} $$ 最后是当前时刻所有进程的请求矩阵$R$ $$ R= \\begin{bmatrix} 2 \u0026 0 \u0026 0 \u0026 1 \\\\ 1 \u0026 0 \u0026 1 \u0026 0 \\\\ 2 \u0026 1 \u0026 0 \u0026 0 \\\\ \\end{bmatrix} $$ 第一行就表示进程1要请求2个磁带机和1个CD-ROM。\n想要找出死锁，就需要一步一步满足请求矩阵R。首先进程1的请求不能被满足，因为已经没有CD-ROM了。进程2也不行，因为没有扫描仪了。但是进程3可以，于是系统将资源分配给进程3，进程3使用完之后返还资源，于是现在的各个图变成这样： $$ A = \\begin{bmatrix}2 \u0026 2 \u0026 2 \u0026 0 \\end{bmatrix} C = \\begin{bmatrix} 0 \u0026 0 \u0026 1 \u0026 0 \\\\ 2 \u0026 0 \u0026 0 \u0026 1 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \\\\ \\end{bmatrix} R= \\begin{bmatrix} 2 \u0026 0 \u0026 0 \u0026 1 \\\\ 1 \u0026 0 \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \\\\ \\end{bmatrix} $$ 然后资源就可以分配给进程2，进程2使用完之后返还资源，再次分配给进程1即可。所以这整个过程中没有死锁。\n如果出现了哪一步所有进程都没办法分配资源的话，就会导致死锁。\n死锁恢复 恢复的方式有三种，都是很好理解的：\n利用抢占恢复：如果资源是可抢占的，可直接抢占。 利用回滚恢复：当进程进入临界区之前保存进程状态，如果存在死锁，则恢复到进入临界区之前的状态。 通过杀死进程恢复：将死锁的进程搞死也是一种方法。 可以看出，无论哪种其实效果都不是很好。所以处理死锁最好的方法就是避免死锁。\n死锁避免 进程资源轨迹图 避免死锁主要是依靠安全状态。首先来看一个人可以识别的方法（机器几乎不能，考试专用方法）：绘制进程资源轨迹图：\n横坐标是A占用资源的时间，纵坐标是B占用资源的时间。右上角的u点是A和B都在这个资源上工作完毕的事件。我们的目标就是从原点p到达u点。在I1到I3时间点内，A需要占用打印机，在I2到I4时间内，A需要占用绘图机。而B则是在I5到I7时间之间占用绘图机，在I6到I8之间占用打印机。\n虚线是资源的被占用状态，比如p到q资源一直在A轴上移动，代表资源被A占用。而q到r则在B轴方向上移动，代表资源被B占用。\n那么显然，不能让资源走到由I2，I3，I6，I7围成的公共区域S中，因为这个区域中A占用着打印机却请求绘图机，B占用绘图机却请求打印机，会产生死锁。所以这个让资源从p到u的不死锁路径就是绕过公共区域S的路径。\n单种类资源的银行家算法 现在假设只存在一种种类的资源，并且我们知道当前资源的占有情况和每个进程所需资源的最大情况：\n假设现在是图(a)的情况，A进程占有3个资源，最大需要9个资源，B占有2个，最大需要4个，C占有2个，最大需要7个。并且系统现在有3个剩余资源。\n银行家算法的思想就是：存不存在一种分配方法，使得所有进程都可以顺利完成自己的工作。\n这里我们将剩余的3个资源中的2个先分配给B，这样就到达图(b)，B利用完资源后返回，到达图(c)，这个时候就有5个多余资源，那么分配给C，到达图(d)，C使用完之后返还资源，到达图(e)。那么显然最后A可以分配，所有进程都可以完成自己的工作。\n安全状态就是指资源分配后可以保证下一步的资源分配（也就是不造成死锁），上图的5个步骤都是安全的。不安全就是指分配资源后会引发死锁。比如我第一步将3个资源分配各A，那么显然后续就没办法进行下去了。\n多种类资源的银行家算法 其实也很简单，这里需要用到“每种类型多个资源”一节中的E，A，C，R图：\n分配的算法很简单：将E向量减去每一行的资源占用向量，如果存在负数部分，表示分配给这个进程后会死锁，就不分配，直到找到结果各分部都大于0的行，分配给这个行所代表的进程，进程用完资源后回收，标记这个进程已经结束，然后再次进行下一轮分配。\n死锁预防 显然死锁避免是不可能的，因为根据死锁避免算法，系统需要知道死锁的最大资源请求数量，也就是说系统得知道进程未来的资源请求情况。这是不现实的。\n在真正实践中，一般是通过打破死锁的四个必要条件中的一个或多个来预防死锁。\n活锁 活锁和死锁差不多，只不过不是进程被阻塞，而是由于轮询机制导致的无休止的等待。比如下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void process_A(){ enter_region(resource_1); enter_region(resource_2); do_something_with_resources(); leave_region(resource_2); leave_region(resource_2); } void process_B(){ enter_region(resource_2); enter_region(resource_1); do_something_with_resources(); leave_region(resource_1); leave_region(resource_2); } 当A进入resource1时B进入resource2，那么会产生活锁：两个进程通过论讯的方式不停地要求资源2和资源1。\n饥饿 饥饿是指在论讯的过程中，总是有进程一直得不到资源。比如优先级最高算法，优先级高的进程先使用资源，那么低优先级的进程将可能等待很长一段时间，这就是饥饿。\n","description":"","tags":null,"title":"操作系统-6-死锁","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-6-%E6%AD%BB%E9%94%81/"},{"categories":null,"content":"《现代操作系统》的笔记，这一篇是I/O。\nI/O简介 IO的本质其实就是除去CPU之外的设备，在单片机中我们成为外设。像磁盘，USB，鼠标，键盘，甚至显示屏都是外设。\nI/O设备 IO设备大体上被分为三种：\n块设备：以块为单位进行读写的设备，比如磁盘。块设备的特点是不能一字节一字节地读写，而必须一个块一个块读写。 字符设备：和块设备相反的设备，只能以一个字符一个字符的方式读写，比如键盘。 其他设备：既不属于块设备也不属于字符设备的设备，比如时钟。 设备控制器 IO不能直接接到CPU上，而必须通过设备控制器接入：\n设备控制器提供了一些操作设备的方法，让CPU可以更好地操作设备。\n设备控制器中会有一些寄存器，以及一个缓冲区（有些有），比如和硬盘打交道的控制器，并不是磁盘传递一个数据之后就将数据转发给CPU，而是将数据放在缓冲区中，等到缓冲区满了再转发数据。一般块设备的控制器都有缓冲区，并且在读取了一个块到缓冲区后会通过校验和检查数据是否出错。\n操作设备的方式 通过端口操纵 设备控制器会暴露端口，软件可以通过端口操控。如在大部分汇编语言中，可以使用in和out指令读和写端口。\n通过内存映射 有些设备有一个CPU可以读写的缓冲区，通过将这些缓冲区直接映射到内存中就可以像访问内存一样访问缓冲区，十分方便。比如在保护模式下，显卡的显存（VRAM）就被映射到0xB800:0x0000地址处，直接向地址写数据就可以在屏幕上显示字符，而不需要通过端口。\n现代CPU一般都是通过两种混合的方式：\n内存映射是这样工作的：CPU在对内存工作的时候，必须将数据放在地址总线上，然后发起一个READ信号。内存接收到这个信号后，会判断是否在IO映射区，如果在，则对应的IO响应，否则内存响应。\n直接存储器存取 如果所有的外设操作都由CPU完成的话，由于需要等待外设完成操作，将会耗费很多CPU时间。有些计算机有专门的直接存储器(DMA)硬件和IO打交道。DMA能够独立于CPU访问IO。DMA一般是可编程的，CPU告诉DMA要打交道的IO和读出的数据应当存放的内存地址后，就由DMA和IO交互，DMA会等待IO的数据，然后放到指定的内存处，CPU之后就可以直接访问内存了：\nDMA会发送和CPU一样的读写指令，所以内存并不知道是谁发送了指令，它只管运行。\n有些DMA还有如图的做法：不是自己存储数据放入内存，而是直接告诉控制器内存地址，让控制器直接放入内存。\nDMA完成IO操作之后，会产生一个中断给CPU，让CPU回来处理数据。\n中断的底层实现 一般IO都挂载到中断控制器上，由中断控制器来向CPU发送中断。CPU也可以对中断控制器进行设置，比如cli汇编指令就是告诉中断控制器忽略可屏蔽中断。\n中断控制器一次只能发送一个中断。一般CPU在运行中断处理程序时会先关闭中断，运行完之后会打开中断。如果IO发现CPU没有响应中断，可能会重复发起中断。\n精确和不精确中断 精确中断是指满足一下三个条件的中断：\n程序计数器（PC）保存在一个已知的地方 PC所指指令之前的所有指令都执行完毕 PC所指指令之后的所有指令都没执行 PC所指指令的执行状态已知 在实模式下的中断都是精确中断，但是保护模式下就不是了。因为保护模式下新增了指令流水线和微操作等特性。\n指令流水线是指：将一条指令的执行过程分为很多指令，并传给不同单元执行，每个单元的执行是并行的：\n而为了实现流水线技术，必须将指令分成更小的称为微操作的指令。一旦分解完毕，CPU就可以使用乱序执行技术，将微操作打乱，以自己认为更合理的方式执行。比如指令\n1 2 3 4 mov eax, [mem1] shl eax, 5 add eax, [mem2] mov [mem3], eax 这里对add eax, [mem2]就可以拆分为读mem2内存微操作和将读出结果写入eax微操作，那么我们就可以在执行shl eax, 5指令的同时将mem2的读操作一并执行，然后再写入。这样指令的顺序就变化了。\n有了这两种特性，当产生中断的时候指令执行的状态就不是那么容易获得，并且在流水线的情况下很难明确目前究竟执行到哪一条指令。所以这种中断就称为不精确中断\nI/O软件原理 接下来简要探讨IO软件的目标和几种实现方法\n设备独立性 存在IO软件或者IO库的目的显然在于封装底层IO的不同操作方式，并且提供统一的接口。比如Unix可以通过open()函数操作硬盘，USB，甚至是网卡（打开Socket），而且在访问的时候不需要指定设备。\nUnix下的做法是统一命名，所有的设备都映射为文件，只需要通过常规的文件操作就可以对设备操作了。\nIO软件还需要做到错误处理：当IO出错了需要报错或者使用某些手段处理错误。\nIO软件还需要提供同步和异步操作，也就是我们常听说的异步IO和同步IO。\n实现方式 程序控制IO 第一种方式是程序控制IO，用户程序必须通过系统调用访问IO，这将导致代码进入内核空间。内核空间会创建一个缓冲区等待IO数据，填充满之后将缓冲区返回给用户程序。\n这里需要注意的是，程序需要一直等待IO数据，如果IO阻塞了需要进行等待，也就是说存在类似下面的代码：\n1 2 3 4 5 6 7 8 void read_disk(int disk_num){ char buffer[1024]; int i = 0; char c; while((c=read(disk_num))!=READY){ buffer[i++] = c; } } 这种方式叫做轮询(Poll)或者忙等待(busy wait)。用高级语言的话说叫做同步IO\n中断控制IO 显然程序控制IO很浪费CPU，使用中断的话更好。也就是说当IO完成操作时向CPU发送中断，从而让CPU处理数据。这种就叫做异步IO。\n使用DMA的IO 最后一种就是使用DMA，如果你的电脑存在DMA硬件的话。\n设备驱动程序 一般来说每一类设备都会有一个设备驱动程序，专门用于和这个设备打交道的。设备的厂商也会自己开发设备驱动程序以供给知名的操作系统。\n与设备无关的IO软件 设备驱动程序的统一接口 每次增加新类型的驱动的话就需要新编写驱动程序，并且需要定义和操作系统交互的接口。这还少很麻烦的事情。所以需要统一设备驱动程序的统一接口。Unix就做的很好：将设备全部映射为文件。\n缓冲 用户通过IO系统调用进入内核后，内核一般都有一个缓冲区用于缓冲。有些内核甚至存在双缓冲：一个缓冲用于将读好的数据交付给用户程序，一个用于接收从设备来的数据。\n有些时候内核没有缓冲，用户程序可以自己定义缓冲。\n错误报告 当设备发送错误的时候必须向用户程序报告错误。\n分配与释放专用设备 如果一个设备一次性只能被一个进程占用，就需要对设备使用进行检查。这也就是为什么在高级语言中设备是通过文件句柄交互的原因。\n与设备无关的块大小 对于块设备来说，不同设备有不同的块大小。IO软件需要定义一个和设备无关大小的块来方便和用户程序交互。\nI/O硬件 接下来看一些几乎每个电脑上都有的IO硬件\n磁盘 磁盘是典型的块设备。其内部结构如下：\n磁盘由多个盘片组成，每个盘片被划分为扇区和磁道。磁道就是用多个同心圆之间的区域，而扇区就是在同心圆区域之间，被从圆心向外发出的直线所分割的区域。每个盘一般有两个盘面。多个盘的同一组磁道在空间上组成了一个圆柱，就被称为柱面。读写磁头就是用于读写磁盘的磁头。\n需要注意的是，读写磁头必须一起移动，不能分开移动。\n对于磁盘的读写，一般来说都是通过指定柱面，磁道，扇区（CHS方法）三个坐标来读取，但是也有称为LBA直读的方式，其将柱面，磁道，扇区编码成一列，你可以通过读取数组一样的方式来读取。\nLBA的优点是软件读取十分方便，但是没有办法利用好磁盘的特点，比如你要读第一LBA和第二LBA，那么磁头必须进行一次移动，从一扇区移动到二扇区。而CHS方法则可以很好地利用磁盘物理结构，如果你想要读取不同盘面的同一扇区的话，磁头只需要移动到对应扇区即可（因为各个盘面的扇区在同一柱面上），这样读取起来十分块。\n现在有些机器还是用RAID（廉价磁盘冗余阵列），其实就是讲多个磁盘叠在一起组成大磁盘，然后由专门的RAID设备驱动程序控制。一般用在服务器上。\n磁盘臂调度算法 由于磁盘臂只能一起移动，所以需要想一些调度算法。\n磁盘的读取速度一般由以下因素决定：\n寻道时间（将磁盘臂移动到指定柱面上的时间） 旋转延时（等待指定扇区旋转到指定磁头下面的时间） 实际读取时间 先来先寻道（FCFS）算法 这个算法也是最容易想到的：先来的读写请求先执行。这种算法就属于无脑算法，因为磁盘臂可能需要移动很长的距离。比如读取请求按顺序是这样的（为了简化，假设只有一个盘，盘只有一个磁道）：3扇区，5扇区，1扇区，6扇区。那么这样移动顺序为3-\u003e5-\u003e1-\u003e6，一共移动了11个扇区的距离。\n最短寻道优先（SSF）算法 这种算法总是优先处理距离当前位置最短的请求，比如存在请求:3，5，1，6。那么移动顺序为3-\u003e5-\u003e6-\u003e1一共走了7个扇区的距离。这种算法的缺点在于，如果近距离的读写请求不断被发送，那么远距离的扇区可能需要等待很长时间。\n电梯算法 这个算法是同时也是现实中电梯的算法：先往一个方向移动，直到这个方向上没有扇区时向反方向移动。比如存在3,5,1,6,2扇区的请求，并且现在的方向是向右移动，那么首先读取3-\u003e5-\u003e6三个扇区，在这个方向上一节没有要读写扇区了，那么向反方向移动，变为6-\u003e2-\u003e1读取三个扇区。这种算法目前是应用最广的。\n时钟 时钟既不属于块设备，也不属于字符设备。时钟由晶振组成，在早期的电脑中，只需要将时钟两端通上电，时钟就可以以一定频率进行振动，从而计时。现在在单片机中我们仍然能看到这样的时钟。\n现代计算机一般都是可编程时钟：\n晶振连接着一个计数器，并且还存在一个存储寄存器。当晶振开始工作的时候，存储寄存器将值放入计数器中，晶振每振动一次，计数器的值就减1，如果计数器值为0，时钟向CPU产生时钟中断，并且再次将存储寄存器的值放入技术器中。由于可以编程指定存储寄存器的值，所以是可编程的。这样中断频率就可以通过软件设置了。\n一般时钟软件都有如下功能：\n维护系统时间 防止进程运行超时 对CPU使用情况进行记账 处理用户提出的alarm请求 为系统各个部分提供监视器 完成概要剖析，统计和监视功能 键盘和鼠标 关于键盘要提的就是系统接收到的键盘按键信息并不是ASCII码，而是按键扫描码（Scancode）。一般键盘不超过128个键，所以使用一个8位寄存器即可记录扫描码，最高位可以用来记录键是否按下的状态。\n鼠标没什么可说的，就是返回按键信息和x，y方向上的偏移量。\n显示器 也没什么可说的，这里科普一下：显示器有两种模式：字符模式和图像模式（VGA模式），这两种模式的IO内存映射也不一样。字符模式下只能显示字符，不能显示图像，但是显示字符很方便（只需要将字符的ASCII码和颜色信息发送给显卡即可），而图像模式下可以绘制图像，但是显示字符也是通过绘制的方式，比较麻烦。\n","description":"","tags":null,"title":"操作系统-5-I/O","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-5-io/"},{"categories":null,"content":"《现代操作系统》的笔记，这里讲述了ELF32文件和ext文件系统。\n文件 文件，其实就是磁盘中的一块二进制文本。文件其实有很多种格式，在Unix下使用的是ELF文件格式，而在Windows下则是PE文件格式。这里就来剖析一下ELF文件格式。\nELF32文件分析 ELF32是32位Unix系统下的文件格式，称为Executable Linkable Format，也就是说这一个格式既可以做到表示可执行文件，也可以做到表示链接文件。64位的操作系统使用的是ELF64。\n如果你想要看官方的说明文档，直接\n1 man elf 即可\n制作分析样本 首先我们用C语言创建一个可执行的ELF32文件来作为分析样本：\n1 2 3 4 5 6 7 8 #include \u003cstdio.h\u003e char buffer[8]; int main(){ const char* str = \"hello world\\n\"; printf(\"%s\", str) } 然后在Unix系统下，使用如下命令编译：\n1 gcc -m32 main.c -o main.out -m32指定了编译为32位的，如果你的系统是64位的但是没有加这个选项，会默认编译为64位的。如果你的系统是64位的，那么需要安装32位的辅助库：\n1 apt-get install gcc-multilib 接下来验证你的main.out文件是ELF32格式的：\n1 2 3 4 file main.out #出现如下即可 main.out: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 3.2.0, BuildID[sha1]=ea6b37ec7e761d92fa742559569d654c9462112d, not stripped ELF32格式 ELF文件中主要有四个部分：\nELF头（ELF header）。这一部分一定在文件开头，ELF32中占52字节。这个头部指定了程序投标和节头表在文件中的位置，以及一些ELF文件的信息。 程序头表（Program header table）。这一部分的位置不固定，一个程序可能有多个程序头表，也可能没有（只有可执行文件才有）。用于指定程序运行时的内存分布。 节头表（Section header table）。这一部分位置不固定，一个程序可能有多个节头表。节头表指定了程序中节在程序中的位置（这里的section意义和nasm中section的意义一样，其实就是指定程序段的位置）。 程序段。程序的程序段。 接下来一部分一部分看：\nELF头部 通过\n1 readelf -h main.out 可查看头部信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 Class: ELF32 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Shared object file) Machine: Intel 80386 Version: 0x1 Entry point address: 0x3e0 Start of program headers: 52 (bytes into file) Start of section headers: 6080 (bytes into file) Flags: 0x0 Size of this header: 52 (bytes) Size of program headers: 32 (bytes) Number of program headers: 9 Size of section headers: 40 (bytes) Number of section headers: 29 Section header string table index: 28 顺便将头部信息对应的结构体也给出（Unix系统下的elf.h头文件中就有），我将每个字段在文件中的偏移地址都写在字段上方了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 typedef uint16_t Elf32_Half; typedef uint32_t Elf32_Word; typedef int32_t Elf32_Sword; typedef uint64_t Elf32_Xword; typedef int64_t Elf32_Sxword; typedef uint32_t Elf32_Addr; typedef uint32_t Elf32_Off; typedef uint16_t Elf32_Section; typedef Elf32_Half Elf32_Versym; #define EI_NIDENT (16) typedef struct { //0字节 unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ //16字节 Elf32_Half e_type; /* Object file type */ //18字节 Elf32_Half e_machine; /* Architecture */ //20字节 Elf32_Word e_version; /* Object file version */ //24字节 Elf32_Addr e_entry; /* Entry point virtual address */ //28字节 Elf32_Off e_phoff; /* Program header table file offset */ //32字节 Elf32_Off e_shoff; /* Section header table file offset */ //36字节 Elf32_Word e_flags; /* Processor-specific flags */ //40字节 Elf32_Half e_ehsize; /* ELF header size in bytes */ //42字节 Elf32_Half e_phentsize; /* Program header table entry size */ //44字节 Elf32_Half e_phnum; /* Program header table entry count */ //46字节 Elf32_Half e_shentsize; /* Section header table entry size */ //48字节 Elf32_Half e_shnum; /* Section header table entry count */ //50字节 Elf32_Half e_shstrndx; /* Section header string table index */ } Elf32_Ehdr; 让我们一个字段一个字段看：\ne_ident[EI_NIDENT]：对应头部信息Magic部分，这是一个魔数，让我们一个字节一个字节看： 7F 45 4C 46：ELF开头必须是这四个字节，7F没有意义，45 4C 46则是ELF三个字母的ASCII码 01：对应Class部分的值，表示文件类型 0：无效文件类型 1：ELF32 2：ELF64 01：对应Data部分的值，表示文件编码的方式 0：无效编码 1：小端表示 2：大端表示 01：对应Version部分的值，表示ELF头部的版本 0：无效版本 1：当前版本 e_type：对应Type部分，表示文件类型 0：无效文件 1：可重定位文件 2：可执行文件 3：共享目标文件 4：Core文件 e_machine：对应Machine部分，表示文件的编译平台。为3表示80386 e_version：对应头部的第二个Version部分，表示这个文件的版本 0：无效版本 1：当前版本 e_entry：对应Entry point address部分，表示程序的入口点（如果不是可执行程序则为0x00），这里是main函数所在的位置。 e_phoff：对应Start of program headers，表示Program header table在文件中的偏移地址，这里是52，表示正好在ELF头的后面。 e_shoff：对应Start of section headers，表示Section header tbale在文件中的偏移地址。 e_flags：对应Flags，表示在x86架构下，程序载入时EFLAGS寄存器的初值。 e_ehsize：对应Size of this header，表示ELF头的大小 e_phentsize：对应Size of program headers，即Program header table的大小 e_phnum：对应Number of program headers，即Program header table的个数 e_shentsize：对应Size of section headers，即Section header table的大小 e_shnum：对应Number of section headers，即Section header table的个数 e_shstrndx：对应Section header string table index，即指向保存字符串信息的节的序号（从0开始算） Program header table 程序头表中存放着一系列的Segment的信息。\n现在来看看程序头表，使用readelf -l main.out即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Elf file type is DYN (Shared object file) Entry point 0x3e0 There are 9 program headers, starting at offset 52 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000034 0x00000034 0x00000034 0x00120 0x00120 R 0x4 INTERP 0x000154 0x00000154 0x00000154 0x00013 0x00013 R 0x1 [Requesting program interpreter: /lib/ld-linux.so.2] LOAD 0x000000 0x00000000 0x00000000 0x00754 0x00754 R E 0x1000 LOAD 0x000ed8 0x00001ed8 0x00001ed8 0x00130 0x0013c RW 0x1000 DYNAMIC 0x000ee0 0x00001ee0 0x00001ee0 0x000f8 0x000f8 RW 0x4 NOTE 0x000168 0x00000168 0x00000168 0x00044 0x00044 R 0x4 GNU_EH_FRAME 0x00061c 0x0000061c 0x0000061c 0x0003c 0x0003c R 0x4 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x10 GNU_RELRO 0x000ed8 0x00001ed8 0x00001ed8 0x00128 0x00128 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame 03 .init_array .fini_array .dynamic .got .data .bss 04 .dynamic 05 .note.ABI-tag .note.gnu.build-id 06 .eh_frame_hdr 07 08 .init_array .fini_array .dynamic .got 然后是结构体声明:\n1 2 3 4 5 6 7 8 9 10 typedef struct { Elf32_Word p_type; //段的类型，或者如何解释此数组元素的信息。 Elf32_Off p_offset; //从文件头到该段第一个字节的偏移 Elf32_Addr p_vaddr; //段的第一个字节将被放到内存中的虚拟地址 Elf32_Addr p_paddr; //仅用于与物理地址相关的系统中。System V忽略所有应用程序的物理地址信息。 Elf32_Word p_filesz; //段在文件映像中所占的字节数。可以为0。 Elf32_Word p_memsz; //段在内存映像中占用的字节数。可以为0。 Elf32_Word p_flags; //与段相关的标志。 Elf32_Word p_align; //段在文件中和内存中如何对齐。 } Elf32_phdr; 这里就直接解释readelf输出的信息了：\n在Program Headers表中，每一行都是一个Segment的信息。Offset表示这个Segment在文件中的偏移量，FileSiz则表示其大小。而VirtAddr则表示这个Segment应当加载到内存中的哪个位置；PhysAddr也一样，只不过是在未开启分页机制下的物理地址，一般在开启分页机制的系统中值都是相等的。MemSiz则是需要多少内存空间容纳这个Segment。\n然后看第一列：PHDR表示本Program header；INTERP则是指定以null结尾的路径名的位置和大小,作为解释器调用，以链接运行时库；LOAD则是必须要加载入内存的Segment；DYNAMIC所指的节包含动态链接的信息；NOTE指定辅助信息的位置和大小；TLS指定线程本地存储模板，从用TLS标志组合所有部分；GNU_STACK是内核使用的字段。\n下面的**Section to Segment mapping（节到段映射表）明确地说明了哪些段对应哪些节。第一个LOAD类型的Segment对应02号节，可以看到里面有.text所以是代码段。第二个LOAD类型的Segment对应03号节，里面有.data和.bss有数据段。\nSection header table 节头表则是用来记录节信息的表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 00000154 000154 000013 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 00000168 000168 000020 00 A 0 0 4 [ 3] .note.gnu.build-i NOTE 00000188 000188 000024 00 A 0 0 4 [ 4] .gnu.hash GNU_HASH 000001ac 0001ac 000020 04 A 5 0 4 [ 5] .dynsym DYNSYM 000001cc 0001cc 000080 10 A 6 1 4 [ 6] .dynstr STRTAB 0000024c 00024c 00009d 00 A 0 0 1 [ 7] .gnu.version VERSYM 000002ea 0002ea 000010 02 A 5 0 2 [ 8] .gnu.version_r VERNEED 000002fc 0002fc 000030 00 A 6 1 4 [ 9] .rel.dyn REL 0000032c 00032c 000040 08 A 5 0 4 [10] .rel.plt REL 0000036c 00036c 000010 08 AI 5 22 4 [11] .init PROGBITS 0000037c 00037c 000023 00 AX 0 0 4 [12] .plt PROGBITS 000003a0 0003a0 000030 04 AX 0 0 16 [13] .plt.got PROGBITS 000003d0 0003d0 000010 08 AX 0 0 8 [14] .text PROGBITS 000003e0 0003e0 000202 00 AX 0 0 16 [15] .fini PROGBITS 000005e4 0005e4 000014 00 AX 0 0 4 [16] .rodata PROGBITS 000005f8 0005f8 000021 00 A 0 0 4 [17] .eh_frame_hdr PROGBITS 0000061c 00061c 00003c 00 A 0 0 4 [18] .eh_frame PROGBITS 00000658 000658 0000fc 00 A 0 0 4 [19] .init_array INIT_ARRAY 00001ed8 000ed8 000004 04 WA 0 0 4 [20] .fini_array FINI_ARRAY 00001edc 000edc 000004 04 WA 0 0 4 [21] .dynamic DYNAMIC 00001ee0 000ee0 0000f8 08 WA 6 0 4 [22] .got PROGBITS 00001fd8 000fd8 000028 04 WA 0 0 4 [23] .data PROGBITS 00002000 001000 000008 00 WA 0 0 4 [24] .bss NOBITS 00002008 001008 00000c 00 WA 0 0 4 [25] .comment PROGBITS 00000000 001008 000029 01 MS 0 0 1 [26] .symtab SYMTAB 00000000 001034 000440 10 27 43 4 [27] .strtab STRTAB 00000000 001474 000250 00 0 0 1 [28] .shstrtab STRTAB 00000000 0016c4 0000fc 00 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), p (processor specific) Nr是序号，Name是节的名称，Type是节的类型，Addr是节应当在内存中的地址，Off是节在文件中的偏移量，Size是节的大小。\n对应的结构体如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 typedef struct { Elf32_Word sh_name; /* Section name (string tbl index) */ Elf32_Word sh_type; /* Section type */ Elf32_Word sh_flags; /* Section flags */ Elf32_Addr sh_addr; /* Section virtual addr at execution */ Elf32_Off sh_offset; /* Section file offset */ Elf32_Word sh_size; /* Section size in bytes */ Elf32_Word sh_link; /* Link to another section */ Elf32_Word sh_info; /* Additional section information */ Elf32_Word sh_addralign; /* Section alignment */ Elf32_Word sh_entsize; /* Entry size if section holds table */ } Elf32_Shdr; 符号表 其实Section里面还有一个特殊的Section叫做符号表，用于存放所有符号，分别为动态符号表.dynsym和静态符号表symtab。使用-s选项观察。\n简化版本的分析 最后我们再来一个简化版本的分析，直接使用汇编语言：\n1 2 3 4 5 6 7 8 9 10 11 12 13 section .data str1: db 'hello world' global _start section .text _start: mov ax, 0 mov bx, 0 mov cx, 0 mov dx, 0 section .bss stack: resb 20 第四行的global是导出_start符号，因为链接器必须要有个对外的代码入口符号才行。将代码保存为main.asm，然后运行：\n1 2 nasm -felf32 main.asm -o main.o\t#汇编为中间文件 ld -m elf_i386 main.bin -o main.out2\t#连接成可执行文件 这个文件执行之后会报段错，不过没关系，我们只是拿来研究一下。使用readelf观察Program header table和Section header table:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align LOAD 0x000000 0x08048000 0x08048000 0x00090 0x00090 R E 0x1000 LOAD 0x000090 0x08049090 0x08049090 0x0000b 0x00020 RW 0x1000 Section to Segment mapping: Segment Sections... 00 .text 01 .data .bss Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .text PROGBITS 08048080 000080 000010 00 AX 0 0 16 [ 2] .data PROGBITS 08049090 000090 00000b 00 WA 0 0 4 [ 3] .bss NOBITS 0804909c 00009b 000014 00 WA 0 0 4 [ 4] .symtab SYMTAB 00000000 00009c 0000b0 10 5 7 4 [ 5] .strtab STRTAB 00000000 00014c 00002d 00 0 0 1 [ 6] .shstrtab STRTAB 00000000 000179 00002c 00 0 0 1 显然，由于我们在程序里面定义了.text,.data,.bss段，而且这些段都是程序运行时的必须段，所以存在两个LOAD类型的Segment指示我们要将这三个段载入内存中。而除了这几个段之外，nasm还自动定义了.symtab（符号表）——因为我们使用了符号_start,stack,str1；.strtab（字符串表）——因为我们使用了字符串常量hello world；和shstrtab（段表字符串表）——因为我们声明了段。\n然后使用-s参数详细查看.symtab的内容：\n1 2 3 4 5 6 7 8 9 10 11 12 Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 08048080 0 SECTION LOCAL DEFAULT 1 2: 08049090 0 SECTION LOCAL DEFAULT 2 3: 0804909c 0 SECTION LOCAL DEFAULT 3 4: 00000000 0 FILE LOCAL DEFAULT ABS main.asm 5: 08049090 0 NOTYPE LOCAL DEFAULT 2 str1 6: 0804909c 0 NOTYPE LOCAL DEFAULT 3 stack 7: 08048080 0 NOTYPE GLOBAL DEFAULT 1 _start 8: 0804909b 0 NOTYPE GLOBAL DEFAULT 3 __bss_start 9: 0804909b 0 NOTYPE GLOBAL DEFAULT 2 _edata 10: 080490b0 0 NOTYPE GLOBAL DEFAULT 3 _end 显然我们定义的符号都保存在符号表中，除此之外nasm还为我们增加了一些额外的符号。\n文件系统 说完文件之后我们来说明一下文件系统。\n基本概念 文件系统布局 磁盘，软盘，CD和U盘一般以块分割，每一个块是512字节（关于IO详见第六个笔记）。第一个块被称为主引导扇区（Master Boot Recorder），机器在启动的时候会自动地读取主引导扇区的512字节，放到0x7C00:0x0000的内存地址处，并且跳转到0x7C00:0x0000的地方执行代码。一般来说，MBR存放着加载器的代码。\n如果你安装过Ubuntu，那么当你从U盘启动的时候，会看到Ubuntu的安装程序。这是因为加载器将Ubuntu安装程序加载到内存中后，将控制权交给了安装程序。安装程序将本来存在在U盘上的操作系统安装到电脑硬盘上，并且留下引导代码，以便于你开机进入系统。\n一般来说，在MBR的最后存在一个分区表，用于指定磁盘的分区情况。分区是指将磁盘单独划分出来的一个区域，一般一个分区中会暗转搞一个文件系统，即一个分区对应一个文件系统。这样说来，你可能会想到在安装多系统时必须先对磁盘分区和格式化，这也正是为了操作系统的运行。\n一个文件系统一般在开头是一个引导块，用于装载该分区的文件系统；紧接着是一个超级块，包含文件系统的所有重要参数；然后就是文件的内容等信息。\n文件的实现 文件存储的实现的关键是确定哪个文件在哪些磁盘块上，这里有几种方法：\n连续分配 将每个文件作为连续的数据存放在磁盘上，所以如果一个文件尾40KB，那么在块大小为1KB的磁盘中就得占用连续的40个块：\n但是这种解决方法显然有缺点：随着时间的推移，可能些块因为太小而一直没有存储文件（产生空洞），导致磁盘变得零碎。而且一般来说不系统不会自动整合空洞，因为这样要遍历整个磁盘，很耗时间（而且这个时间是和磁盘大小成正比的，这意味着操作系统没办法通过算法控制时间）。\n在Windows7中，通过附件-\u003e系统工具菜单就可以找到磁盘碎片整理程序，这个程序就是为了处理空洞的。运行一次所需的时间还是比较长的。\n或者可以通过维护一个空洞列表，记录下空洞位置和大小，在创建文件的时候寻找可以容纳的空洞。但是这个方法也很有问题：必须在文件创建前得知文件的大小。试想你在打开Vim新建文件编写代码的时候，Vim却要你确定文件大小才让你进行编辑。这是一件很让人烦的事情。\n链表分配 办法就是将文件放在不同块中，并且以链表的方式记录：\n这样就可以很好地利用磁盘了。但是由于不是随机存储，查找文件会很耗时（尤其是磁盘这种很“笨重”的硬件），而且一般来说我们在每个物理块的前几个字节防止指向下一个物理块的指针，可能会导致物理块中剩余空间的大小不是2的幂，这也会影响CPU读取文件的速度。\n在内存中采用表的链表分配 看了链表分配后，你想不用在每个块前放置指针，而是将指针全部放在一张表里面不就行了。内存中的链表分配方法正是这么做的：\nA的块为0,2,4，B的块为1，3，5。这种表称为FAT（文件分配表）。\n这种方法也有明显的缺点：在文件和磁盘不断增大的情况下，内存中的这个表会越来越大，内存可能无法承受。\ninode 最后要介绍Unix系统一直在用的inode方法，下面是inode的结构示意图：\ninode保存着文件的属性，像是文件名称，文件GID，UID，权限，大小等等属性（需要注意的是这些属性并不是在ELF文件中定义的）。然后使用指针指向文件各部分所在磁盘块的地址。如果inode有大小的话，超出的磁盘块会存放在附加磁盘地址中，并且使用指针标明。\n文件夹（目录）的实现 一般来说可以将所有的目录列成表存储在磁盘中：\n如果使用了inode，还可以将文件属性放在inode中而不是目录项中。\nWindows使用第一种方法，Unix使用第二种方法。\n日志文件系统（LFS） 现在试想这样一个情况：你的WPS在写入文件，这个时候电池突然没电了，电脑关机。那么在关机之后磁盘的情况是怎样的呢?如果不采取一些措施的话，磁盘中将会存在WPS文档的部分信息，并且在开机之后不会将剩余部分的信息写入。这个时候磁盘中就会多出一块没用的空间，造成空间浪费。\n日志文件系统就是为了避免这种情况而诞生的。其基本思想是：每次读写磁盘的动作都作为日志记录在磁盘中。如果出现断电重启情况，系统会先查看日志，继续执行未完成的操作。\nLFS一般还有一个清理线程，用于定时清理没用的日志。\n而且LFS还有利于更好地提升磁盘读写效率：LFS可以在将文件读写的操作延后，等到存在连续扇区或柱面读取的时候再一次性读取，这样会快很多。\n虚拟文件系统（VFS） 即使在同一个计算机的同一个操作系统下，也有可能有不同的文件系统。你可以在你的Linux系统上使用df -T来查看各个文件系统：\n1 2 3 4 5 6 7 8 Filesystem Type 1K-blocks Used Available Use% Mounted on udev devtmpfs 998020 0 998020 0% /dev tmpfs tmpfs 204096 2772 201324 2% /run /dev/vda1 ext4 41152812 3984212 35264944 11% / tmpfs tmpfs 1020464 0 1020464 0% /dev/shm tmpfs tmpfs 5120 0 5120 0% /run/lock tmpfs tmpfs 1020464 0 1020464 0% /sys/fs/cgroup tmpfs tmpfs 204092 0 204092 0% /run/user/1001 可以看到，在/dev目录下下挂载的是devtmpfd系统，而在/目录下则是ext4文件系统。\nWindows的做法是将磁盘分区，然后每个区一个文件系统，比如C盘，D盘等都可以是不同的文件系统。但是同一个盘下必须是一个文件系统。\nLinux就不一样了，它尝试将所有的文件系统整合一个统一的结构中，所以就提出了VFS。\nVFS的核心思想就是通过VFS层将不同的操作系统掩盖起来，并且提供统一的POSIX标准的访问方式给进程。\next2文件系统 ext系列文件系统一直是Unix使用的文件系统，从ext1到最新的ext4。这里我们拿比较经典的ext2来说明。首先来看一下ext2的格式：\n首先存在一个启动块(Boot Block)，用于用以安装启动管理程序。然后是各个不同的ext2文件系统。\n每个文件系统的开头为一个超级快(Super Block)，用于记录本分区的信息（inode/block总量，大小，剩余量等）。然后是一个块组描述符表(Group Description Table)，整个分区分成多个块组就对应有多少个块组描述符。每个块组描述符存储一个块组的描述信息，如在这个块组中从哪里开始是inode Table，从哪里开始是Data Blocks，空闲的inode和数据块还有多少个等等。块组描述符在每个块组的开头都有一份拷贝。\n然后是块位图(Block Bitmap)，用1和0表示其后的块是否被占用（下面会说），然后是inode位图(inode Bitmap)，用1和0表示inode项是否有用。\n然后是inode表(inode Table)，里面存储了一系列的inode。\n最后是数据块，存储着用户数据。\n块位图的思想是这样的：由于磁盘分为很多个块，所以可以用一个长列表来表示每个块是否被占用，为0表示没有被占用，为1表示被占用。由于经常从形式上将长列表折叠成表格，所以叫做块位图：\n这里磁盘块的标号表示第几个磁盘块，灰色表示已经被占用。\n下方的块位图中中间数字表示是否被占用，角标表示对应的磁盘块序号。\ninode位图也是一样的思想。\n参考 CSDN博客1\nCSDN博客2\n","description":"","tags":null,"title":"操作系统-4-文件和文件系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-4-%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"《现代操作系统》的笔记。这里记录了段和页的相关知识。\n实模式和保护模式 首先必须说明一下实模式和保护模式。在“汇编语言”课程中，包括王爽的《汇编语言》中，大家接触到的都是16位汇编。16位汇编的特点是寄存器是16位的，并且对于内存的访问是任意的。\n但是任意对内存访问的话很容易导致内存混乱和，尤其是当存在操作系统的时候，如果能够对内存进行随意的访问，可能会更改操作系统所在的内存。也就是说，在16位模式下，没有任何的内存模型，当时的内存分布有三种：\n最右边的情况虽然说稳定一点，但是操作系统还是有可能被修改。16位下的对内存无限制访问的情况称为实模式。\n很快32位和64位的CPU发展了出来，Intel公司意识到，如果像这样不给内存读写加上任何限制的话，程序的编写还得是一个难事，所以给CPU加上了保护模式。保护模式中你需要告诉CPU自己的程序用到哪些段，段的起始地址和大小。如果你访问了不在段内的内存，CPU会产生异常中断。\n在16位下，虽然寄存器是16位的，但是地址总线是20位的，为了更好地利用内存，采用了段地址*16+偏移地址的做法来寻址20位内存，也就是$2^{20}=1MB$。所以16位寄存器20位总线只能寻址1MB内存，内存多了也没用。\n到了32位，由于地址总线都32位了，就取消了段地址*16+偏移地址的做法，直接将段地址和偏移地址相加得到内存地址。这个时候寄存器可以寻址$2^{32}=4GB$内存，所以在32位机器上安装4GB内存就够了，多了CPU也用不了。\n64位的话显然可以使用$2^{64}=2^{24}TB=16777216TB$，这下用户再也不愁内存太多CPU用不了了。\n在保护模式下，由于内存寻址突然变大了，可加载的程序也变多了，各个程序之间的内存协调也越来越重要，于是Intel公司在其处理器上又退出了分页机制。所以说分页机制只能在保护模式下使用，实模式下是不能使用的。\nIntelCPU下的计算机在启动的时候，为了兼容以前的程序，首先进入的还是实模式。这个时候就算你有32位总线你还是只能使用20位。一般操作系统都会有引导程序，引导会采用Intel规定的方法从实模式跳转到保护模式，然后在保护模式下加载和运行操作系统。所以你一开机就可以使用32位和64位的程序。但是如果你自己写操作系统就还得考虑从实模式到保护模式的事情。\n段 分段机制在汇编语言课程中有所涉及，这里不再赘述。简单来说就是讲程序分为很多的段，每一段负责不同的数据或者代码。在Unix操作系统中，一般有四个典型的段：\n.text段：用于存储代码 .data段：用于存储已经初始化的数据 .bss段：用于存储没有初始化的数据 栈 段：用于当做栈 段与段之间可以不是连续的，比如如下实模式代码：\n1 2 3 4 5 6 7 8 9 section .text\t;代码段 mov ax, 10 mov bx, 1001 times db 512 ;中间空出512字节 section .data\t;栈段 msg: db 'hello world' msg_len: equ $-msg 而保护模式下，可以通过告诉CPU段首地址来找到段，所以段也可以是不连续的。\n在高级语言中，编译器帮你隐藏了段的概念。程序在编译之后（如gcc）产生的文件里会存在段的信息。通过查看可以发现段也不一定是连续的（这部分知识见操作系统-4-文件系统）。\n接下来具体看一下保护模式下如何使用段（以NASM汇编器为例）：\n32位保护模式下使用段 首先得看一下这个图：\n这个表示GDT(Global Description Table全局描述符表)的内存结构，GDT有64字节，里面分别存放了段的信息，还有一种LDT和GDT的功能和格式是一样的，只不过一般用在用户程序中（GDT用在操作系统程序中）。接下来对其中的信息做一下说明：\n段界限：这个段的长度，用20个字节表示。可能有人会问为什么这个段界限不放在一起，高4位和低16位分开了。这个是由于Intel在推出最初拥有保护模式的80386CPU之前尝试推出过80286CPU，80286是在16位情况下使用保护模式，其中段界限就是放在AVL字段和P字段之间的，但是80286不给力，被淘汰了，所以80386为了兼容就搞成这样了，段基地址的分离也是这个原因。 段及地址：段的首地址，32位长度 TYPE：标志这个段的类型，是数据段？代码段？可读的？不可读的？依附的？一共占4位 S：代表这个段是不是系统使用的，占1位。有些段是系统使用的，比如指向LDT表的段 DPL：三个位表示的优先级，由于只有三位，所以只能表示三个优先级。0优先级最高，一般是内核运行的优先级。1优先级其次，一般是驱动程序所在优先级，2优先级最低，用户程序所在。低优先级的代码不能访问高优先级的段。 P：这个段目前在不在内存中。占1位。如果不在而去访问，会产生缺页中断，一般配合分页机制使用 AVL：没卵用位，程序员可以自定义用途 L：从16位保护模式遗留下来的，如果为0表示使用16位保护模式，现在都是32和64位保护模式，应该一直置1 D/B：也是16位保护模式遗留下来的，表示汇编指令中的操作数大小。为0表示操作数视为16位的，为1表示32位的。现在都是置1 G：表示段界限的粒度。为0表示Byte，为1表示KB。也就是说，假如段界限是$0xA3=163$，G为0表示163字节，而G为1表示163KB。 引导程序在进入会先设置自己的代码，数据，栈段，然后从实模式跳入保护模式，加载操作系统程序，然后将程序控制权交给操作系统。操作系统开始运行时，一般会首先重新设置GDT以便寻址更大的空间（因为引导程序一开始在实模式下工作，只能寻址1MB内存，所以GDT所指向的段大小加起来最大不能超过1MB。而进入保护模式之后可以寻址4GB，所以操作系统要重新设置GDT）。下面是使用NASM编写的一个小引导程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 %include \"pm.inc\" jmp code16 [bits 16] STACK_ADDR: equ 0xA0000 STACK_TOP: equ 0xFFFF ;GDT表 GDT_ADDR: dq 0 CODE32_SEG: GDT_ITEM 0, code32_len-1, G_BYTE, DB_32, P_INMEM, DPL_0, S_USER, TYPE_CODE CODE32_STACK_SEG: GDT_ITEM STACK_ADDR, STACK_TOP, G_BYTE, DB_32, P_INMEM, DPL_0, S_USER, TYPE_DATA_RW CODE32_DATA_SEG: GDT_ITEM 0, code32_data_len-1, G_BYTE, DB_32, P_INMEM, DPL_0, S_USER, TYPE_DATA_RW VIDEO_SEG: GDT_ITEM VIDEO_TEXTMODE_ADDR, VIDEO_TEXTMODE_SIZE-1, G_BYTE, DB_32, P_INMEM, DPL_3, S_USER, TYPE_DATA_RW GDT_LEN: equ $-GDT_ADDR GDTR_ADDR: dw GDT_LEN-1 dd GDT_ADDR CODE32_SELECTOR: equ 0x08 CODE32_STACK_SELECTOR: equ 0x10 CODE32_DATA_SELECTOR: equ 0x18 VIDEO_SELECTOR: 0x20 section code16 ;将code32代码段地址放入GDT mov eax, code32.start mov [CODE32_SEG+2], ax shr eax, 16 mov [CODE32_SEG+4], al mov [CODE32_SEG+7], ah ;将code32_data代码段地址放入GDT mov eax, code32_data.start mov [CODE32_DATA_SEG+2], ax shr eax, 16 mov [CODE32_DATA_SEG+4], al mov [CODE32_DATA_SEG+7], ah ;进入保护模式 lgdt [GDTR_ADDR] in ax, 0x92 or ax, 0x02 out 0x92, ax cli mov eax, cr0 or eax, 0x01 mov cr0, eax jmp CODE32_SELECTOR:0x00 [bits 32] section code32_data msg_in_protect: db 'into protect modea OK' msg1_len: equ $-msg_in_protect code32_date_len: equ $-$$ section code32 mov eax, VIDEO_SELECTOR mov es, eax mov eax, CODE32_DATA_SELECTOR mov ds, eax mov eax, CODE32_STACK_SELECTOR mov ss, eax mov sp, STACK_TOP ;这里应当有加载操作系统的代码 code32_len: equ $-$$ 让我来简单解释一下：\n第1行%include是NASM汇编器的预编译指令，和C的#include一样，包含一个文件进来。pm.inc中存在一些常量定义和GDT_ITEM宏，用于快速生成一个GDT表项（就是上面图中的那个东西）。\n第2行使用一个段内近转移。因为CPU在执行的时候是从上往下执行的，但是这个语句下面有GDT表，GDT表是数据不能被执行的，所以需要使用这个跳转语句跳转到24行的代码主体。\n4和5行定义了常量，表示栈的位置和大小（equ是NASM定义常量的关键字）,栈我们不放在这个程序里面。\n第3行的[bits 16]表示下面的代码汇编为16位的，直到52行的[bits 32]改为汇编为32位。\n然后是8到13行的GDT表的构建，里面构建了CODE32_SEG32位代码段，CODE32_STACK_SEG32位栈段，CODE32_DATA_SEG32位数据段（在第55行的段），VIDEO_SEG显存段（用于向屏幕显示文字）。这里9行的dq 0是声明一个64位的空GDT项，Intel规定GDT的前64位必须为0。\n我们有了GDT表了，但是CPU怎么知道它的大小和位置呢？第15行定义了40位的GDT描述符，分别记录了GDT的大小和首项的内存位置。\n19到22行定义了GDT选择子，这个后面会说道。\n然后程序来到了代码主体，进入24行的代码段。这个时候还在16位实模式，而这个代码段的功能就是打开保护模式并跳转到保护模式的代码段。25到36行是填充CODE32_SEG和CODE32_DATA_SEGGDT项的段基地址。可以看到我们在定义的时候给了0（GDT_ITEM后的第一个参数），所以现在要填充（不在声明的时候填充是因为NASM的限制）。\n39行通过lgdt [GDTR_ADDR]的指令将含有GDT信息的GDT描述符的地址给专用的GDTR(GDT Register)寄存器。这个时候CPU就可以通过GDTR寄存器找到GDT表了。\n41到43行打开A20总线开关。这个是历史原因。因为一开始CPU进入的是16位嘛，但是我们电脑有32位总线啊，那你在16位总线上工作这几个指令\n1 2 3 4 mov ax, 0xFFFF mov ds, ax mov bx, 0xFFFF mov ax, [bx+1] 那你说最后找到的数据段地址是什么？，显然得溢出对吧。但是总线有32位，意味着这个运算是会成功的。为了在16位下正常运行，Intel在第21根总线上动了手脚，让其在第21根线的值恒为0，这样在32位下就可以和16位一样运行16位代码了。但是进了32位后就不需要这个功能了。这里的代码就是关闭这个功能。\n然后45行关闭中断。因为保护模式下的中断机制和实模式下也不一样，所以关闭实模式中断。\n47行到49行是真正进入保护模式的代码：只需要将特殊寄存器cr0的最低位置1就可以开启保护模式了（顺便说一句，将其最高位置1会开启分页机制，所以分页机制默认不是开启的。一般都在操作系统代码里开启）。到这里我们就进入保护模式了。\n虽然进入了保护模式，但是我们的代码还是在16位下，所以51行一个段间远转移跳到32位的保护模式代码段（60行）（其实不仅为了进入32位代码，也是为了刷新指令流水线）。这里注意跳转命令的写法：\n1 jmp CODE32_SELECTOR:0x00 在保护模式下由于每个段都在GDT表中注册过了，所以就不用直接指定段的地址进行跳转了，而是需要指定段选择子。这里CODE32_SELECTOR在第19行有定义，值为$0x08$。计算方法是将这个值向右移3位，得到的结果是段在GDT中的位置。这里右移后是$0x01 = 1$，即在GDT表中的第一个位置（11行的声明，第一个空表项不算）。这样就指定我们要跳转到的段了。\n然后代码跳转到60行，开始执行保护模式下代码。61到67分别初始化了数据段和栈段，然后就应该加载操作系统代码了（加载代码太长，就不放出来了），最后也是一个段间远跳转跳到操作系统的代码，然后操作系统就转起来了。\n分页机制 除了段机制，Intel还提出了极其重要的分页机制。\n分页机制提出的缘由 在16位实模式下，由于没有内存模型，计算机只能一次运行一个程序。为了一次性运行多个程序，需要做到两点：\n保护：某个程序不能被其他程序干扰，这一点随着保护模式的提出已经解决了。 重定位：程序加载进内存后需分配给每个程序自己的内存空间，分页机制就是为了解决这个的。 而且分页机制的提出还带来了交换技术和虚拟内存技术，让大于内存的程序可以运行。\n分页机制理论 二级分页机制 本来程序是可以直接访问内存中的物理地址的，但是分页机制通过一种手段，将物理地址映射成线性地址。现在的分页机制一般是二级分页：\n首先将内存分为称为页框的概念（也称为帧或页帧），一个页框表示一个定长的物理内存，一般页框是4KB，Intel从奔腾CPU开始制定页框是4MB，但是有些系统还是使用的4KB（比如Linux）。\n然后是页表的概念，一个页表含有多个页（或者叫做页面），一个页指定一个页框在内存中的位置，页表和页本身也有大小，一般页的大小和页框是一样的。\n然后是页目录，用来存储页表的表。\n整个映射过程如下：\n其实二级分页就像字典一样，你要想找到一个地址，你得先查找页目录，通过页目录找到页表，然后通过页表最后找到内存的物理地址。\n这里页目录指向页表的物理地址，一个页目录项指向一个页表，这里假设页表在内存中是连在一起的，且页表的大小和页框大小一样是4字节。那么第一个页表的第一个页表项0x0000就是指内存中第一个页框，也就是0x0000~0x0004这四个字节；第二个页表项就的0x0001指向内存中得 第二个页框，也就是0x0004~0x008这一部分字节。\n一般来说页表和页框大小都是4KB，这里只是举个栗子。\n有了分页机制有什么用呢？显然，我们可以给每个进程一个页目录，这样每个进程都可以使用内存中的任意部分了，但是不能同时使用，这种内存叫做虚拟内存。\n那么多进程就好实现了，假设现在有个进程占据着内存在运行，现在CPU执行调度算法，需要将另一个进程换到当前进程所在处，那么我们就可以将当前被占据的页写到磁盘上，然后从磁盘上将需要调度的程序的页载入进来。这样就完成了一次进程切换。\n快速分页过程 从线性地址到物理地址转换的速度必须快，否则会很浪费时间。为了加速转换，使用叫做MMU(Memory Manage Unit)的专门硬件来实现转换：\nMMU将地址转换后再发给内存和存储器。\nMMU里面有一种TBL(Translation Lookaside Buffer)硬件，用于更加快速地转换地址：其内部保存着一个含有少量表项的表：\n有效位 虚拟页面号 修改位 保护位 页框号 1 140 1 RW 31 当一个线性地址到达MMU时，MMU首先将地址和TBL中的所有表项进行同时查找（并行地），如果存在和地址对应的虚拟页面号，则不需要读取页表而直接得到页框号。如果不存在则查找页表，然后将找到的信息随机替换表中的一个行。\n别看这么做好像没什么用，实际上这极大地提升了地址转换效率。这个表的原理是根据程序的局部性原理提出的（即上一次访问的代码在短时间内有很大可能也被访问）。\n现代的很多CPU没有TBL，都是用软件实现的。如果TBL内没有查找到页面号，则会产生中断，通过操作系统来改变TBL表。\n针对大内存的分页 多级分页 之所以使用二级分页（也可能是多级分页）而不是一级分页，主要是为了大内存而设计的。如果使用一级分页的话，在32位系统下，假设页表大小和页框一样是4KB，那么就需要$2^{20}$个页表，占据内存$2^{20}*4=2^{22}=4MB$内存（假设一个页表项的大小是32位的），你想每个程序都得有自己的页表，操作系统自己还有自己的页表，那得占多大内存啊。所以就采用了分页的方法。分页的好处是：不用的页表可以不放在内存中，而且页表不需要一次性映射所有内存，而是只需要映射已经用到的内存即可，这样就节约了页表本身的大小。如果在地址转换的时候发现指向的页表指向的页面不存在，那么会发生一个缺页中断，操作系统会使用页面置换算法处理这个中断，载入新的页（如果不存在指向的页表项的话也会分配页表项）。这样就极大地减少了页表占用的内存。\n但是超过三级分页的技术用起来很复杂，所以现在主流CPU都是二级分页\n倒排页表 现在来看64位的情况，如果页框还是4KB，那么你得有$2^{52}$个页表，假设每个表项8字节，那你得有超过30000GB的空间来存放页表，就算是使用二级页表也不一定能搞定。所以对于64位系统，提出了倒排页表的骚操作。\n具体做法是这样：以往都是页表指定页框所在位置，现在我们反过来：每个页框中包含一个页表项（比如页框的前8个字节），这样我们就不用页表了。也就是说现在是从物理地址找到线性地址。\n这个算法极大地节省了空间，但是缺点很明显：最坏的可能需要遍历所有页框。解决办法是通过哈希表来加快查找速度。\n32位下的分页机制实例 接下来会展示32位下创建页目录，页表和开启分页机制的代码。再此之前必须看一下Intel对于页目录和页表的格式规定：\n页目录项的格式和页表项的很相似，简单解释一下：\nP位：表示这个页表项指定的页是否存在内存中，为0不存在，不存在会引发缺页中断 RW位：为0表示这个页只能读取，为1表示可读写 US位：为1表示所有优先级的程序都可以访问，为0表示只有0，1，2级程序可以访问 PWT，PCD位：和高速缓存有关，此处不探讨 A位：访问位，表示这个页是否被访问过，由硬件自动改变值，初始值应当为0 D位：脏位，表示这个页是否被写过数据，由硬件自动改变值，初始值为0 PAT位：高速缓存有关，不解释 G位：页是否是全局的，如果为1表示全局的。全局页会在高速缓存中保存以便更快地被找到。 Avail字段：没卵用的3个位，程序员可随意使用 20位的页表基地址/页物理基地址：指的是页表基地址或物理基地址的前20位。因为页表和物理地址必须是4KB对齐的（因为32位下页表和页框的大小是4KB），所以低12位永远是0，这里只保存其高20位即可。 这里是代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 %include \"pm.inc\" section code vstart=0x7c00 [bits 16] jmp start ;GDT表的声明不再给出 PDE_ADDR: equ 0x200000 PTE_ADDR: equ 0x201000 STACK_TOP: equ 0xFFF VIDEO_SELECTOR: equ 0x08 CODE_SELECTOR: equ 0x10 STACK_SELECTOR: equ 0x18 PDE_SELECTOR: equ 0x20 PTE_SELECTOR: equ 0x28 ;从实模式到保护模式以及配置GDT的代码不再给出 [bits 32] code: ;现在开启分页模式 ;先填充页目录 mov eax, PDE_SELECTOR mov es, eax mov ecx, 1024 xor edi, edi mov eax, PTE_ADDR|0x007 .loop1: stosd add eax, 4096 loop .loop1 ;再初始化所有的页表 mov eax, PTE_SELECTOR mov es, eax mov ecx, 1024*1024 mov eax, 0x007 xor edi, edi .loop2: stosd add eax, 4096 loop .loop2 ;让CR3指向页目录 mov eax, PDE_ADDR mov cr3, eax ;打开分页 mov eax, cr0 or eax, 0x80000000 mov cr0, eax jmp .wait .wait: nop hlt code_len: equ $-code 略去了GDT表的声明和从实模式跳到保护模式的代码，直接从22行开始看：\n25行将页目录的首地址给eax寄存器，PDT(Page Directory Table)是页目录表，PTE(Page Table Entry)是页表入口的意思。这里看第9行的定义知道页目录表放在内存处$0x200000$的位置。而第10行明确了第一个页表的物理地址在$0x201000$处（我们这里所有页表都声明，并且页表和页表间是紧挨着的）\n27行将1024传递给ecx，因为页目录需要1024个页表项。\n28行清空EDI，29行制作了第一个页目录项，这里$0x007=000000000111$,即P,RW,US三位为1其它位为0。\n30到33行的循环放置1024个页目录项，之所以eax要加4096，是因为$4096=2^{12}=1左移12位$，即将高20位（页表物理基地址部分）加1，也就是将下一个页表的物理基地址放入。如果某一个页表暂时不在内存中的话，高20位置0即可（这里我们将所有1024个页表都配置了）。\n这个时候页表目录就配置好了，35行开始配置页表，其实是一个道理\n35~36行将PTE给eax。\n37行说明我们要循环$1024*1024$次，因为一个页目录有1024个页表，而一个页表有1024个页表项。而每个页表项指向的页框则是4KB大小，所以一共就是$4KB*1024*1024=4*2^{10}*2^{10}*2^{10}=2^{32}$，即可达到寻址32位内存地址，整个4GB。\n38~43行同理，生成页表项并且放到内存中指定位置。\n45~46行通过寄存器cr3指向页目录基地址，这样CPU就能找到页目录了\n48~50行通过将cr0的最高位置1，来开启分页机制。至此分页机制开启完毕\n52~55行通过跳转清空指令流水线。\n那么我们如何使用分页机制呢？使用的方法如下：\n当寻址32位的时候，页部件将32位分为3部分，高10位用于找到页表，中间10位用于找到物理地址，最后12位是偏移量。\n比如如下指令：\n1 mov edx, [0x1050]\t;假设段的起始地址为0x00800000，cr3指向的PDT地址为0x00005000 首先根据段地址+偏移地址公式，得到最后的目标地址为0x00801050=0000000010 0000000001 000001010000 页部件首先通过高10位找到位于页目录中的页表。主要是将高10位乘以4（每个目录项4字节）再加上PDT地址，这里为$0x5000+0x0002*4=0x5008$，最终处理器从0x5008处得到了页目录项的值，假设为0x08001000。\n然后页部件再从中间10位找到页表项的位置，具体做法也是乘上4然后和0x08001000相加，假设得到最后结果为0x0000C000。\n这个0x0000C000就是内存中你要找的页框地址了。最后的12字节就是表示从页框开头的偏移量，所以最后要将0x0000C000加上这个偏移量，为0x0000C050，这就是最后的物理地址。\n页面置换算法 最后我们来说一下页面置换算法。页面置换算法是在发送缺页中断的时候，将缺少的页从磁盘上拿取到内存中的算法。\n最近未使用页面置换算法（NFU) 页表项里面有一个A位表示此页是否被访问过，和一个D位表示这个页是否被写过。这两个位都是硬件自动修改值的。一般来说硬件会在固定间隔的时间内置这两个位为0。\n最近未使用页面置换算法通过A和D位将页面分为4种：\n第0类：没被访问，没被修改 第1类：没被访问，已被修改 第2类：已被访问，没被修改 第3类：已被访问，已被修改 NRU算法每次都随机地从类编号最小的页面中淘汰一个页面。其优点是容易实现。\n最少使用置换算法（LRU） 就是每次都挑选使用次数最少的页面进行置换。这里的难点就在于如何知道页面的使用次数。一般来说可以跟踪A位，看A位被置1的频率来腿短使用的次数。\n先进先出置换算法 很容易理解，就是将被调入的页面放在队列末尾，然后每次置换的时候淘汰的队列最前面的页面。这个算法不可靠，因为存在时间最长的页面不一定是使用次数最少的页面\n第二次机会置换算法 在先进先出算法上改进的算法。在置换的时候查看队列头部的页面的A位，如果A位为0则表示这个页面又老又没用，直接淘汰。如果A为1则将这个页面的A位清除并放到队列末尾，然后再查看下一个页面。\n这个算法的坏处就是总是要移动节点，很耗时间。\n时钟页面置换算法 在第二次机会算法上的改进。将进程排成环，有一个表指针指向最老的页面。当发生页中断时，查看指针所在处页面的A位，如果为1则清0然后指向下一位，如果为0则将这个页置换为新的页，并且指针向后移动：\n工作集页面置换算法 一般来说，我们采用请求调页的策略，即在一个进程开始的时候，内存中是是没有和这个进程有关的页的，那么进程运行时立刻会产生一个缺页中断，然后运行页面置换算法。在一段时间过后，进程就会在较少缺页的情况下工作。即页面是在需要时被装入，而不是预先装入。\n一个进程当前正在使用的页面的集合叫做工作集，不少系统会跟踪进程的工作集，在CPU切换回进程之前确保内存中存在这个进程的所有工作集。通过这种手段来减少频繁缺页而导致的磁盘请求。这种模型叫做工作集模型。下面就来探讨基于工作集的页面置换算法。\n为了确定工作集，我们必须确定一个k值作为工作集的最大容量。当前页面和前k-1个页面所组成的页面就是页面集。\n基于工作集的置换算法基本上就是找到一个不再工作集中的页面，然后淘汰他。\n工作集时钟页面置换算法 很简单，就是将原本的页面换成工作集。\n参考 CSDN博客-10种页面置换算法\n","description":"","tags":null,"title":"操作系统-3-段和页","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E6%AE%B5%E5%92%8C%E9%A1%B5/"},{"categories":null,"content":"《现代操作系统》的读书笔记，这里记录了进程间通信和互斥的问题。\n进程 进程可以简单地理解为正在运行的程序。一般程序是指编译为二进制文本的文件（如C语言），或者有特定程序去解释执行的文件（如Python），而进程就是操作系统将程序调入内存中运行之后的状态。\n进程的创建 一般有四个情况会导致进程创建：\n系统初始化时：这个时候系统自己会创建一些进程 一个现有的进程执行了创建进程的系统调用：比如在C/S模型架构的服务器中fork子进程 用户要求创建进程：比如你双击了程序图标 初始化了一系列作业（一般在批处理系统中） 存在在后台的进程被称为守护进程（daemon）。在Unix下，系统启动时创建的第一个进程为init进程，随后的所有进程都是其子进程。由此构成了一个进程树。而Windows下进程之间没有任何的关系，不存在进程层级。\n在Unix下，新创建的进程（采用fork函数）会和其父进程共享一份数据，直到其父进程或其本身改变了这份共享的数据，这时，会将共享的数据拷贝一份给子进程。这种做法叫写时复制(Copy On Write)。\n进程的销毁 有如下四种情况导致进程销毁：\n进程正常退出：这个时候进程该做的事情都做完了，于是正常瑞出。 错误退出：由于程序发现了一个致命错误（fatal error）而导致的退出，但是这个错误是可以被程序控制的（比如C语言编译器编译了不存在的文件）。 致命错误：进程产生了一个致命错误，这个是进程没有预料的错误，比如访问了不存在的内存地址。 被其他进程杀死：比如Linux下使用kill命令杀死进程 前两种都是进程自愿退出型。后两种是非自愿退出型。\n进程状态 进程有三种状态：\n运行态：这个时候进程正在运行 阻塞态：这个时候进程被IO阻塞 准备态：进程准备运行 阻塞态和准备态的区别：\n阻塞态是进程在运行的时候，由于IO阻塞或者系统调用引起的。比如C++代码cin\u003c\u003ca;等待用户输入时就是阻塞态。\n而准备态则是进程时间片用完了，CPU将其换下来的状态，是由CPU而不是IO阻塞引起的。\n这三种状态的转换为：\n运行态到阻塞态：正在运行的程序由于IO阻塞，或者系统发现他现在没办法运行（比如调用了pause()函数或者sleep()函数，就会将其切到阻塞态。 阻塞态到准备态：当从IO阻塞恢复，或者可以运行（sleep()函数的事件到了或者在pause()中用户按下了按键）时，CPU并不会直接让其运行，而是先放入准备态等待运行（等待属于其的时间片到来才能运行） 准备态到运行态：进程调度算法准许此进程运行，这时进程就从准备态到运行态 运行态到准备态：进程的CPU时间片用完了，进入准备态等待下次运行。 准备态不可能到阻塞态，因为在准备的进程不能执行代码，所以不可能调用阻塞系统调用或者IO函数。\n进程间通信(IPC)问题 进程间通信被称为IPC（InterProcess Communicate），由于进程间通信而带来的问题就叫做IPC问题。\nIPC总共有三大类问题：\n进程间如何传递消息？ 进程之间如何不产生竞争条件？ 进程取资源的顺序 进程间传递消息的话，在Linux下可以使用共享内存和共享文件，或者管道，Socket套接字。总之这个问题已经有很多解决方法了，也不是讨论的重点。\n重点是后面两个问题，本质上都是由于时间片轮转造成的。竞争条件（race condition）是指\n当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，我们认为发生了竞争条件\n​\t——《Unix环境高级编程》\n《现代操作系统》中举了个例子：\n假设A和B程序的功能都是“在内存中找到下一个空闲区域并放入自己的数据”。首先A读取格子状态，发现其是空的，准备写入数据；这个时候，A的时间片用完了，操作系统让A进入准备态，让B进入运行态。然后B读取了当前格子的状态，写入了自己的数据，并且移动到下一格准备重复上述操作。这个时候，B的时间片到了，B进入准备态，A进入运行态，代码从A离开的那句开始执行。由于A先前判断当前格子是空的，所以会写入自己的数据，这样B的数据就被覆盖了，产生了bug。\n临界区（critical regions） 为了解决竞争问题，提出了临界区的概念：\n临界区指的是一个访问共用资源的程序片段，而这些共用资源又无法同时被多个线程访问的特性。当有线程进入临界区段时，其他线程或是进程必须等待\n​\t——百度百科\n也就是说临界区就是那段要共享的数据区。在每一时刻只能由一个进程进入临界区（访问共享数据）。为了更好的解决竞争，光有临界区还不够，这里首先提出四个条件：\n没有任意两个进程在同一个临界区内 不对CPU的数量和速度做假设 临界区外的进程不能阻塞其他进程 没有进程需要无止境地等待进入临界区 在这四个条件下来研究解决竞争问题的方法。\n一次只能由一个进程进入临界区的情况称为互斥(mutul exclusion)\n忙等待下的互斥 首先考虑使用忙等待来实现互斥。\n关闭中断法 因为CPU切换线程是通过时钟中断的信号来切换的。时钟中断会以一定时间给出一个中断，比如5ns。假设分配给每个进程的时间片都一样，是15ns，那么当时钟中断发生3次就CPU就会切换一个进程。\n所以如果将中断关闭的话就不会切换进程，那样进程就可以完成自己的工作了（比如上面A不仅可以读出格子信息，还能写进去）。\n这是一个防范，但是这个风险非常大。因为中断对于操作系统来说是非常重要的东西，一般在0环实现（内核中），所以将中断的开闭权限给用户的话（3环，用户层）对系统是非常不利的，比如你的程序在关闭中断之后忘记打开了，那CPU就不能切换进程了。所以这个方法被否决\n锁变量法 让一个变量L为锁，初值为0.当有进程要进入临界区的时候，让L为1表示现在临界区里面有进程了。其他进程看到L=1就等待。当进程出临界区时将L设为0以允许其他进程进入。\n这个方法也是治标不治本，因为和上面的竞争例子一样，假设A查看L得知为0，想要进入临界区时CPU切换进程B，B查看L发现为0，设为1后进入临界区。然后CPU切换为A，A再次将L设为1，然后进入临界区。所以这个方法没什么卵用。\n严格轮换法 在变量锁上进一步改进得到自旋锁：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //公共变量turn unsigned int turn=0; //A进程 while(1){ while(turn!=0); enter_critical_region(); turn=1; leave_critical_region(); other_no_share_operator();\t//一些不在临界区内工作的代码 } //B进程 while(1){ while(turn!=1); enter_critical_region(); turn=0; leave_critical_region(); other_no_share_operator();\t//一些不在临界区内工作的代码 } turn作为锁变量（称为自旋锁），记录着当前进入临界区的进程。每一个进程自己有一个ID（这里假设A的ID是0，B的ID是1，并且turn的初值为0，代表允许A先进临界区）。每个进程在进入临界区之前需要判断turn是否为自己的ID，如果为自己的ID则进入。在离开临界区之后将turn赋值为下一个进程的ID。\n这里就算A在判断trun是否为0的时候切换到了B，B也会由于turn=0而无法进入临界区，有效地避免了竞争。\n但是这个算法是不行的，不说B因为忙等待不停地测试turn变量带来的CPU浪费，当A执行完临界区的工作和非临界区的工作后，返回带循环开头第4行，但这个时候B还第20行做非临界区相关工作。那么A就被阻塞不能进入临界区了。这就违反了上面所说的条件3：“临界区外的进程不能阻塞其他进程”。所以这个也不行。\nPeterson的解决办法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #define N 2\t//假设目前有两个进程 int turn; int interested[N];\t//初值全部为0 void enter_critical_region(int process){ int other = 1-process; interested[process] = 1; turn = process; while(turn==process\u0026\u0026interested[other]==1); } void leave_critical_resion(int process){ interested[process] = 0; } 现在只考虑有两个线程的情况。turn是用于标志想要进入临界区进程的自旋锁，intersted则是表示已经进入临界区的进程数组。假设A现在调用了enter_critical_region(0)，这时interested[0]=1,interested[1]=0,turn=1。A通过第十行的判断，进入临界区。就算在第九行被切换为B进程，B也会因为interested[other]==1`的条件而忙等待。\nPeterson的方法是忙等待算法中唯一一个没有什么缺点的算法。\nTSL指令带来的CPU间互斥 要注意到在多核CPU中，各个CPU之间的进程可以真正意义上同时执行，那么当然也会产生竞争条件。这个避免方法是采用汇编指令TSL，现在的CPU一般都带有这个指令：\n1 TSL RX, LOCK 他将内存中LOCK变量的值读入寄存器RX中，并且设置LOCK的值为非0值。需要注意的是**这两部操作是一个原子操作，原子操作就是不可被分割的操作。也就是说在执行TSL指令时CPU不能切换。**那么这个时候就可以写出临界区代码：\n1 2 3 4 5 6 7 8 9 enter: TSL AX, LOCK CMP AX, 0 JNE enter ret leave: mov LOCK, 0 ret enter过程从LOCK中取出其值放入AX中，并且同时将LOCK设为1.然后看AX是否为0，为0表示可以进入临界区，程序返回。为1表示不行，于是回到enter标号中重新执行。也就是说当LOCK值为0时表示临界区现在无进程。\nTSL是的实现不是关闭中断，因为你关闭了一个CPU的中断和另一个CPU没什么关系。它关闭的是CPU到内存的内存总线。\n这个没什么算法可言，主要是硬件指令帮了忙。\n唤醒和睡眠下的互斥 忙等待下的互斥主要是通过让进程忙等待来等待进入临界区，但是这样显然太浪费CPU。我们可以通过将进程变为阻塞态来等待进入临界区（因为阻塞态是不消耗CPU的，只有相关信号到达CPU才会调用进程，其他时候CPU不会分配给进程时间片）。\n一般操作系统有sleep()和wakeup()函数。sleep用于让当前进程进入阻塞态，而wakeup指定将一个通过sleep进入阻塞态的进程进入到准备态。在这个情况下，我们可以用sleep和wakeup函数来改善Peterson的方法了。\nLinux下sleep对应wait()函数，而wakeup对应poll()函数。\n生产者消费者问题 这是一个经典的IPC问题。问题描述如下：\n假设现在有一个共享的固定大小的缓冲区。生产者进程（记为P）的任务是向缓冲区中空白的部分放置数据，而消费者进程（记为C）的任务是从缓冲区中拿取已有数据。如何调节这两个进程？\n首先想到可以先让生产者生产，消费者睡眠，当生产者生产完后唤醒消费者，自己进入睡眠。消费者如法炮制，将缓冲区消费之后唤醒生产者，自己进入睡眠。具体的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #define N 100;\t//假设缓冲区中有100个空间 int count=0;\t//目前缓冲区中被占用的空间 void procedure(){ while(1){ int item = generate_item(); if(count==N) sleep(); count++; wakeup(consumer); } } void consumer(){ while(1){ if(count==0) sleep(); remove_item(); count--; wakeup(procedure); } } 这里显然有一个不足之处，就是两个进程都能对count变量无约束地访问。这就导致如下的竞争条件：\n消费者运行到第16行读取了count，假设此时count为0，然后CPU切到生产者，生产者执行完代码，在第10行唤醒了消费者，然后再次循环到第8行进入睡眠。此时CPU切到消费者，消费者由于之前确认了count为0（实际上此时已经为1），进入睡眠。这样，双方都进入睡眠，程序死循环。\n解决这个问题的一个方法是记录下生产者消费者收到的唤醒，然后在进入睡眠时查看记录。如果存在唤醒记录就不睡眠。但是这样就需要为每一个生产者消费者提供一个额外变量，很占用内存。\n信号量(Semaphore) 为了解决生产者消费者问题，Dijkstra（没错就是搞图论算法的那位）提出了至今都在使用的信号量(Semaphore)。\n信号量的思想融合了锁变量和原子操作：\n信号量为一个特殊的整型变量，其值为0（表示没有保存唤醒操作）或者正数（有一个或者多个唤醒操作）。对其的操作有两个：\nUp操作：又称为V操作，会将信号量的值加1。如果存在睡眠的进程，就唤醒那个进程让其完成其Down操作。 Down操作：又被称为P操作，会先判断信号量是否为0，如果为0，让这个进程睡眠。如果大于0，将其减1. 并且Up和Down操作是原子操作。\n所以Down操作和Up其实是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 void Down(Semaphore s){ if(s==0) Sleep(); s--; } void Up(Semaphore s){ if(s==0){ s++; wakeup_a_process(); } } 这里有一点要注意：如果现在s是0，那么当进行一个Up操作之后，虽然将s加1了，但是被唤醒的进程会立刻将s减1，所以在信号量为0的时候并且有沉睡进程时，对其进行Up操作不会改变信号量的值（为0）。\n一般来说实现UP和DOWN的方法是将其作为系统调用，然后在执行时暂时关闭中断。\n互斥量(Mutex) 如果不需要信号量的计数功能，信号量会简化为互斥量。这个学过多线程编程的都知道，我就不细说了。\n管程 使用过互斥量或者信号量的同学应该知道，如果其解锁代码的位置发生了变化，会带来完全不一样的结果。由于信号量和互斥量使用的复杂性，人们提出了管程。管程其实是编程语言概念，是语言内部带有的。C语言就没有，但是Java就有。管程就相当于一个好用的库。\n消息传递 其实消息传递问题在计算机网络中有很多解法。操作系统里面的方法和计算机网络的差不多，就不一一介绍了。这里主要是说如何用消息传递解决生产者消费者问题。\n我们不用缓冲区进行物品存放，而是采用**信箱📪**的方法。消费者首先传输N个空信封给生产者，生产者接收到空信封之后就往里面填充数据，然后返回信封给消费者。消费者拿出来消费之后再将空信封传给生产者。当有一方没有信封时进入睡眠，直到信封到来。这种算法的好处是没有用到任何的中间缓冲池。\n屏障(Barrier) 这个是为进程组设计的。在多进程程序设计中，尤其是大矩阵分解运算的时候，每个进程都在计算自己的数据，等到所有数据都算好之后再整合为结果矩阵。这时可以用屏障，即当其中一个进程算完后会被屏障阻拦，不能够继续下面的操作，而必须等待直到所有进程完成计算，再一同进行下一次操作。\n一些典型的IPC问题 哲学家就餐问题 现在有五个哲学家坐在圆形餐桌上，他们就干两件事情：吃饭和思考人生。每个人右手边都有一支筷子，要吃饭的时候必须拿起其左右两边各一支才能吃饭。那么如何协调这些哲学家？\n这里的问题在于，如果一个哲学家要开始吃饭，他得先拿起左边筷子再拿起右边筷子。如果其中有一个筷子被人拿了，那哲学家就没有办法吃饭。\n首先可以采用靠运气的方法：每个哲学家想要吃饭时拿起两个筷子。如果其中有一个筷子被拿起来了，那么就将他拿起的筷子放下，然后等待一段随机时间再吃饭。这种算法的思想类似于计算机网络中避免链路拥塞的方法。但是在需要快速反应的RTOS和交互式系统中，这也许不是最好的办法。\n其实解决这个问题很简单，有多线程编程经验的同学应该可以看出来：这里有五个公共的资源——五支筷子，造成竞争条件的原因是因为对筷子的拿起没有约束。所以我们可以对每个筷子加一个信号量（或者互斥锁随便），当哲学家想要吃饭时，先看自己手边筷子齐不齐。不齐的话就不吃饭，齐的话就给筷子上锁，然后拿起筷子吃饭，吃完放下筷子再解锁。这样就解决问题了。\n读者写者问题 这个问题广泛用在机票订购等系统中。说的是现在有一群读者和写者需要访问一块资源。读者只读数据，写者只改变数据。那么如何协调？\n这个问题和哲学家问题以及生产者消费者不一样，因为读者对信息的读取是没有破坏性的，所以可以允许多个读者同时读。但是写者一次性只能有一个。所以我们可以使用先来先服务策略，如果来的是读者，那么直接进入读取数据。但是如果是写者，必须等待临界区中的所有读者读完之后再进入临界区，并且在其后的读者也不允许比他先进临界区。\n其实这个算法可以做一个小小的改进：如果写者到来了，将资源拷贝一份，让临界区内的读者读取拷贝的资源，写者则改变原有资源。这样写者就不用等待读者离开临界区了。但是这很占内存。\n进程调度算法 CPU一次只能运行一个进程的代码。如果想要实现多进程，就必须使用进程调度算法。\n线程有两种类型：\nIO密集型（I/O-bound）：这种进程的大多时间花在IO操作上（比如终端系统） 计算密集型（compute-bound）：这种进程将大多时间花在计算上 随着现代CPU运行的越来越快，程序越来越趋向于IO密集型。\n何时调度进程：\n创建进程的时候。是优先运行父进程还是子进程 在进程退出时。这时CPU必须切换到下一个进程 当进程阻塞在IO或信号量或其他事情上。这个时候也需要切换进程 IO中断发生时。这个时候IO的操作完成了，算法必须决定是否切换到等待这个操作的进程 由于有三种不同类型的操作系统（批处理系统，交互式系统，实时操作系统），所以每个操作系统上的算法目标也不一样：\n共同目标 公平：给每个进程公平的CPU份额 策略强制执行：进程不能违背调度算法 平衡：尽可能让系统各部分忙碌（充分利用CPU和外设） 批处理系统： 吞吐量：单位时间内完成的作业数 周转时间：从提交作业到作业终止的时间（不是作业运行到终止的时间） CPU利用率 交互式系统： 响应时间：响应用户操作的时间 均衡性：满足用户的期望 实时操作系统 满足截止时间：避免丢失数据 可预测性 进程调度算法在大体上分为两种：\n抢占式调度：每个进程运行一段时间，到了规定时间后不管有没有运行完，都切换到另一个进程。 非抢占式调度：进程运行的图中CPU不会切换其他进程，除非进程自己放弃运行，否则进程必须运行完才能切换进程。 批处理系统下的调度算法 批处理系统会接收到一堆称为作业的程序，然后运行他们即可。像很久以前的打孔式机器就是批处理。批处理不提供交互功能，只需要完成到来的作业即可。\n先来先服务（first-come first-serve） 首先可以想到让作业排队，先到来的作业先运行，运行完之后再运行下一个作业。这是非抢占式算法。\n最短作业优先 这种算法需要实现知道作业大概的运行时间，然后当存在一批作业到来时，按时间递增的顺序依次运行作业。这也是非抢占式算法。\n这里要注意的是，一批作业必须同时到来，如果A作业在B后面到来，那么即使A的时间比B的短，B程序也不能停下转换到A程序，因为这个算法是非抢占式的。\n这个算法主要是让平均周转时间最短。假设现在有一批程序同时提交给系统：\n程序 时间 A 5 B 6 C 2 D 1 如果按照先来先服务，周转时间为：\n程序 周转时间 A 5 B 5+6=11 C 5+6+2=13 D 5+6+2+1=14 那么平均周转时间约为$\\frac{5+11+13+14}{4}=10.7$。\n如果按照最短作业优先：\n程序 周转时间 D 1 C 3 A 8 B 14 平均周转时间为6.5，显然是缩小了。\n最短剩余时间优先 这个算法是最低按作业优先的抢占式版本。也就是说不管新作业什么时候来，只要新作业的时间比老作业的剩余时间少，CPU就切换到新作业执行。\n交互式系统下的调度算法 交互式系统是我们用的最多的系统，包括Mac，Windows和Linux系统等。特点是注重和用户的交互，所以响应时间显得尤其重要。交互系统总是采用抢占式算法\n轮转调度 很简单，将进程排成环，CPU给每一个进程分配同样的时间片，时间到了就换下一个进程执行。\n这个算法对时间片长短有要求。因为如果时间片过短，会因为平凡的切换进程导致的存储进程信息时间变长。比如时间片为10ms，但是切换一个进程需要1ms，那这显然很浪费CPU。但是时间片过长的话，系统响应用户的速度将会变慢。所以需要合理选择时间片。\n优先级调度 在轮转调度的基础上发展而来，进程之间不再平等，而是具有优先级。优先级高的进程先被执行，而且只要存在优先级高的进程，就不会去执行优先级底的进程：\n这个算法存在一个缺点：如果高优先级的进程源源不断地到来，那么低优先级进程将无法被执行，这种情况叫做饥饿。\n多级反馈队列 Unix系统采用的方法，在优先级调度上发展起来的算法。同样也是将进程分优先级。但是高优先级的时间片较少，低优先级的时间片较多。而且每个队列的算法可以是不一样的。低优先级的队列可以采用时间片轮转方法，而高优先级队列则采用先来先服务算法。并且还可以通过用户操控改变优先级：比如用户在终端按下了回车键，那么位于优先级3的终端程序会被提升到优先级1，以快速地和用户交互。\n最短进程优先 这个是从批处理系统上借鉴来的。如果有多个进程同时执行的话，我们可以先执行执行时间最短的那个，这样系统的反馈速度会加快。比如你先打开了一个Word软件，然后在其加载的时候又打开了Vim。系统知道Vim的打开时间会比Word短，那么即使Word先打开的，也会运行Vim。\n这里唯一的问题是如何估计进程的事件。在批处理系统中每个作业是重复运行的，所以有较大的把握知道作业的运行时间。但是交互式进程只能猜测：假设某一程序上次运行时间为$T_1$，这次时间为T_2，那么我们可以通过$aT_1+(1-a)T_2$的方式来猜测下次的事件。这里a是老化参数。如果a取0.5的话，那么三轮的猜测时间为 $$ T_1,\\frac{1}{2}T_1+\\frac{1}{2}T_2,\\frac{1}{4}T_1+\\frac{1}{4}T_2+\\frac{1}{2}T_3 $$ 这样先前测量的值会随着时间逐渐减小，这种情况叫做老化。\n保证调度 保证调度为了公平性，如果进程没有优先级的话，保证每个进程运行的时长都尽可能一样。也就是说，如果A进程比B进程先开5小时（并且目前没有结束），那么算法会在后续的运行中多分配B进程时间片，直到弥补B进程少的5小时。\n这个算法也可以用在多用户系统中，保证每个用户的运行时间一致。\n这样系统必须跟踪进程来记录下其运行的总时间。\n彩票调度 这是一种基于概率的（靠运气的）调度方法。系统给每个进程分配彩票，然后等到要调度的时候，从已分配出去的彩票中选择一个，拥有这个彩票的进程呗执行。\n如果某个进程需要更多的CPU时间话，可以分配给其更多的彩票来让其更可能被运行。\n公平分享调度 这是对于多用户系统而言的算法。每个用户都获得等同的CPU时间片（而不管用户内部的调度程序怎么使用），让每个用户的调度时间公平。\n实时系统（RTOS）中的调度 实时系统是指需要对外界反映做出快速响应，并且能快速完成任务的系统。一般而言都是嵌入式系统。比如汽车搭载的系统，当刹车时系统必须及时反映并允许刹车程序。或者是工业机器人中搭载的系统。也就是说正确但是迟到的答案比没有更糟糕。\n","description":"","tags":null,"title":"操作系统-2-进程","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2-%E8%BF%9B%E7%A8%8B/"},{"categories":null,"content":"《现代操作系统》读书笔记\n操作系统的作用 操作系统的作用是在用户层和硬件层之间搭建起沟通的桥梁：\n操作系统对用户和工作在操作系统上的程序员隐蔽了硬件的细节，使得用户有更好的体验。\n举个栗子：比如你要想在屏幕上绘制线段，如果你要自己写操作系统的话，你得和显卡打交道，具体要做的是使用BIOS中断服务打开VGA显示模式，然后向显存（VRAM）的0xA0000地址处写入像素的数据。但是如果你是在操作系统的基础上绘制线段的话，你只需要调用一下操作系统的API即可（或者图形库，图形库本质也是调用API），完全不需要考虑显存的问题。\n内核 内核（Kernel）是指操作系统的最基本的部分，一般可以提供的功能有：\n管理进程 管理文件系统 管理内存 管理网络系统 设备驱动程序 内核将直接和硬件打交道（比如上面所说的VRAM），并且保护硬件不受用户程序乱用。显然，如果用户程序可以像显存写入数据，那你将会在屏幕上任意的地方没有限制地绘制线段，可能会将整个界面弄得一团糟。如果将磁盘的控制权释放给用户将会更加糟糕，用户可以随意更改磁盘上的文件，甚至是内核源代码。所以对硬件的保护是有必要的。\n内核还有可能提供系统调用或者API给用户。\n中断 中断也是内核管理的一部分，中断分为两种：硬件中断和软件中断。硬件中断又分为两种：可屏蔽中断和不可屏蔽中断：\n硬件中断：由硬件带来的中断，像是磁盘的读准备中断等。 可屏蔽中断：可以被屏蔽的中断。被屏蔽之后内核不会对中断做出响应。 不可屏蔽中断：不可以被屏蔽的中断，一定会发生 软件中断：通过软件代码来指定产生中断 中断就是中断当前的事情，执行指定的事情的意思。也就是说，如果发生中断，内核会暂停当前程序的允许，转而去执行中断所指定的程序。执行完之后再返回执行程序（不一定执行中断发生前的程序，因为有些中断就是为了切换用户程序才发生的）。\nAPI API是Application Programmer Interface，通俗的说就是应用程序接口，是一系列运行在用户空间的，可供程序员使用的函数和变量。系统API就是操作系统提供的一些函数和变量，库API就是库提供的函数和变量。\n系统调用 系统调用是一系列运行在内核的函数，然是却可以被用户程序调用。在Linux中，系统调用是用户访问内核的唯一途径。\n当用户程序进行系统调用时，操作系统会从用户控件转移到内核空间，然后在内核控件中执行系统调用。\n比如说，现在用户想要从磁盘上读取一份文件，但是由于内核将磁盘的读写权限保护起来了，用户程序不能直接使用。这个时候用户程序只能进行一个系统调用，切换到内核空间，这个时候由于内核有权限读取磁盘，所以内核会运行磁盘服务，读取数据后将数据返回给用户，并再次进入用户空间。\n并发和并行 并发是指在单个CPU下，由于进程调度算法，给用于一种多个进程同时运行的错觉（其实一个CPU同一时间只能运行一个进程，通过调度算法来回切换时间片给出同时运行错觉）。而并行则是真正意义上的同时进行，并行是指多个CPU的进程同时执行。\n栈和堆 栈是一种特殊的数据结构，符合先进后出。而堆一般指一块随机存储的内存。在NASM汇编中，栈就是section .stack中的数据，而堆则是section .bss中的数据。在C语言中，手动声明的变量时存放在栈中的，这样在程序结束后操作系统会回收栈内的数据；而是用malloc等内存分配函数所分配的数据就是在堆中。在分配的时候操作系统在内存中查找一块符合大小的空白的区域，并将区域的第一个字节的地址返回。系统不会跟踪这块区域，所以在程序结束前必须手动free以防止内存泄漏。\n现代操作系统大部分都会增加对应的结构来记录程序在堆上分配的内存，以便在程序内存关闭后同样清空堆。但是并不是所有的操作系统都存在这种机制（称为内存自动回收）。\n","description":"","tags":null,"title":"操作系统-1-基本知识","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"这里介绍C++中用于断言的三种方式\nstatic_assert static_assert是C++11最新的关键字。用于静态断言，其用法如下：\n1 2 static_assert(布尔常量表达式, 消息) static_assert(布尔常量表达式) 如果给出了消息参数，那么当布尔常量表达式为false的时候会输出消息。\nassert 这是C/C++共同拥有的断言方法，在cassert文件中\n1 assert(表达式) 如果表达式为0会终止程序并且输出一些提示信息（注意是表达式为0而不是表达式为false）。\n这里需要注意的是：assert是仿函数宏（也就是形如#define f(x)这种），你这样写assert(b==false)是不行的，必须用括号将表达式扩起来才行写assert((b==false))。\n而且根据assert的实现，如果你在程序中定义了NDEBUG宏，那么assert函数会什么也不做（当然你得在包含cassert之前声明）。这样我们就可以方便的在调试模式和非调试模式下切换了。\n#error 这个也是C/C++共用的，属于预处理命令：\n1 #error 信息 这个宏只要一出现就会在预编译阶段在有#error的这一行阻止程序，所以你会看到编译器给你在#error处报一个错。\n使用方法的话一般是和#ifdef, #ifndef搭配使用：\n1 2 3 #ifndef MAC #error 不是Mac电脑 #endif 这里如果不是Mac电脑我们就不允许编译。\n","description":"","tags":["cpp"],"title":"C++中的static_assert, assert和#error","uri":"/posts/c++static_assert-assert%E5%92%8C%23error/"},{"categories":null,"content":"在学习《Orange‘S：一个操作系统的实现》时，作者使用nasm和gcc生成ELF文件，然后使用ld命令链接。但是他是在Linux上做的，Mac系统的gcc（clang）只能生成Mac自己的macho64格式的C中间文件，所以需要安装i386编译工具。\n由于书中是在IA32上开发的，所以所有的汇编和C语言都必须编译为32位的ELF，所以我选择了i386系列工具。如果有想要其他架构和平台的，过程也差不多。\n参考博客为Dani Rodríguez的博客（好像要翻墙）\n下载 首先去GNU下载binutils和GCC工具：\n1 2 wget ftp://ftp.gnu.org/gnu/binutils/binutils-2.25.tar.gz wget ftp://ftp.gnu.org/gnu/gcc/gcc-5.2.0/gcc-5.2.0.tar.gz 然后解压\n安装 首先声明变量PREFIX:\n1 export PREFIX=/usr/opt/ 这个变量说明了最后生成的工具安装在哪里，可以改成你喜欢的路径。\n先编译binutils，进入binutils的文件夹，新建build文件夹，进入build文件夹：\n1 2 3 cd binutils-2.25 mkdir build cd build 然后运行configure程序：\n1 2 3 ../configure --prefix=$PREFIX \\ --target=i386-elf --disable-multilib \\ --disable-nls --disable-werror 这里--target说明我们要生成i386-elf类工具，想要其他平台的自行改动。\n等待configure好之后，直接运行make，然后安装即可：\n1 2 make make install 然后安装GCC。先进入文件夹。\n这里要注意，gcc需要gmp,mpc,mpfr,isl三个库。这里比较坑的地方时，isl库最新版本没有GCC编译需要的函数，所以光用homebrew安装isl，在编译时还是会报错。\n这里建议运行：\n1 ./contrib/download_prerequisites 让GCC自己下载并编译需要的第三方库。这应该是一个漫长的等待。\n然后新建build文件夹，进入build文件夹：\n1 2 3 cd gcc-5.2.0 mkdir build cd build configure：\n1 2 3 ../configure --prefix=$PREFIX --target=i386-elf \\ --disable-multilib --disable-nls --disable-werror \\ --without-headers --enable-languages=c,c++ 然后就可以make了：\n1 2 make all-gcc install-gcc make all-target-libgcc install-target-libgcc 至此，所有的工具就安装完成了。\n编译Orange's源码 这里以/chapter5/b文件夹下的源码为例：\n1 2 3 nasm -felf32 foo.asm -o foo.o i386-elf-gcc -c -o bar.o bar.c i386-elf-ld -s -o bar.bin bar.o foo.o 通过使用i386的elf格式工具，可以成功编译出来。\n","description":"","tags":null,"title":"Mac下安装i386编译工具","uri":"/posts/mac%E4%B8%8B%E5%AE%89%E8%A3%85i386%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/"},{"categories":null,"content":"参考博客Luca's Blog\n使用nasm编写函数的时候，函数开头需要有标号（就是这个函数的名称，开头必须是一个下划线），并且标号要用global声明为全局的，并且函数最后一行得使用ret返回：\nglobal _idio section .text _idio: ;todo somthing ret 然后C语言需要声明extern类型的函数:\n1 2 3 4 5 6 extern void idio(); int main(){ idio(); return 0; } 具体的函数返回值和参数取决于你的汇编代码。\n编译的时候Nasm需要使用-fmacho64来编译为Mac系统的64位机器语言：\n1 nasm -fmacho64 idio.asm -o idio.o 返回值的话汇编语言中需要将返回值放到rax中：\nglobal _idio section .text _idio: mov rax, 20 ret 1 2 3 4 5 6 extern int idio(); int main(){ printf(\"%d\", idio()); return 0; } C语言输出20。\n函数参数的话，取决于你使用的C语言编译器和平台。我这里是MacOS系统上的GCC编译器，前六个参数分别放在rdi,rsi,rdx,rcx,r8,r9寄存器中：\nglobal _add section .text _add: mov rax, 0 add rax, rdi add rax, rsi add rax, rdx ret 1 int add(int a, int b, int c);\t//a参数放入rdi，b参数放入rsi，c参数放入rdx 具体什么类型的编译器和平台对应什么参数，见wiki X86 calling convertions\n","description":"","tags":["c","asm"],"title":"Mac下C语言如何调用Nasm汇编函数","uri":"/posts/mac%E4%B8%8Bc%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8nasm%E6%B1%87%E7%BC%96%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"使用gcc的时候只能产生masm的汇编代码。但是masm不是跨平台的，一般开发的时候都是用nasm进行汇编。但是gcc不能直接生成nasm汇编代码。这里记录了生成nasm汇编代码的方法。\n答案来源于stackoverflow。此实验已经在Mac系统上已经尝试成功过。\n生成中间文件 首先需要使用gcc生成中间文件：\n1 gcc -fno-asynchronous-unwind-tables -s -O2 -c -o main.o main.c 如果你的电脑不是32位而是64位的话，gcc默认生成的是64位的中间代码，需要加上-m32来强制指定32位：\n1 gcc -m32 -fno-asynchronous-unwind-tables -s -O2 -c -o main.o main.c 使用objconv转换为nasm汇编代码 然后需要使用objconv工具将中间文件转换为nasm汇编代码：\n1 objconv -fnasm main.o main.asm 如果电脑上没有objconv工具，去这个网站的Object file converter一栏下载，或者直接点击这个下载链接（如果还有效的话）。\n下载下来之后解压，里面只有windows的可执行文件。如果想要在Mac或Linux上使用，解压source压缩包，进入解压后的source文件夹，运行build.sh编译，完成后会生成objconv文件（纯C++写的，不用安装其他库）。\n去除错误的和不必要的代码 objconv会生成一些不必要的代码需要去除，主要是：\n使用global定义的函数名称标签 .SECTION一行中的execute或noexecute，和（如果有需要的话）align=N语句 default rel行 空的段（如果你想的话） 下面是我写的一个perl小程序，可以自动化将c语言转为32位的nasm汇编语言，并去除多余代码（空的段不会去除）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #!/usr/bin/perl use 5.010; use utf8; use strict; sub ConvertC2Nasm{ my $filename = shift; #$filename = chomp $filename; my $output_obj = $filename; my $output_asm = $filename; $output_obj=~s/c$/o/; $output_asm=~s/c$/asm/; system(\"gcc -m32 -fno-asynchronous-unwind-tables -s -O2 -c -o $output_obj $filename\"); system(\"objconv -fnasm $output_obj $output_asm\"); return $output_asm; } sub FixErrorInNasmFile{ my $filename = shift; my @lines; open HANDLE, $filename or warn \"$filename not exists\"; while(\u003cHANDLE\u003e){ if($_=~/global .*$/){ next; } if($_=~/default rel/){ next; } if($_=~/SECTION/){ $_=~s/execute//g; $_=~s/noexecute//g; } push @lines, $_; } close HANDLE; open HANDLE, \"\u003e$filename\"; print HANDLE @lines; close HANDLE; } while(@ARGV){ my $filename = shift(@ARGV); say \"file:$filename\"; FixErrorInNasmFile(ConvertC2Nasm($filename)); } ","description":"","tags":["nasm","c"],"title":"gcc生成32位的nasm汇编代码","uri":"/posts/gcc%E7%94%9F%E6%88%9032%E4%BD%8D%E7%9A%84nasm%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81/"},{"categories":null,"content":"这里主要说明的是使用va_arg,va_start,va_end宏得到的不定参数。\n主要坑爹的地方在于，va_arg这个宏的第二个参数——取出的数值类型，必须是int或者double，而不能是float，char等。如果你在调用函数的时候，char，unsigned char等实数会转化为int，而float会转化为double：\n1 2 3 4 5 6 7 8 9 10 11 12 template \u003cint num\u003e real min(double a, ...){ va_list args; real min = a; va_start(args, a); for(int i=0;i\u003cnum-1;i++){ double value = va_arg(args, double); min = value\u003cmin?value:min; } va_end(args); return min; } 这里如果第7行改成va_args(args, float)会得到乱七八糟的数据。\n还有一个坑爹的地方在于，如果你的参数像上面一样使用的是double，那么：\n1 min\u003c3\u003e(2, 3, 5); 这种调用是错的，你必须明确指出你给的参数是浮点数（只需要至少给出一个即可）:\n1 min\u003c3\u003e(2.0f, 3, 5); ","description":"","tags":["cpp","c"],"title":"C/C++不定参数注意事项","uri":"/posts/cc++%E4%B8%8D%E5%AE%9A%E5%8F%82%E6%95%B0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"categories":null,"content":"《计算机网络：自顶向下方法》的学习笔记。\n这一章记录链路层有关知识\n链路层概述 链路层其实就是最底层的，涉及到硬件的层。链路层中包含节点（运行链路层协议的设备）和链路（将相邻节点连接起来的通信信道）。链路层协议有很多很多种，但是基本上都会将来自网络层的数据报封装在自己的链路层报文中，然后发送给其他节点。\n报文在链路层中的传输就像你从安徽到上海，先坐高铁从淮南到合肥，然后从合肥坐飞机到上海。那么你自己就是爆粉，淮南，合肥和上海就是节点，而高铁，飞机这种运输方法就是链路层协议。\n链路层提供的服务 成帧：链路层会将上层报文封装在自己的链路层帧中（注意链路层不叫做报文而是帧）。由于链路层协议的不同，导致存在多种不同的帧格式。 链路接入：即传输帧 可靠交付：链路层提供可靠交付，也是通过确认和重传实现的。但是对于一些不易出错的链路（如光纤，同轴电缆等），可靠交付显得没有必要。所以很多链路层并不提供可靠交付。 差错检测和纠正：链路层可以检验数据的差错，并且在一定程度上纠正。 链路层在何处实现 链路层的主题部分是网络适配器，也就是通常意义上的网卡。网络适配器里面有很多专门的硬件提供链路服务（因为链路层传输要非常快才行），而且大部分服务也是用硬件直接提供的。\n差错检测和纠正技术 奇偶校验 一维奇偶校验 这个也是很著名的校验方法。这种方法分为奇校验和偶校验。以奇校验为例，假设要传输数据D，那么在真正传输的时候在D后面附上一位，以使整个的数据中1的数目是奇数。然后接收方收到数据之后，检查数据中是不是1的数目加起来也是奇数，如果不是，就表示数据出错了。\n比如我要传输$10010001$，这里有三个1，是奇数个，那么我在最后要附加一个0变成$100100010$，然后传输出去。\n偶校验同理，需要让1的个数为偶数个。\n奇偶校验是非常简单，但是也不是很可靠的方法。因为如果出错的是偶数个位，那么接收方是没办法得知数据出错的。而且奇偶校验方法并不能从错误中恢复数据。\n二维奇偶校验 二维的话提升了可靠性，并且允许在某些情况下纠正错误。主要的方法是将数据分成几组，排列成一个矩阵： $$ \\begin{matrix} d_{1,1} \u0026 d_{1,2} \u0026 d_{1,3} \u0026 \\dots \u0026 d_{1,n} \\\\ d_{2,1} \u0026 d_{2,2} \u0026 d_{2,3} \u0026 \\dots \u0026 d_{2,n} \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \\\\ d_{m,1} \u0026 d_{m,2} \u0026 d_{m,3} \u0026 \\dots \u0026 d_{m,n} \\end{matrix} $$ 然后在每一行和每一列后面加上一个位，来让这个行和列的1是奇数/偶数个： $$ \\begin{matrix} d_{1,1} \u0026 d_{1,2} \u0026 d_{1,3} \u0026 \\dots \u0026 d_{1,n} \u0026 c_{1,n+1}\\\\ d_{2,1} \u0026 d_{2,2} \u0026 d_{2,3} \u0026 \\dots \u0026 d_{2,n} \u0026 c_{2,n+1}\\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \\\\ d_{m,1} \u0026 d_{m,2} \u0026 d_{m,3} \u0026 \\dots \u0026 d_{m,n} \u0026 c_{m,n+1} \\\\ c_{m+1,1} \u0026 c_{m+1,2} \u0026 c_{m+1,3} \u0026 \\dots \u0026 c_{m+1,n} \u0026 0 \\end{matrix} $$ 然后传输这个矩阵。\n由于现在有行和列两个维度来校验，稳定性会比一维的好很多。接收方接收到数据之后，如果不仅能通过行列知道错误，某些情况下还能纠正错误，比如下面这种情况： $$ \\begin{matrix} 1 \u0026 0 \u0026 1 \u0026 0 \u0026 1 \u0026 1 \\\\ 1 \u0026 0 \u0026 1 \u0026 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 1 \u0026 1 \u0026 0 \u0026 1 \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \u0026 1 \u0026 0 \\end{matrix} $$ 可以看到第二行第二列的数据出错了，因为这个是偶校验，而第二行和第二列的1的个数都是奇数个。而且显然第二行第二列的0应当改成1，才能通过奇偶校验，所以我们就纠正了这个错误。\n当然奇偶校验也不是万能的，如果错误多一些是没办法校验和检测到的。\n检验和方法 这个方法在运输层中已经介绍过了，就是讲数据分成n组，然后将n组相加，用得到的和的反码作为校验码的方法。这种和叫做因特网检验和。\n检验和也有可能没办法检测错误，而且没办法回复错误。\nCRC 循环冗余检测（CRC)算法可以说是非常知名的一种算法了。这个算法基本上一定可以检测出错误，是很可靠的算法，不过不能回复错误。\n其基本思想是将数据分为n组，在每一组后面加上一个m位的冗余码。通过这个冗余码，接收方可以进行差错检测（当然冗余码的位数是双方商量好的）。\n这里用例子来说明。假设现在有一组数据111001记为$D$，那么步骤如下\n计算冗余码：\n首先在数据后面加上m个0（m双方已知），假设这里m是3，那么数据变为111001 000，记为$D_{new}$\n然后双方会用实现商讨的一个除数Q来除这个$D_{new}$，这里假设除数是110，需要注意这里的除法是按照异或运算来算的，也就是说本来除法中的减法要改成异或，具体过程如下：\n我们要的是最后的余数。这里的余数是0。冗余码就是余数。\n将冗余码附加到$D$后面（注意是$D$后面而不是$D_{new}$后面），这里余数是0，所以我们附加三个0.所以最后传输的数据就是111001000\n那么接收方要如何验证呢？很简单，只需要再次用除数去除接受到的数据即可。如果余数为0表示没有错，不为0表示出错。\nCRC的优点是非常可靠，缺点是计算量和发送量会变大。你可能会说，诶呀CRC这么牛逼，为什么不在运输层中使用呢？因为CRC的计算非常多，所以放在运输层会增加很多的传输时延。而链路层的CRC是通过专门硬件算的，算的飞快，所以可以在链路层使用。\n多路访问链路和协议 链路层有两种类型的网络链路：\n点对点链路：也就是说在发送方和接收方建立起单一链路。 广播链路：也就是说发送方发送出去的帧会被广播到所有在同一广播信道上的节点中。 点对点链路没什么可说的，问题在广播链路：如何协调多个发送和接收点对一个广播信道的访问呢？如果不加以控制的话，会产生多个信号同时在一条信道上传输的情况，这样信号之间就被影响了，我们称这个情况为碰撞。这种问题就叫做多路访问问题（本质上是避免碰撞）。为了解决这种问题，提出了多路访问协议。多路访问协议有三种，接下来看一下：\n信道划分协议 这一种协议在第一章其实就说过了，其实就是应用时分复用和频分复用来传输帧。这种方式保证了节点之间的公平公正，但是有个缺点：时分复用TDM中，如果到一个节点的时间点但这个节点却不用发送/接收数据的话，这个时间点就被浪费了。在频分复用FMD中，虽然公平公正，但是每个节点也只能以一小段的频率发送信息。\n随机接入协议 随机接入协议的核心思想是：每次信道发送信号总是以全速率发送，当发生碰撞时，就延时一个随机时间，然后在这个随机时间之后再发送。如果还发送碰撞，就再延时。\n下面有两种典型的随机接入协议：\n时隙ALOHA 协议如下:\n所有帧由L比特组成 时间被划分为长度为L/R秒的时隙（一个时隙就是传输一帧的时间，R是传输的最高速率） 节点只在时隙开始的时候传输帧 节点是同步的，每个节点都知道时隙何时开始 如果在一个时隙中发现碰撞，就随机延时n个时隙之后再次发送。（精确的描述是这样：节点会以概率p在下一次时隙到来时发送） 如果在这个时隙发送成功了，这个时隙就叫做成功时隙。\nALOHA 时隙ALOHA要求所有节点同步传输（在每个时隙时传输），但是纯的ALOHA协议不需要。当网络层的报文到达之后，会立刻封装成帧并且发送出去。如果碰到了碰撞，会先等待一个帧传输时间，然后以概率p传输该帧，或者1-p的概率继续等待。\n载波侦听多路访问（CSMA） CSMA是一个非常拟人规则：\n在说话前先听：如果在发送帧之前信道上有其他节点的活动，就等待直到存在一小段空闲的间隙再传输。这种传输前先听信道的方法叫做载波监听。 如果和他人同时说话，则停止说话：这种情况被称为碰撞检测，即如果在传输时发现有其他节点在干扰传输，则立刻停止并等待一个随机时间，然后再等待新的时间间隔。 这个时候就有人问了：那既然每个节点发送前都会监听，那为什么还会有同时说话的情况？这是因为信号传输时需要时间的，如果A发送信号后B还未监听到信号，那么B也会发送信号，这样A和B的信号就会碰撞了。\n具有碰撞检测的载波监听多路过访问（CSMA/CD) 使用CSMA比较经典的协议就是CSMA/CD协议，其过程和CSMA一模一样，只不过在最后一步“立即停止并等待一个随机时间”中的随机时间上采用二进制指数后退算法，即在经历了连续的n此碰撞后，从集合${0,1,2,4,\\dots,2^n-1}$中选择一个延时值。采用这种算法的好处是可以更快地找到空闲的时间，而不必做出大量等待时间。\n轮流协议 主要分为两种\n轮询协议 存在一个主节点，主节点以循环的方式询问信道上的各个节点：“你要不要发送/接受数据啊？”，如果得到了对方的肯定，就让对方占用信道。未被询问到的节点不能占用信道。\n这个方法很快，都不需要碰撞检测算法。但是缺点很明显：如果主节点凉了，那整个信道通信就凉了。而且还加入了轮询所需的时间。\n令牌传递协议 每个节点像是环链表一样，知道自己的下一个节点是谁，然后其中一个节点拥有令牌。拥有令牌的节点可以占用信道，如果此时不用，需要将令牌传递给下一个节点，以此类推。\n这个协议效率贼高，但是也有缺点：万一令牌丢失了，或者某个节点忘了释放令牌，会造成堵塞。而且如果一个节点崩了，那整个循环就崩了。\n链路层寻址和ARP 链路层寻址 网络层以上的层有IP地址进行寻址，那么链路层是如何找到对方的呢？答案是使用MAC地址（又称为LAN地址，物理地址）。\n主机和路由器是没有链路层地址的，而是他们的网络适配器有链路层地址（通俗说就是地址在你的网卡里面）。具有多个网络接口的主机或路由器会有与之关联的多个MAC地址。\nMAC地址长度为6字节，虽然MAC地址设计是写在硬件里面不可更改的，但是也有黑客可以通过软件伪造MAC地址。和IP地址一样，没有两个网路接口的MAC地址是一样的，MAC地址由IEEE组织管理。\n一般写MAC地址都是两个字节为一组，以十六进制表示，并且以减号分隔，像是1A-23-F9-CD-06-9B。而且所有位是1的MAC地址是MAC广播地址，即经过这个地址的帧会被广播到局域网上的所有节点中。\n这个时候有人问了：为什么有了IP地址还要有MAC地址呢？这是为了各层的独立。因为链路层上面并不一定要是网络层，还可以是其他的层（只不过当今网络体系基本都在用应用层到链路层这四层模型），所以链路层要单独有标识自己的地址，方便和其它层拼接。\nARP ARP是地址解析协议，是将IP地址解析为MAC地址的一种服务。有点像链路层的DNS服务。其反向相依RARP将MAC地址解析为IP地址。链路层也是通过这个协议才能从网络层的IP地址得到目标的MAC地址。\nARP主要通过维护一个ARP表来进行地址转换，比如下面这种：\nIP地址 MAC地址 TTL 222.222.222.111 88-FA-12-FA-8C-2B 13:45:00 其中TTL是这个行被记录时的时间。\n如果MAC地址不在表内，发送方会构造一个ARP分组，然后将分组广播出去，得到ARP响应分组，从而得到MAC地址。ARP是即插即用协议，同时由于承载了IP和MAC两种地址，被称为跨越网络层和链路层的协议。\n具体的ARP和RARP协议内容见《TCP/IP详解：卷一》。\n以太网 以太网现在占据着几乎所有的有限局域网市场。在你看《TCP/IP详解》的时候你还会看到令牌环和FDDI网，那些都是以前和以太网竞争的网络类型，不过现在几乎都被以太网打败了。\n以太网帧 以太网帧的格式如下：\n前同步码 目的地址 源地址 类型 数据 CRC校验码 数据字段（46~1500）字节。以太网的最大传输单元（MTU）是1500字节。如果不同类型的网络连在一起的话，就必须选取多个网络的MTU中最小的，称为Path MTU的MTU。\n目的地之和源地址都是MAC地址而不是IP地址。\n类型用于表示当前帧是什么类型的服务，比如ARP服务或者其它。\nCRC就是我们上面说的CRC校验码\n前同步码是8个字节的，前七字节都是10101010，用于唤醒接收帧的适配器，并且将他们的时钟和发送方时钟同步，相当于快递告诉你“正在派送中”。第八个字节是的最后两位会警告接收方“重要的数据要来了”，相当于快递到你家楼下了，打电话给你说我已经到了，你在哪一层这种，这个时候你就要打开大门，等着快递上来。同样，接收方也会准备好接收数据。\n交换机 以前以太网中使用的是集线器，集线器作用于每个比特，并且将其放大，相当于信号放大器。现在使用的是交换机，用于转发和过滤帧。过滤是决定搞一个帧应当转发到哪个接口还是要丢弃的功能，转发就是决定一个帧应当发送到哪个接口，并且发送的功能。\n交换机也有一个类似于ARP表的交换机表：\n地址 接口 时间 62-FE-F7-11-89-A3 1 9:13 如果没有地址，则广播帧来获得地址。而且在一定时间之后，没有用到的地址会被去除。\n具体流程如下：\n交换机初始列表为空 对于每个接口接收到的入帧，交换机存储地址，接口和帧到达的时间。 如果在一段时间（称为老化期）之后，交换机没有接收到以该地址作为源地址的帧，那么会将这个地址的信息删除。 交换机也是即插即用设备，并且是自学习的，不需要人工操作的。\n交换机的优点如下：\n消除碰撞：通过交换机的报文会被缓存，一个时间只会有一个帧传输 异质链路：如果两个链路的介质不一样，或者传输速率不一样，交换机可以自动适配。 管理：提供了网络安全性。如果一个适配器连续不断地发送帧，交换机可能会察觉到并且断开该异常适配器的连接。 需要注意到的是，交换机和路由器本质上是不同的，一个是链路层设备，一个是网络层设备。\n","description":"","tags":null,"title":"计算机网络-6-链路层","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-6-%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":null,"content":"《计算机网络：自顶向下方法》的学习笔记。\n这一节记录了路由选择算法，主要是对关联向量算法的解释。\n简介 路由器在接收到分组之后，需要找到最快传递到目的地的路径。确定这种路径的算法就是路由选择算法。\n现在实现路由选择算法有两种方式：\n每路由器控制：指每个路由器运行一种路由算法的情况，每台路由器都有分组转发和路由选择功能。这种主要是将计算负担放在路由器本身。 逻辑集中式控制：指只有一台机器运算路由选择算法，路由器想要找到路径的时候需要向此机器请求路径。这种主要是将计算负担单独放在一台机器上。一般来说，每个路由器都有一个控制代理（CA)，每当要得到路径的时候，需要CA向逻辑集中式路由选择控制器发送请求，得到路径后传给路由器。CA之间不能互相交流，也不能参与路由选择运算。 路由选择算法的分类 有三种分类方法\n集中式还是分散式： 集中式路由选择算法：用完整的，全局性的网络信息计算出从源到目的地的最低开销路径。也就是说每个路由器（或者集中式路由选择控制器）需要知道整个网络线路的信息。我们这里会介绍其典型算法链路状态算法。 分散式路由选择算法：路由器以迭代的，分布式的方式进行计算。没有节点拥有整个网路的信息，其每个路由只需要与其相邻的路由的信息就可以开始工作。这里会详细说明其典型算法距离向量算法。 静态的还是动态的： 静态路由选择算法：路由随之间的变化非常缓慢，通常是人工进行调整 动态路由选择算法：路由器自己可以随着网络哦流量负载和拓扑发送变化，但是会受到选择循环和路由振荡之类的情况影响 负载敏感的还是迟钝的 负载敏感算法：链路开销会动态的变化以反映出底层链路的拥塞水平，如果拥塞过高会趋向于绕开该链路来选择路由。 负载迟钝算法：某条链路的开销不能反映拥塞水平。 链路状态路由选择算法和距离向量算法 链路状态路由选择算法 这个算法是集中式的算法，每个路由器都会知道整个网路的情况。具体怎么知道的是用链路状态广播算法来完成的，也就是将当前路由器的状态广播给所有路由器。所以每个节点可以并行地计算出下一跳目的地。\n具体的算法有很多种，因为这个问题是完全的图论问题，只需要将路由器当做节点，路由器之间的路径当做边，并且测量出边的开销（分组通过此边的开销）即可。所以你可以使用任何的最短路径算法来解决。比较常用的是Prim和Dijkstra算法。这两种算法数据结构中详细说过，我就不再说明了。\n距离向量算法 这个算法是分布式的，迭代的，异步的和自我终止的。\n分布式的：此算法需要路由器将自己的信息发送给其相邻路由器。 迭代的：这个过程要持续到相邻路由器之间没有更多信号交换位置 异步的：不要求所有路由器同时运行此算法 自我终止的：没有计算应该停止的信号，它会自我停止。 首先我们定义：\n邻居：最接近当前路由器的其他路由器为当前路由器的邻居，即当前路由器可直达的路由器为其邻居。\n开销：分组经过一跳所耗费的时间。从x路由器到y路由器的开销记为$c(x,y)$\n然后我们还得知道一个重要公式：：Bellman-Ford公式：\n令$d_x(y)$为路由器x到y的最低开销路径的开销，那么Bellman-Ford公式为： $$ d_x(y) = min_v{c(x,y) + d_v(y)} $$ 其中$v$为x的所有邻居\nBellman-Ford公式说明了：在图中，从x到y的最短路径是集合${x到y的距离+x相邻节点到y的最短路径}$中的最小值。\n这也很好理解：如果对于x的任意邻居v，存在v到目的地y的最短路径，那么显然从x到y的最短路径就是 从x到v再从v到y的最短路径值的最小值。\n有了Bellman-Ford公式，任意一个分组从x到y的算法就可以如此描述：\n通过公式找到最短路径上的下一跳路由$v^*$ 将分组转发给$v^*$ 再在$v*$上应用公式得到$v*$的下一跳地址，以此类推，直到分组到达目的地。 为了实现这个算法，需要定义距离向量：\n距离向量$D_x=[(D_x(y): y\\in 不包括x的路由器集合)]$是x到除了自己的所有路由器的开销估计。\n所以现在，每个路由器x需要维护三个量：\n对于每个邻居v，从x到v的开销$c(x,v)$ x自己的距离向量$D_x$ 它的每个邻居的距离向量$D_v$ 每个节点不时地向其邻居发送自己的距离向量，邻居接收到距离向量之后，会按照Bellman-Ford公式重新计算自己的距离向量：\n$D_x(v)=min_v{c(x,v)+D_v(y)}$\n如果距离向量的值变了，他也会如法炮制，向自己的邻居传递自己的距离向量。\n在不停地传递距离向量的情况下，所有路由器的路由表总会更新到最短下一跳。这样就得到了最短路径。\n距离向量（DV）算法的缺陷 距离向量算法会遇到选择环路，假定现在有如下路由链路：\na---1---b \\ / 4 \\ /50 c 假设我们要从a传送到c，那么这里a的距离向量是$D_a(b)=1,D_a(c)=4$，b的距离向量是$D_b(a)=1,D_b(c)=5$，c的距离向量是$D_c(a)=4,D_c(b)=5$\n那么从a传送到c就最短就是4（$D_a(c)=\\min{d_a(c)+d_a(a), d_a(b)+D_b(c)}=\\min{4+0, 1+50}=5$）。\n现在假设a到c的路径变成60了，那么假设a先检测到了路径开销变化，并更新自己到c的距离向量，是$D_a(c)=\\min{D_a(a)+D_a(c), D_a(b)+D_b(c)}=\\min{0+60, 1+5}=6$，显然是错误的计算结果，但是节点a会认为他是对的。\n然后现在a要发送分组给c，它会先将分组发给b。由于b还没有更新距离向量，所以b又会将分组还给c（他认为最短路径是b-\u003ea-\u003ec），一次往返，形成循环。\n这个过程会增加分组传送时间。解决的办法是毒性逆传，意思是当a发现从b来的分组的下一跳还是b的话，就告诉b从a到b的距离是无穷大，这样再将分组传回b之后b就不会再往a传了。\n可惜的是毒性逆传并不能解决大于三个顶点的环路情况。这也是DV算法的缺陷。\n","description":"","tags":null,"title":"计算机网络-5-网络层-路由选择算法","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-5-%E7%BD%91%E7%BB%9C%E5%B1%82-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"《计算机网络：自顶向下方法》的学习笔记。\nIP协议存在于网络层，网络层是将运输层送到网络边缘的分组发送到路由器的层。而IP协议就是运行在网络层的协议。\nIPv4 IP协议分为两种，一种是IPv4一种是IPv6。IPv4是目前广泛运用的，而IPv6则是为了弥补IPv4中IP地址不足而提出的\n数据报格式 首先来看一下IPv4的数据报格式：\n版本：表示IP版本，IPv4是4。 首部长度：整个首部的长度（不包括数据）。 服务类型：标识当前数据报代表什么类型的服务。因为有很多基于IP的服务，如FTP和ICMP等，这里就是给出服务的标志（详见《TCP/IP详解：卷一》。 13比特片偏移：和运输层报文段一样，如果IPv4报文段过大会分片，而IPv4不想TCP使用序号标志，而是使用比特偏移来标志当前片的位置。 寿命：即TTL（Time-To-Live），这个是防止数据报在网络中无尽循环传输的。比如现在有两个路由器A和B，A可以通过路径P1通往B，B可以通过路径P2通往A。这个时候数据报到A路由器，路由器和他说，你下一站是B，然后他跑到B问B下一站在哪里，B说你下一站是A。那这样数据报就在A和B两个地方不停地跑，形成了死循环。TTL是数据报的寿命，没到一个路由器就会减一，如果路由器发现TTL是0就会丢弃这个数据报。 上层协议：表明这个数据报应当交给运输层的哪个协议，6位TCP，17位UDP。 首部检验和：和运输层一样，用于校验内容。有两个地方要注意： 计算方式：计算方式是将首部轴每两个字节分为一组，用反码算数对这些数求和，该和的反码就是校验和。 每次重新计算：由于TTL没过一个路由器会减一，所以每次到达新路由器，路由器都必须重新计算校验和 源IP地址和目标IP地址：这个就是发送方的IP地址和接收方的IP地址 选项：允许首部被扩展以增加一些其他功能，不过很少用到，IPv6已经废弃了这个字段 数据：上层给出的数据 数据报一行32比特，所以首部最小一共是$5*4=20Bytes$。\nIPv4编址 IPv4地址的表示 这里不得不说人尽皆知的IP地址了。IPv4中IP地址4字节，每一个字节为一组，共分为四组，每组以一个点分割，形成如198.2.10.1这种表示，称为点分十进制表示。\nIP其实并不是代表主机的地址，而是代表接口的地址。接口是主机和物理链路之间的边界，或者路由器和其任意一条链路的边界：\n这里直接是链路，圆是路由器，矩形是端系统。一般主机只有一个接口，所以主机自己带有一个IP地址（这里用黑色表示）。路由器可以有多个接口，比如左上方的路由器就一共有三个接口（分别是和两个端系统相连的233.1.1.0和连接向右边路由器的1.18.1.33和连接向厦门路由器的1.19.2.4）。同样地其他两个路由器也有三个接口。\n子网 假设现在你开了个公司，你得向ISP要IP地址对吧。那么这个时候假设你的公司里面有三台联网的电脑，难道你就要三个IP地址吗？显然我们得多要一点以备以后增加电脑所需。而ISP分配给你IP地址也不是一个一个分配的，而是一次性分配给你一堆，比如它会将233.1.1.x下的所有IP分配给你，那么你就有233.1.1.1 ~ 233.1.1.254这么多地址了。\n子网其实就是分配给你的IP地址范围，比如233.1.1.3就在233.1.1.x子网下，而由于最左侧24个位定义了子网，所以在233.1.1.0后面加个/24来表示子网。以前叫/24子网掩码，现在不这么叫了。这种表示子网的方法叫做无类别域间路由选择（CIDR）\n举个栗子，比如129.3.0.0/16的意思就是左边16位是子网，那么你的主机IP就可以是129.3.0.1~129.3.255.254了。\n为什么129.3.0.0和129.3.255.255不能作为主机IP呢？因为除了子网之外的数值不能全是0或1.如果全是0代表当前子网，你看上图中路由器是不是最后8位都是0，那如果你主机最后还是个0，不是和路由器IP重了吗，那数据报到达之后路由器怎么知道送往哪一个主机呢。而全为1的话表示广播地址，发往广播地址的数据报会分发给当前子网下的所有主机（有时候路由器也会选择性地发到外部网络，不过一般不这么做）。\n子网的计算方法 现在问一下，上图中一共有多少个子网？\n答案是6个，首先可以明显判断路由器和主机相连为一个子网，所以有3个子网，还有三个如下图：\n图中绿色圈出来的就是子网，诶没想到吧。\n子网可以通过如下方法确定：\n为了确定子网，分开主机和路由器的每个接口，产生几个隔离的网络岛，使用接口端接这些隔离的网络的端点。这些隔离的网络中的每一个都叫做一个子网\n网络的分类和子网掩码 这一部分现在已经废弃了，记录下来主要是为了应付考试。\n网络分类 在CIDR出现之前，确定子网是通过将网络分类的方式。主要是将IP地址分为ABCDE五类，每一类都有确定的子网号和主机号：\n图片来自于CSDN\n同理可计算出ABCDE网络的范围：\nA: 0.0.0.0 - 126.255.255.255 B:128.0.0.0 - 191.255.255.255 C:192.0.0.0 - 223.255.255.254 D:224.0.0.0 - 239.255.255.254 E:240.0.0.0 - 255.255.255.255 子网掩码 在给网络分类之后，ABC类网络都有默认的子网掩码：\nA: 255.0.0.0 B: 255.255.0.0 C: 255.255.255.0 所谓子网掩码就是用来区分网络号和主机号的掩码，子网掩码是1的地方对应IP地址就是网络号，为0的地方对应IP地址就是主机号。比如126.123.3.3这个IP是A类网络，其默认子网掩码是255.0.0.0，那么其网络号就是126.0.0.0，其主机号就是123.3.3。\n所谓网络号就是子网号，和用CIDR表示的126.123.3.3/8表示的126.0.0.0一样，而主机号就是在这个子网中主机可以使用的IP号，就是子网掩码0对应的位置。\n内网和外网 内网就是局域网（LAN），而外网就是互联网。我们可以通过调制解调器将多个主机连在一起形成局域网，或者将主机连接到通往外网的路由器来连接到外网。具体解释如下：\n摘自CSDN czl_Serena\n外网：即互联网，局域网通过一台服务器或是一个路由器对外连接的网络，这个IP地址是惟一的。也就是说内网里所有的计算机都是连接到这一个外网IP上，通过这一个外网IP对外进行交换数据的。也就是说，一个局域网里所有电脑的内网IP是互不相同的,但共用一个外网IP。在局域网中，每台电脑都可以自己分配自己的IP，这个IP只在局域网中有效。而如果你将电脑连接到互联网，你的网络提供商（ISP）的服务器会为你分配一个IP地址，这个IP地址才是你在外网的IP。两个IP同时存在，一个对内，一个对外。当你家里买了两台电脑，你想组建一个局域网，你除了要用网线和路由器等设备将两台电脑相连，你还要将两台电脑设置固定IP，比如电脑A设为192.168.1.2，电脑B设为192.168.1.3，这样你就可以用这两个IP地址互相访问两台电脑，但这两个IP地址只在这两台电脑间有效，对外网无效。所以局域网中分配的IP与广域网中的IP完全没有对应关系。你在内网的机子在上网时，都是在向网关发出请求，再由网关（一般为路由器）用外网IP转到INT网上，接受数据后，再分发到你的内网IP上。\n也就是说，在局域网中我们可以自己手动设置自己的IP地址，这个IP就是内网IP。如果你想要连接到互联网的话，路由器会通过DHCP协议给你分一个IP，这个IP就是外网IP。\n通过如下指令可以得到同意网关下的所有内网IP:\n1 arp -a 通过如下命令可以得到外网IP：\n1 curl ifconfig.me 动态主机配置协议DHCP 一旦你获得了一个子网，就可以为子网中的主机分配IP地址了，你当然可以手动分配，但是也存在着名为DHCP的自动IP地址分配协议。这个协议广泛用于无线网中（移动端接入网之后，DHCP分配一个IP给他，等用户走了只会自动归还IP）。\nDHCP本质是一个C/S架构的协议，你可以配置DHCP给每次连接的主机相同的IP，或者随机给它个临时IP。由于DHCP可以自动分配给连入网络主机IP的能力，所以又叫做即插即用协议和零配置协议。\n要使用DHCP，你的子网内必须有一个运行着DHCP服务的服务器，或者有一个DHCP中继代理（每次请求DHCP服务时，中继代理会帮助你和真正的DHCP服务器通信）。\n从DHCP得到IP分为四个步骤：\nDHCP服务器发现：一台新到达的主机要向广播地址255.255.255.255发送源地址为0.0.0.0的报文。由于DHCP服务器在子网中，所以会受到来自广播的这个报文。 DHCP提供：受到报文之后，DHCP会找一个IP地址填入报文，然后再通过广播地址发送给主机。报文内有分配的IP地址，事务ID，网络掩码和IP地址租用期（即这个IP地址的最长使用时间）。 DHCP请求：由于一个子网中可能存在多个DHCP，可能会发送多个DHCP提供报文，所以主机必须选择一个报文并给予响应，表示我要用你给我的IP地址了 DHCP ACK：在客户响应报文之后，DHCP也会回应一个ACK报文表示“好的，你就用这个IP地址吧，我记录下来了”。 一旦DHCP ACK报文接收到之后，主机就可以在租用期内使用这个IP了。\n网络地址转换NAT NAT用于网络地址转换，具体的背景请见百度百科：\n随着接入Internet的计算机数量的不断猛增，IP地址资源也就愈加显得捉襟见肘。事实上，除了中国教育和科研计算机网（CERNET）外，一般用户几乎申请不到整段的C类IP地址。在其他ISP那里，即使是拥有几百台计算机的大型局域网用户，当他们申请IP地址时，所分配的地址也不过只有几个或十几个IP地址。显然，这样少的IP地址根本无法满足网络用户的需求，于是也就产生了NAT技术。\n简单地来说，就是IP地址不够了，导致我们得想个办法减少IP地址的使用率。\nNAT服务一图就可以表示完全：\nNAT会隐藏内部的主机，只暴露自己的IP地址。比如主机10.0.0.1的8080端口发送了一个报文，NAT会将其源IP地址变为自己的IP地址（这里是138.76.29.1），并且将端口号也给换了（假定换成5339），然后在内部的转换表中记录一下端口和IP的映射。在将数据报发出去。这个时候外部网络就会以为是IP为138.76.29.1的主机上的5339端口发送的报文。然后目的地会返回请求的数据，数据也是首先到达NAT路由器，路由器通过转换表发现5339端口应当转换为8080端口，IP为10.0.0.1的主机，于是给10.0.0.1主机的8080端口转发这个报文。\n网关和路由器的区别 网关是网络边缘的器件，连接两个不同类型的网络，让两个端系统相互通信。而路由器则是转发分组，通过路由选择协议发送报文。不过现在的路由器都带有网关的功能，所以基本上路由器就是网关。\nIPv6 在2019年11月25日时，IPv4地址以及全部用完。互联网进入了IPv6时代。\n有关IPv6的细节见《TCP/IP协议》，这里只略微提到一点。\n数据报格式 版本：IPv6是6。需要注意的是，简单地将版本换为4是没办法变成IPv4报文的 流量类型：和IPv4的服务类型差不多 有效载荷查干度：在定长的40字节首部之后的数据长度 下一个首部：和IPv4的“上层协议”一样 跳限制：就是TTL 源地址和目的地址：地址增长到了128位（16字节），这样就不用担心地球人用完IP地址了。 数据：上层要传输的数据 从IPv4到IPv6的迁移 首先带来的问题是如何将IPv4机器升级到IPv6机器。这个吧目前没什么好解决办法。其次是使用IPv6的路由器如何将数据转发到使用IPv4的路由器上（总不能把所有IPv4路由器都换了吧），这里提出的解决办法是建隧道：\n这里相连的IPv4路由器被视为一个隧道。IPv6路由器会将数据报放到IPv4数据报的数据字段中，这样IPv4路由器并不知道自己已经携带了IPv6信息了，它会直接传给和它相连的IPv4路由器，直到IPv4路由器将数据传给IPv6路由器，IPv6路由器会从其数据字段部分解析出IPv6数据报，然后继续传送。\n","description":"","tags":null,"title":"计算机网络-4-网络层-IP协议","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-4-%E7%BD%91%E7%BB%9C%E5%B1%82-ip/"},{"categories":null,"content":"《计算机网络：自顶向下方法》的学习笔记。\n运输层是只工作在端系统的层，用于将应用程序的网络消息传输到网络边缘，以及从网络边缘得到数据并发送给应用程序。\n运输层的中点是TCP和UDP协议，重点中的重点是TCP协议。\n如果你想要详细了解TCP，UDP以及网络层的IP，ICMP协议的话，强烈推荐你去看《TCP/IP详解：卷一》\n运输层的主要作用 运输层和其下的网络层，虽然看上去很像，但功能并不一样。运输层的特点是：\n只运行在端系统，也就是只运行在主机，在路由器，调制解调器等中继器件上是不支持的。 用于将数据从应用程序移动到网络边缘。 而网络层则是运行在路由器等硬件上。每次运输层将应用程序想要发送的信息移动到网络边缘，然后由网络层传输数据到另一个主机，然后运输层再从网络边缘将数据移动到另一个主机上的应用程序，完成一次数据传送。\n运输层是通过Socket套接字和应用程序交互数据的，而网络层则不能感知到套接字。\n比如你现在通过浏览器上百度，首先浏览器会使用HTTP协议生成一个数据包，然后网络层将这个数据包发送到无线网路由器或者调制解调器（取决于你联网的设备），然后运行在路由器和调制解调器（主要是路由器）上的运输层通过一系列算法将数据传向下一个路由器，一直传到搭载百度HTTP服务器的主机上，然后网络层再从路由器或调制解调器将数据搬运到百度HTTP服务器端，完成一次请求。\n而且网络层只会作用于网络层报文段，是不会检查运输层报文段的。\n运输层提供了不同主机上进程的逻辑通信，而网络层则是提供了不同主机之间的逻辑通信。\n运输层的主要协议：TCP和UDP 协议概述 运输层主要是TCP和UDP协议。TCP协议的特点是：\n面向连接的服务。通信双方每次通信都得建立连接，如果连接不能建立，那么是无法传送数据的。 全双工的连接。你可以通过一条连接发数据给我，我也可以通过同样一条连接发送信息给你。 可靠的连接。TCP通过一系列手段保证数据可靠地传输到目标地点。 而UDP简直是TCP的对立面，其特点是：\n面向流的（无连接）服务。通信双方不需要建立连接，发送方想什么时候发信息就发信息，而不管接收方是否在接受信息。 不可靠服务。UDP完全不管你的数据是否正确送到了，它只管发送。 虽然UDP看上去很废柴，但是UDP的效率很高。TCP为了维护可靠的连接，首先得进行三次握手建立连接，还要通过窗口，定时器等一系列操作保证数据传输，所以会很费时间。TCP用在HTTP协议，网络游戏等。而UDP则用于实时通讯，语言交流等对延时要求很高的程序。\n这里需要注意的是：TCP的可靠连接是TCP自己的能力，丝毫不依赖下层（运输层和链路层）。因为在运输层的IP协议是一个“尽力交付”协议（也就是不可靠的）：我尽力将数据传送到，但是到底能不能传送到就不是我的事情了。而TCP在运输层通过很多方法来确保可靠，和IP协议完全无关。\n多路复用和多路分解 TCP和UDP从网络层拿到数据之后不是直接给应用程序，而是给应用程序生成的套接字。那么将运输层报文段中的内容交付到正确的套接字的工作就是多路分解，而相反，将套接字生成的数据附上首部信息，并且移动到网络层的工作就是多路复用\nUDP协议 UDP的特点使得UDP拥有如下优点：\n应用程序可以更加精细地控制数据发送的时机和内容。因为UDP接收到数据之后就送出去了，而没有TCP繁琐的操作。 无需建立连接。UDP可以更快地发送数据 无连接状态。由于TCP需要保持可靠连接，所以需要一些内存来保存信息。而UDP则不需要 分组首部开销小。UDP的首部只有8字节，TCP则有20字节。 UDP报文结构 长度是指包括首部和数据的UDP数据报的长度。校验和是是接收方用来检验数据是否出错的信息。\n校验和（Check Sum） UDP提供了差错检测功能，可以通过校验和来得知接受的数据是否出错。具体算法是所有信息（除了校验和）分为16比特一组（少的补0），将所有的组全部加起来，溢出的位回卷，然后取反码。\n所谓回卷就是将溢出的位和第一位相加。\n比如我现在要传一个空信息到百度（数据部分为空）：\n1 2 3 源端口号:8080 = 00011111 10010000 目标端口号:80 = 00000000 01010000 长度:8字节 = 00000000 00001000 那么三个加起来是0001111111101000，然后取反码，就得到校验和1110000000010111。\n校验的方法就是将校验和和所有数据（除了校验和）加起来，如果全为1代表没有出错，有一个0就是出错了。\n虽然能够检测出差错，但是UDP不能恢复错误。\nTCP协议 TCP是面向连接的可靠数据传输协议。\nTCP报文段结构 为了下面的知识点，需要先看一下其段结构：\n序号是TCP协议用来区分报文的。如果报文非常大，TCP会将报文分段，然后给每段一个序号，到时候传到目的地，目标再通过需要将包重新组合回报文。\n确认号是在三次握手，四次挥手以及收到消息之后所发送的。\n需要注意的是第四行中的CWR，ECE等位，RST，SYN，FIN用于连接的建立和断开，PSH表示接收方应该立刻将分组送往程序，ACK用于指示确认号是有效的，CWR和ECE用于拥塞控制中。\n紧急数据指针是在此数据报被视为紧急数据（URG位为1）的时候使用的。\n选项是针对TCP的一些选项（详情见《TCP/IP详解：卷一》）\n序号和确认号 序号并不是一系列连续的数字，而是根据分段大小递增的数字。也就是说，我发送的第一个分段的大小是1022字节，那么我第一个分段的序号就是0，而第二个分段则是1023。\n确认号也不是连续底层的数字，而是接收端期望从发送端收到的下一字节的序号。也就是说假设发送端发送了序号为200，大小为1022字节的数据，那么接收端返回的确认号应当是1022+200+1=1223。简单来说就是接收到的序号加1。\n建立连接的三次握手和断开连接的四次挥手 三次握手 要想使用TCP传输数据，必须先建立连接。TCP建立连接的方法是三次握手：\n1 2 3 4 5 6 7 8 9 客户端 服务器端 |[SYN] SEQ=n len=x | |---------------------------\u003e| | | |[SYN] SEQ=x+1 ACK=n+1 len=y| |\u003c---------------------------| | | | ACK=m+1 SEQ=y+1 | |---------------------------\u003e| 客户端首先发送一个SYN报文给服务器端，并且带有自己的序号和数据长度。\n然后服务器端接收到之后，返回一个包含ACK的SYN报文给客户端。\n然后客户端再次发送一个报文给服务器端，经理了这三次数据传输之后，连接就建立了。\n简单来说就是：客户端首先发送SYN表示我要建立连接了，然后服务器端为了表示收到，发送一个报文回去（其中ACK表示收到上个报文，SYN表示想要建立连接），然后客户端返回一个带有ACK的报文表示我知道你同意并也想要建立连接了，那我们两个就建立连接吧。\n这里的SYN报文就是将SYN位设为1的报文。含有ACK的报文就是将ACK位设置为1的报文。\n接下来来看一下实际的三次握手，这里使用wireshark抓包工具捕获telnet连接到百度HTTP服务器时的三次握手：\n看Info那一栏：telnet先发送了带有SYN设置的TCP包给百度，并且Seq是0，数据的长度也是0。\n然后百度返回了一个带有SYN设置的TCP包，并且Ack=1，Seq=0，长度为0\n然后我方再返回一个ACK=1，SEQ=1的包，握手完成。\n数据传输 数据传输的过程中，每当接收方收到分组的时候，都需要返回一个含有ACK的报文，表示我已收到，并且这个ACK的值就是接收报文序号的值加1。这里直接看一个例子：\n这里通过telnet连接到QQ的POP3邮箱服务，并发送一些信息。\n前三行是照旧的三次握手，第四行服务器那边发来了“+OK XMail POP3 Server v1.0 Service Ready(XMail v1.0)”字符串，于是telnet在第五航返回了一个ACK表示已经收到信息。然后第六行我利用telnet发送了\"user VisualGMQ\"的字符串过去，在第七行服务器返回了一个ACK表示收到，并且紧接着在第八行发送了“+OK”的消息回来，我们的telnet也不能失礼，直接在第九行返回了代表确认的ACK。\n四次挥手 当我们想断开连接时，我们需要通过四次挥手来告诉对方。四次挥手的过程如下：\n1 2 3 4 5 6 7 8 9 10 11 12 客户端 服务器端 |[FIN] | |---------------------------\u003e| | | | [ACK] | |\u003c---------------------------| | | | [FIN] | |\u003c---------------------------| | | | [ACK] | |---------------------------\u003e| 这里忽略了SEQ的值，反正计算都一样。\n一般都是由客户端发起中断连接的请求，所以这里客户端发送设置为FIN的报文给服务器。服务器得到之后，表示我已经知道你要断开连接了，所以返回了一个ACK。\n这个时候要注意：连接并不是在这个地方就彻底断开了。由于TCP是全双工连接，客户端发送FIN只代表客户端通向服务器的连接断开了，也就是说客户端不能向服务器发送数据了，但是服务器到客户端的连接还没断开呢，客户端这个时候还能接收数据，所以客户端程序也不是在发送ACK之后就关闭了，而是要等待服务器端的FIN。\n接下来服务器端发送了一个FIN，表示我也要断开和你的连接了，客户端表示OK，返回了一个ACK。至此，服务器和客户端的连接才真正断开了。\n有些时候为了省事，FIN和ACK会一起被发出：\n1 2 3 4 5 6 7 8 9 客户端 服务器端 |[FIN] | |---------------------------\u003e| | | | [ACK] [FIN]| |\u003c---------------------------| | | | [ACK] | |---------------------------\u003e| 为了更详细地弄清楚在四次挥手时客户端和服务器的状态，给出下图：\n可以看到，客户在得到ACK之后并没有直接CLOSE，而是进入了FIN-WAIT-2状态。这个状态下客户端只能接受来自网络的数据，它也是在等待可能来自服务器的数据。而且在接收到对方的FIN并且返回ACK之后，还会等待2MSL时间才会关闭。MSL（MAX Segment Life最长报文寿命），是任何报文在网络上能存在的最长时间。\n最后给出一个实例，是通过telnet连接到QQ的POP3服务器断开的情形（倒数四行是四次挥手）：\n总结大图 最后将握手，通讯，挥手三部分的总图给出来，图片来自于《UNIX网络编程：卷一》：\n你自己细品🍵\n提供可靠连接的方法 接下来要说TCP的重难点：TCP究竟是如何只靠自己就提供了可靠连接的呢？\nTCP是靠如下方法提供可靠连接的：\n校验和：用来确保数据的正确性 序号：用于将乱序的信息重新排序 确认：告诉对方已收到报文 否定确认：告诉对方收到错误的报文（注意不是没收到报文），对方会重传 定时器：在一定时间内没有接受到相应ACK会判断丢包，可能重传 窗口和流水线：提高发送和接收效率 校验和 这个就不多说了，和UDP一样，需要校验和来确保数据的正确性。\n序号 由于网络和分组传递路径长短的问题，到达的分组可能是乱序的，这样给每个分组一个序号，就可以通过序号将分组重新组合成原有的报文。\n序号还有一个作用：避免冗余分组。假设A向B发送了一个分组，过了一段时间之后A觉得时间太长了（定时器到了），以为分组已经凉凉，会重发一个分组。但是这个分组其实并没有凉，而是完好无损地发给了B，只不过时间长了一点。那么这个时候B就可能接收到两个一样的分组。有了序号我们就可以辨别同样的分组（SEQ值一样），然后丢弃冗余分组了。\n确认和否定确认 当收到分组的时候会返回一个确认报文（ACK报文），如果没有接收到正确的分组会返回一个否定确认报文（称为NAK报文），表示我收到错的分组。这个时候发送方会选择重传（就是将丢掉的分组再传一遍）。\n实际上TCP报文段中并没有对NAK报文的设置位，TCP发送的其实是ACK。因为首先你接收到了正确的分组，发送了一个ACK，然后检查了一下发现这个分组是错的，再针对这个分组发了个ACK。接收方一看：你怎么对同一个分组发了两个ACK（第二个ACK称为冗余ACK），肯定是什么地方搞错了，所以他也会重传。\n定时器 定时器分为四种：重传定时器，坚持定时器，保活定时器，2MSL定时器。这里介绍重传定时器，其他定时器在其他部分介绍。关于定时器的底层机制，见《TCP/IP详解：卷一》。\n重传定时器，顾名思义，当这个定时器到时间了会触发分组重传。每次发送方发送一个分组都会为这个分组启动一个定时器，等到定时器到了还没有收到对应ACK的话就会重传，收到则会终止定时器。\n流水线和窗口 在存在前面所说的机制之后。TCP仍然存在一个严重缺陷：当TCP发送一个分组之后，他得启动定时器，等待分组到达目的地，然后得到ACK之后关闭定时器，再发送下一个分组。这显然是一个很浪费时间的事情（这种协议被称为停等协议）。聪明的小伙伴一定一眼就看出解决办法了：用缓冲区啊！没错。流水线其实就是在TCP中加入了缓冲区，而窗口则是管理缓冲区的一种算法。\n回退N步（滑动窗口）和选择重传 滑动窗口协议 回退N步协议又称滑动窗口协议（GBN）。在GBN协议中，发送方可以一次性发送多个分组而不必等待ACK。其会将所有的分组排成一列（称为流水线），并且根据以下方法来管理\n最右边的纯黑色分组是目前还不能用的分组，绿色的是可用的，但是还没发送的分组。灰色是已经发送了，但是还没有接收到对应ACK的分组，深灰是已经被确认的分组。\n滑动窗口协议维护两个变量：base和nextseqnum。整个窗口的长度为N。而发送了还未确认的分组存在于$[base, nextseqnum-1]$，可用未发送的存在于$[nextseqnum, N+base-1]$中。小于base的为已确认分组，大于$N+base-1$的为不可用分组。\n如果这个时候发送方的第一个分组得到了其ACK，那么窗口会向后移动一格，这样就会多一个可用分组了。这也就是为什么叫做滑动窗口的原因：\n如果位于base处的分组收到了ack，那么他会变为已确认分组，base的值将加1来使窗口向后滑动。\n如果接收方接收到了序号为n的分组，且这个分组是有序的（也就是说前n-1个都接收到了），那么接收方会针对这个分组返回一个ACK。如果不是有序的，接收方会丢弃这个分组，让发送方重传。这种确认方式叫做累计确认。\n如果程序现在要发送分组，运输层会先看窗口是否已经被“发送但未确认分组”塞满了，如果塞满了，网络层将不给予发送（也有可能会将分组缓存，等到窗口有空间了再发送），如果窗口内存在“可用未发送分组”，那么取出nextseqnum处的可用分组，填充数据之后发送，并且更新nextseqnum变量。\n整个窗口维护一个重传定时器。这个定时器在最早的分组发送时生成。如果出现超时，发送方会重传所有发送但未确认分组（这也是回退N步名称的由来）。如果还未超时时已经接收到了ACK，并且存在发送未确认分组，那么定时器重新计时；如果不存在发送未确认分组，定时器停止：\ngraph TB 1[第一个分组发送] --\u003e 2[定时器启动/重启] 2 --\u003e 3{超时了吗} 3 -- 是的 --\u003e 4[重传所有已发送未确认分组] 4 -- 重启定时器 --\u003e 2 3 -- 没有 --\u003e 6[得到ACK] 6 --\u003e 7{存在未被确认分组吗} 7 --是的--\u003e 8[更新窗口] 8 --\u003e 2 7 --没有--\u003e 9[定时器停止] 9 --发送了新分组--\u003e 2 选择重传 可以看到滑动窗口中的一个大缺陷：接收到的分组必须是连续的，如果不是连续的就直接丢弃。这样是很浪费带宽的。选择重传顾名思义，就是接收方接收到不连续的分组时，仅仅对这个分组发出重传要求。这样可以节省贷款，但是增加了运行时内存。\n相比于回退N步，选择重传协议需要为每一个分组开启一个定时器，定时器到了之后重传这个分组而不是所有分组。下面是选择重传的发送方和接收方示意图：\n发送方会保留已发送分组在窗口内，只有当base处的分组接受到之后，窗口才会向后滑动多个分组（这里就是3个）。接收方也是一个道理。\n往返时间估计和超时 TCP在发送报文的时候会设定一个定时器，那么这个定时器应当定多长时间呢？\n首先定时器时长必定要大于一个RTT（Round Trip Time），RTT是报文传输到获得此报文ACK之间的间隔时间。TCP有公式可以计算出设定的时长。\n首先TCP会间断地测量一个报文的RTT，这个RTT称为SampleRTT。注意TCP绝不会对重传报文测量SampleRTT，也就是说报文必须是一次性到达的才能测量。\n然后TCP会维护一个EstinamtedRTT，用于估算SampleRTT的均值，此值为 $$ EstinatedRTT=(1-\\alpha)EstinmatedRTT+\\alpha SampleRTT $$ 其中$\\alpha$的推荐值为0.125。\n然后还会维护一个DevRTT用于估算SampleRTT偏离EstimatedRTT的程度，为 $$ DevRTT = (1-\\beta)DevRTT+\\beta|SamplerRTT-EstimatedRTT| $$ $\\beta$的推荐值为0.5。\n最后就可以推算出重传超时间隔TimeoutInterval: $$ TimeoutInterval = EstimatedRTT+4DevRTT $$ 推荐的TimeInterval初值为1秒。当出现超时时TimeoutIntercal会加倍。然而只要收到ACK或者来自Socket的数据时，就需要用上述公式再次计算。\n快速重传 定时器虽好，但可能计时时间很长，这样会让报文的重传时间变慢。基于此，如果TCP收到了三个冗余ACK（即先收到一个ACK，然后收到三个和先前一模一样的ACK），TCP就会执行快速重传，即在该报文定时器过期之前就重传该报文。\n流量控制 TCP可以自己控制流量。如果发送方不停地发送数据，而接收方在忙其他数据的话，接收方的缓冲区将会溢出，然后接收方要求重传，这就导致了发送包的浪费。TCP通过报文段的接收窗口（rwnd）字段来告知对方我的缓冲区当前大小。发送方每次发送的分组不得大于接受窗口的大小。\n拥塞控制 如果过个TCP同时以较大的速度发送分组，那么网络会拥塞，导致大量分组丢失，然后由于重传机制导致更多的分组发出，网络更加拥堵。\n为了防止上面的情况发送，TCP还可以预防网路拥塞，主要是通过在发送方维护一个cwnd变量来预防拥塞。发送方发送的数据不能超过$\\min{cwnd, rwnd}$具体通过三种方法：\n慢启动 拥塞避免 快速恢复 慢启动 在慢启动状态下，cwnd以一个MSS（Max Segment Size TCP能够传输分组的最大长度）开始，每次收到一个ACKcwnd就再加一个MSS。\n慢启动虽然看上去一开始很慢，但是增长的速度是惊人的。一开始$cwnd=1$，能够发送一个分组，发送之后得到ACK，$cwnd=2$就可以发送两个分组了，然后会得到两个ACK，$cwnd=4$...这样是以指数方式增长的。\n当需要重传时，TCP会记录下当前cwnd值的一半（记为ssthresh），然后将cwnd再次置为一个MSS，并且再次执行上面的递增方法。如果遇到三个冗余ACK，则会进入快速恢复（下面会说）算法\n拥塞避免 当cwnd超过ssthresh时，cwnd会进入拥塞避免算法，这个时候每一个RTT时间后会使cwnd会以一个MSS的速度线性增长，直到遇到重传，会再次开始慢启动算法。\n快速恢复 这是TCP推荐的算法，而不是必须的。当接收到三个冗余ACK后会进入这个算法，主要是将ssthresh和cwnd调整为当前窗口的一半，然后继续执行拥塞控制算法\n总结图 图片来自于csdn博客：\n","description":"","tags":null,"title":"计算机网络-3-运输层","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-3-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":null,"content":"这里说明如何在Mac下配置YouCompleteMe插件（Linux上应该也一样的）\n在安装YCM之前确保你的电脑有Cmake，make,npm，python和C/C++编译工具。\n首先下载插件，随便你是手动下载还是使用插件管理器。我这里使用的Vundle下载，在vimrc中加入如下行并运行PlugInstall：\nPlugin 'ycm-core/YouCompleteMe' 等待下载，下载完成之后，进入YouCompleteMe的文件夹（一般在~/.vim/bundle/youcompleteme下），运行\n1 python3 ./install --all 这里--all是安装所有的语言补支持p，具体有C/C++,Java,Rush,JavaScript等。如果你想装几种语言支持，请看文档。\n运行之后可能会提示你缺少仓库，根据提示在终端输入：\n1 git submodule update --init --recursive 它会帮你把子模块全部下载，耐心等待即可。\n下载安装之后，再次运行\n1 python3 ./install --all 这个时候会有第一个坑：他可能不能够将所有的子模块都下载下来！我这里是没有下载cregex库，所以我在运行的时候，他总是在编译ycmd的时候告诉我cregex库没有CMakeLists.txt文件。\n解决办法是到third_party/ycmd/third_party/下去一个一个检查模块。每个模块放在不同的文件夹下，进去看看文件夹里面有没有文件。我这里就是只有cregex文件夹，然后文件夹里面没有文件。。。\n找到空文件夹之后就可以将模块手动下载进来了，这里可以通过git来找到模块的github地址，比如cregex模块，先进入cregex文件夹，然后\n1 git remote -v 就可以看到结果了：\n1 2 origin\thttps://github.com/ycm-core/regex.git (fetch) origin\thttps://github.com/ycm-core/regex.git (push) 可以看到https://github.com/ycm-core/regex.git是其github仓库。\n等到你的所有子模块都OK的时候，就可以再次运行python3 ./install.py --all了，然后他又会下载文件，耐心等待即可。\n全部安装完成之后你就可以开始使用自动补全了。\n","description":"","tags":null,"title":"Mac下在Vim上配置YCM","uri":"/posts/mac%E4%B8%8Bvim%E4%B8%8A%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEycm/"},{"categories":null,"content":"这里记录了Perl面向对象的相关知识\n类 类的本质是包，其实一个类就是一个包。\n创建类 这里来一步一步创建一个类，由于类就是包，类名就是包名，所以应当首先创立一个包。我这里就直接创建一个模块了：\n1 2 3 4 5 6 7 8 9 #file Person.pm package Person; use 5.010; use utf8; use Exporter; @ISA = qw(Exporter); 1; 类中的函数其实就是包中的函数。为了初始化对象，我们需要给出一个构造函数：\n1 2 3 4 5 sub new{ my $this = {}; bless $this; return $this; } 一般习惯是将构造函数命名为new，当然你也可以取其他的名字。\nPerl的类和Lua的类十分像。Perl本身是没有表示类的数据结构的，所以这里表示类只能用哈希表示。\n第二行声明了一个this变量，引用了匿名的哈希。\n第三行使用bless函数让这个引用和本包名关联起来。bless是在创建类的时候必须需要的一个特殊函数，其作用是将变量和包关联起来，让用户能够通过变量来调用包内的函数。\nbless的第一个参数一定要是一个引用，第二个参数是要关联的包名，这里忽略默认为本包。\n第四行返回我们构造完成的this变量。这里由于this变量是指向的匿名哈希的引用，所以虽然函数结束之后this变量销毁了，但是匿名的哈希并没有被销毁，所以可以被外部变量使用。\n不要忘记最后在EXPORT变量中导出函数（下面不再说明）：\n1 EXPORT = qw(new); 使用类的话可以使用多种方法：\n1 2 3 4 5 6 use Person;\t#首先导入模块 #可以用::或-\u003e获取包中的变量和函数 $p = Person::new(); $p = Person-\u003enew(); $p = new Person();\t#这种类似C++/Java的方法也可以 添加成员变量和函数 首先来添加一些成员变量：\n1 2 3 4 5 6 7 8 sub new{ my $this = {}; $this-\u003e{name} = @_[1]; $this-\u003e{age} = @_[2]; $this-\u003e{height} = @_[3]; bless $this; return $this; } 由于整个类对象其实就是this变量所指向的引用，所以显然给引用键值对就相当于给对象成员变量了。这里增加了name，age，height三个属性。\n需要注意的是，new函数的参数默认第一个是类名称，所以我们要得到自己的参数需要从第二个参数开始。\n然后添加一些成员函数。由于bless的影响，我们可以直接通过this变量访问包内的函数，所以这个时候函数直接放在包内就可以了，而不需要像成员变量一样加到this中：\n1 2 3 4 5 6 7 8 9 10 11 12 sub GetInfo{ my $this = shift; return ($this-\u003ename, $this-\u003eage, $this-\u003eheight); } sub ModuleInfo{ say \"this is Person Module\"; } sub DESTORY{ say \"I'm died\"; } 这里GetInfo()函数属于虚函数（C++概念），也就是说对于不同的子类，调用同一个方法时，调用的是子类的方法而不是父类的。虚函数的第一个参数一定是类对象，所以在第二行的时候直接将类对象shift出来。\n而ModuleInfo()则是静态函数（C++概念），由于是静态函数，所以不需要类对象作为参数。静态函数其实就是整个包的函数，也可以通过包直接使用：Person::ModuleInfo()。\nDESTORY()函数是析构函数（一定是这个名字），一个类中只能由一个。其有唯一的参数——类对象本身的引用。但是注意这个引用是只读的（也就是说不能用$_[0]这种方法获得），但是对象自身是可写的（如%$_[0]这种）。\n继承 继承的话只能继承函数而不能继承成员变量，所以对成员变量的继承得你自己想办法。\n继承是通过@ISA变量做到的：\n1 2 3 4 package Programmer; use Person; @ISA = qw(Programmer);\t#将父类写入其中即可，你可以写多个父类来表示多继承 这样Programmer类就有了Person类中的所有函数。\n重写 在子类中重写父类方法是可行的，如果你要调用父类方法，可使用\n1 $this-\u003eSUPER::func(); 的方法来调用。\n","description":"","tags":["perl"],"title":"Perl的面向对象","uri":"/posts/perl%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"这里介绍了Perl的包，模块和面向对象相关知识。\n包和模块 包 和Python一样，Perl有包机制。声明包的话需要使用package函数，而引入则需要require函数：\n1 package Example; 这里声明了一个Example包。\n如果你的代码不声明包的话，默认是main包：\n1 package main; 也可以通过no函数来取消包的引用：\n1 no main; 如果你写了上面的语句，那么你的文件现在就是没有包的状态，那么你声使用的变量和函数就必须显式指定是哪个包里面的，直到你用require导入了包。\n一个文件中是可以通过package来转换包名的：\n1 2 3 4 package Example; $a = 12; package main; $a = 23; 上面两个a变量不一样，第一个是Example包中的a变量，第二个则是main包中的a变量。\n创建一个包 创建包的一般格式如下：\n1 2 3 4 5 package package_name; # some statements 1; 开头一句不用说，是说明现在的包名。最后一个1是因为，在使用require函数的时候，require会先执行包含的文件（使用eval来执行）。如果这个文件最后返回真，则导入，返回假则停止导入。所以为了我们的包可以导入，一般都在最后加上1;来表示返回真。\n然后就可以在里面放入一些函数和变量了，这里随便放几个：\n1 2 3 4 5 6 7 8 9 10 package Example; $name = 32; local $age = 19; sub Info{ say \"this package name is \", __PACKAGE__; } 1; __PACKAGE__是一个特殊的变量，指代当前包名。加了local的变量代表只能在自己的包内使用。\n使用包 我们现在使用上面的Example包，首先先导入：\n1 require \"Example.pl\"; require函数是可以指定路径导入的。这里将Example.pl放在和源码同一目录下。\n然后使用变量和函数：\n1 2 $Example::name; Example::Info(); 注意变量之前要加上固有前缀。\n模块 Perl用包表示模块。\n一般我们将程序分成一块一块的，这种就叫做模块。\n其实你可以认为模块就是包。\n导入模块 你可以通过require导入，因为包就是模块，或者用更正规的use导入。\nuse会查看@INC变量，这个变量里面存储了很多路径，Perl会在这些路径下面找你use的包。\nuse了包之后就不需要再加包前缀了。\n例子 模块的后缀是pm，我们这里就来创建一个简单的，放在Example.pm文件中（模块名和文件名同名）：\n1 2 3 4 5 6 7 8 9 10 package Example; $name = 32; local $age = 19; sub Info{ say \"this package name is \", __PACKAGE__; } 1; 这个就是上面的Perl包，这里当做模块使用。\n然后在main.pl中使用这个包：\n1 2 3 use Example; Info(); 你也可以通过Exporter模块来指定你的模块要导出什么函数的变量（默认是导出全部的非local函数和变量）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package Example; use Exporter; @ISA = qw(Exporter); @EXPORT = qw(Info); @EXPORT_OK = qw(age name); $name = 32; local $age = 19; sub Info{ say \"this package name is \", __PACKAGE__; } 1; 第三行导入Exporter模块，第四行是固定写法，第五行的@EXPORT变量表示要导出的函数，第六行的EXPORT_OK变量表示要导出的变量。这里将所有的函数和变量都导出了。\n模块生成工具h2xs Perl本身带有h2xs工具来生成模块。其说明文档写的很详细。\n安装第三方模块 首先你得有一个可以找到模块的网站，这里推荐metacpan。\n上去之后你就可以在里面找模块了，找到模块之后点进去，在左边的TOOLS栏中可以看到Install Instructions，点开之后就可以看到这个模块的安装方法了。\n一般有两种安装方法，第一种是它提供的，通过cpan工具安装，一般指令如下：\n1 2 perl -MCPAN -e shell install XXXX 网上也提供了使用cpanm工具的方法，不过cpanm工具要另装。\n还有一种是手动安装，将模块下载下来之后，进入模块然后通过\n1 perl Makefile.PL 指令来生成Makefile，然后再\n1 make 即可编译完成，之后还可以使用\n1 make test 来运行模块的测试，看看这个模块是不是能转。\n然后用\n1 make install 即可安装模块到Perl目录中。\n","description":"","tags":["perl"],"title":"Perl的包和模块","uri":"/posts/perl%E7%9A%84%E5%8C%85%E5%92%8C%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"本文说明了如何在XCode配置Vulkan，以及如何使用g++进行vulkan编程。\n下载，测试和安装 首先去vulkan官网下载Mac下的SDK包。我这里下载的是vulkansdk-macos-1.2.135.0.tar.gz。\n下载好之后解压。先进入Applications文件夹，里面有vkcube程序，双击看看能不能转。如果能转的话说明你的显卡可以使用vulkan，就可以进行安装了。\n在解压文件根目录下可以看到install_vulkan.py文件。这个就是安装文件，打开终端，输入./install_vulkan.py即可安装。\n如果安装过程中出现失败，一般他都会提示你如何修复。\n它会将vulkan头文件安装到/usr/local/include下，并且将vulkan库安装到/usr/local/lib下。\n如果想要卸载vulkan，请运行uninstall.sh。\n在XCode上配置Vulkan 官方文档说了如何在XCode上配置，见这里。\n这里我也简单说一下：\n创建一个基于C++的XCode工程\n将这段代码粘到main.cpp中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u003ciostream\u003e #include \u003cvulkan/vulkan.h\u003e int main(int argc, const char * argv[]) { VkInstance instance; VkResult result; VkInstanceCreateInfo info = {}; result = vkCreateInstance(\u0026info, NULL, \u0026instance); std::cout \u003c\u003c \"vkCreateInstance result: \" \u003c\u003c result \u003c\u003c \"\\n\"; vkDestroyInstance(instance, nullptr); return 0; } 这个时候由于找不到vulkan头文件，会报错。解决办法是加上vulkan的framework：\n将vulkan文件夹下的macOS/Frameworks/vulkan.framework拷贝到你的工程根目录 打开工程的Build Phases选项卡，打开Link Binary With Libraries节点，将你刚刚拷贝的vulkan.framework拖进去。 然后打开Copy Files节点，去掉Copy only when installing，再将vulkan.framework拖进去。 然后再编译应该就可以成功了。\n如果还是提示找不到头文件的话，你就需要在XCode的Build Settings选项卡里面找到Header Search Paths节点，手动添加vulkan的头文件目录（这里是/usr/local/include）。\n经过以上步骤应该就可以编译了。\ng++的配置 前面我们说过，头文件安装在了/usr/local/include下，库安装在了/usr/local/lib下，所以我们就可以这样编译：\n1 g++ main.cpp -o exe -I/usr/local/include -L/usr/local/lib -lvulkan 即可成功。\nvulkan工具 vulkan还会将macOS/bin下的文件安装到/usr/local/bin下。可以使用vulkaninfo工具来看看你系统上vulkan的信息。\n","description":"","tags":null,"title":"如何在Mac上配置Vulkan","uri":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E9%85%8D%E7%BD%AEvulkan/"},{"categories":null,"content":"《计算机网络：自顶向下方法》的学习笔记\n应用层是我们应用程序所在的层，程序员编程的时候只需要了解应用层的相关知识。应用层将复杂的硬件和协议，和应用程序隔离开。\n由于应用层主要是一些应用。所以我们这里主要看一些典型的应用层应用。\n客户-服务器模型（CS模型） 首先要说的是客户服务器模型。在网络通信中，等待连接的一方叫做服务器端，而主动连接的一方叫做客户端。客户端连接到服务器之后可以使用要求服务器提供一些服务。举个栗子：你去餐馆吃饭，那么餐馆的服务员就是服务器端，因为他们要一直在餐馆等着客人来就餐，然后提供相应的服务。他们不能随意离开餐馆。但是客人就是客户端，客人想来就来，想走就走，并且可以要求一些服务。而且客人是主动方，客人可以选择是否踏入餐馆，而服务员则不能硬拉着客人就餐。同样的，客户端需要服务的时候需要主动连接到服务器，服务器则不能主动连接客户端。\nCS模型是网络上最基本的应用程序模型。再举个栗子：你打王者荣耀的时候，是不是想什么时候上分就什么时候上分（也可能是掉分），所以你的王者荣耀软件就是客户端，每次当你想上分的时候就需要连接到王者荣耀服务器。而服务器是由腾讯自己维护的，一天24小时不间断开着，所以你只要一打开王者荣耀，你的客户端就可以自动连接上服务器。然后服务器会传给你一些信息，包括匹配队友的信息，以及峡谷中各个队友的位置啊，伤害啊，技能动画等。\n还有一种对“服务器”的解释，是硬件方面的，指一台运行着服务器程序的电脑或机器。因为服务器程序基本上要二十四小时开着，还要处理大量的流量，写日志什么的，所以一般不会将自己的PC当服务器，而是买一台服务器（硬件上的）。买来的服务器基本上性能比PC好得多，可以处理网络上的各种信息通讯。\n不过现在这个时代不需要真的买个几吨重的服务器回来，现在各大厂有“云服务器”，也就是说服务器机子在他们那边，但是你可以通过网络连接到你买的服务器，然后操控服务器机子。阿里云和腾讯云就是出售云服务器的平台。\n其实服务器机子本身也没什么特殊的，你可以把它当做性能很好的电脑，所以也得安装操作系统，而且服务器程序你也得自己写，服务器本身是没有的。\n编写网络程序 这一部分是一大块独立内容，这类就不提及了，如果你想要编写自己的网络程序的话，网站方面可以上百度搜索“HTML CSS JS”，而服务器和客户端程序的话，Windows推荐《WinSocket编程》，Unix推荐《Unix网络编程：卷一》，Perl语言推荐《Perl网络编程》。基本上大部分语言都带有网络编程的API，C/C++需要依赖操作系统自身API，而Python，Java这种跨平台的本身就带有网络编程API，你可以直接搜索相关教程学习。\nIP地址和端口号 当客户端连接到服务器端的时候，客户端怎么知道服务器端在哪里呢？简单来说，路由器在发送客户端的信息时，怎么知道服务器端在哪里呢？\n首先路由器会按照IP地址找到服务器程序所在的电脑（每个电脑只有唯一的IP地址，由硬件厂商生产网卡时写入网卡内的，不可改变），然后再在目标电脑上通过端口号找到目标程序，然后和程序通讯。也就是说，在同一个主机上，端口号用来区别不同的程序。\n无论是客户端程序还是服务器程序，都需要绑定一个端口号，一个端口号只能由一个程序使用。\n端口号的取值范围为0~65535，前255个端口号是常用端口号，用于一些广为人知的应用程序（下面会说），一般不用做自己的程序（除非你实现的就是那些“广为人知”的程序）。\n基于TCP的程序和基于UDP的程序 在应用程序下的层——传输层中，存在两个很重要的协议：TCP和UDP。我们大多应用程序都是基于这两个协议的。\nTCP协议的特点 可靠的数据传输：TCP协议采用一系列方式让传输变得可靠，包括超时重传（如果超过一定时间服务器还没有相应，那么再将之前的信息传一遍），使用报文传输等 面向连接的服务：在通信前TCP需要通信双方建立全双工连接，这样传输的数据在连接中进行，比较不容易被窃听。 UDP协议的特点 无连接的服务 不可靠的传输 这个时候就有人问了：你这个UDP干啥啥不行，为什么不直接用TCP呢？因为UDP传输很快，而且不会超时重传，传输失败的数据直接丢弃。这一点广泛用在音视频通话，在线会议上。因为这些程序对同步性有很高的要求。如果你用TCP，有一帧的数据没传到，那TCP还得重传，那到时候你的延时就比别人大了。而UDP不管传没传到，反正我就接着传。这样虽然中间几帧丢失了，你顶多也是看到画面突然切了一下，不会有延时。\n所以在编写程序的时候，你需要指定程序是使用TCP还是使用UDP。使用TCP的程序就是基于TCP的，使用UDP的就是基于UDP的。\n一些广为人知的应用程序（常用应用程序） 网络上有很多常用的应用程序，系统为他们保留了相关端口号。下面让我们来看看：\nHTTP服务 即超文本传输协议，主要体现就是传输Web页面，也就是你浏览器天天打交道的对象（浏览器可以看成HTTP客户端）。系统保留端口号80，基于TCP。\n特点 主要特点是无状态协议，也就是说不会记录通信对象的信息。他把网页传给你之后就忘了这件事情。你要想再让他传给你，你得再次建立TCP连接，要求他再传一份给你（浏览器上就是按刷新按钮）。\n而且你在网页中填写的信息（比如登录名称啊，密码啊）他也不记得，你要想重新登录得自己输入。\n这个时候有人就问了：不对啊，我登录网页的时候它会帮我自动登录啊，或者问我用不用以前保留的密码之类的。这个不是HTTP的事情，是cookie的事情。\n非持续连接和持续连接 HTTP可以选择是非持续连接还是持续连接。非持续连接就是他把信息传给你之后，TCP连接就关闭了。持续连接就是他传给你之后还等着，不断开连接（这些在下文请求报文中有体现）。\n浏览器对象 网页中除了有文字，还有图像什么的对吧。文字本身（也就是HTML文件）是一个对象，图像是对象，CSS和JS文件也是对象。在非持续连接中，每个对象是需要单独建立TCP连接传输的。也就是说，浏览器先建立一个连接，传给你HTML文件了，然后关闭连接，再打开一个新连接，传给你一个图片，再关闭这个连接。。。如此往复，直到所有对象传输完毕。\n这显然很麻烦，所以一般使用持续连接：所用东西用一个连接顺序传输，传完再关闭连接（或者继续等待）。\nHTTP报文格式 HTTP报文分为两种：请求报文——用于客户端发给服务器，请求一些数据；响应报文——服务器根据传过来的请求报文，发送回去的含有数据的报文。\n这里顺便说一下：报文的换行符不是\\n，而是\\r\\n。也就是说每一行的末尾其实是\\r\\n。\n请求报文 典型的请求报文如下：\nGET /dir/index.html HTTP/1.1 Host: www.webpage.com Connection: close User-agent: Mosilla/5.0 Accept-language: zh 第一行为请求行，后面的叫做首部行。\n请求行有三个部分：请求方法，请求的资源，使用的HTTP协议。这里请求方法是GET，表示我要接收数据，还可以是：\nPOST：表示我要发送数据了，一般你在登录的时候，填完用户名和密码，点登录时就会发送POST请求 HEAD：和GET一样，只不过要求响应报文中不要有内容，只返回响应报文头部即可。 DELETE：指定删除一些页面 等。其他的请自行上网百度。\n请求的资源很好理解，就是你想要什么。比如你想要服务器上，位于picture文件夹下的a.jpg，那么可能就是/picture/a.jpg。这里要获得dir文件夹下的index.html文件。\nHTTP协议部分也很简单，这里指定使用HTTP1.1版本协议。\n首部行第一行为Host信息，表示请求的主机名称。第二行Connection表示使用持续连接还是非持续连接。这里的close表示发送完就关闭，显然是非持续连接。第三行指定客户端的信息，这里是火狐浏览器的代号，表示是火狐在请求。最后一行是要接受的语言。如果服务器提供相关语言的网页的话，会返回给你，否则返回默认语言的网页。这里请求的中文网页。\n由于是GET方法，所以只有请求行，没有请求内容。但是如果是POST方法，则需要将额外信息附加到请求内容中，类似这样：\n请求头\\r\\n \\r\\n 信息1\\r\\n 信息2\\r\\n 请求头和信息之间有一个空行。\n响应报文 一般格式如下：\nHTTP/1.1 200 OK Connection: close Date: Tue, 18 Aug 2020 02:02:03 GMT Server: Apache Content-Type: text/html datas 第一行为状态行，下面的四行为首部行，然后是实体行（存储数据的部分）。\n状态行说明了：HTTP信息，状态码和状态码描述。这里200表示成功，描述为OK。我们常见的404就是指内容找不到。\n第三行的Date字段表示了传输的时间\n第四行的Server表示使用的服务器软件类型，这里是Apache服务器软件\n第五航Content-Type表示实体行的数据类型。这里是html文本。\n更多关于报文的说明请自行百度。\nCookie 为了达到自动登录类似的效果，浏览器需要保存用户信息。这就要用到Cookie。\n具体的过程是这样的：假设你现在登录到github，传了你的用户名和密码。当github的服务器确认用户名和密码正确之后，会在它的数据库里面保存你的信息，并且生成一个标识你信息的ID，然后将这个ID放在响应报文的set-cookie字段中传给浏览器。\n浏览器收到了登录成功的网页和set-cookie字符，就知道你的信息可能需要记录下来了，就会弹出个对话框问你要不要保存你的信息。如果你点是，那么浏览器就会把你的信息保存下来，这个信息就叫做cookie。\n过了几天之后，你再次打开github登录界面，浏览器会先检查有没有保存cookie，有的话他不用你多说，直接自己发送一个POST请求给github服务器自动登录，或者帮你在用户名和密码栏里面填好。这就实现了密码记忆和自动登录了。\n所以说了这么多，你可能发现了：HTTP并不知道cookie的保存和传输，最多也只知道set-cookie字段器而已。HTTP不知道cookie的具体内容，cookie的保存和发送都是浏览器和服务器干的事情。所以拥有cookie和HTTP是无状态连接的事实并不冲突。\nWeb缓存和代理服务器 作为Web缓存的服务器叫做代理服务器（或者Web缓存器）。就是新搞一台服务器，这个服务器叫代理服务器。每次浏览器发送请求的时候先发送到代理服务器，代理服务器如果没有信息，就会再将请求发送给真正的服务器。那么真正的服务器会返回一个响应，也是先到代理服务器（因为是代理服务器给真服务器法的请求），代理服务器会将这个响应保存一份，然后发个客户端。下次客户端再发送同样的请求后，代理服务器会先检查自己有没有请求的信息，有的话直接返回，就不用劳烦真路由器了。\n需要Web缓存的意义很明显：降低真服务器的负担，使得响应时间更短。\n而且这里要注意一点：代理服务器由于不知道真服务器的内容是否更新了，会不定期请求真服务器发信息给自己，来更新自己的数据。所以代理的内容并不是会永远存储的。\n有时候你明明将文件上传了，但是刷新之后页面却没有显示新文件，等了一会再刷新又有了。那么这个时候就是代理服务器给你的反馈，在你等待的时候代理服务器更新了自己的内容。\n有时代理服务器不仅仅用作Web缓存，还可以干其他的事情：\n正向代理和反向代理 正向代理 正向代理的意思是说，如果你想要访问一个服务器A，但是不能直接访问到，那么你可以通过配置一个代理服务器B，然后让代理服务器B去访问服务器A。这样你就可以通过服务器B来访问服务器A了。\n正向代理的典型应用就是翻墙。假设你想要访问谷歌，但是大陆没办法直接访问，但是假设台湾可以，而你又可以直接访问台湾的服务器，那你就可以在台湾设置一个代理服务器，每次要访问谷歌的时候就先请求代理服务器，让代理服务器访问谷歌，然后将信息传给你，就相当于你自己访问了谷歌。\n反向代理 和正向代理一样，都是通过代理服务器间接访问目标服务器。和正向代理不同之处在于，用户并不知道自己访问的服务器是代理服务器。也就是说，你以为你访问的是谷歌，其实你访问的是台湾的代理服务器。\n反向代理的例子就是防止黑客破坏。比如黑客黑入了你的代理服务器（他以为是真服务器），在里面传播病毒，你的代理服务器挂了，但是你真正的服务器没事，这样就不影响你的网络程序和数据。也就是说黑客只是黑了一个替身而已。\n两者的区别就是正向代理需要用户手动配置，并且用户知道访问的是代理服务器。而反向代理由目标服务器方配置，用户并不知道访问的是代理服务器。\n负载均衡 当客户请求量特别大的时候，单一服务器可能吃不消，这个时候就可以通过代理服务器（一般是反向代理）将请求分发给多个服务器（称为集群），让多个服务器处理：\n1 2 3 4 5 6 7 8 9 #原本的情况 客户端----------服务器 请求 #增加了代理的情况 / 服务器1 客户端--------代理服务器- 服务器2 请求 \\ 服务器3 分发请求 这样就可以加快处理速度了。\n有人说那请求多了代理服务器炸了咋办？那当然可以增加多个代理服务器咯~~（有钱真好）~~。\n动静分离 一般也是使用反向代理。所谓动静分离，就是将动态请求和静态请求分离给不同的服务器处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #原本的情况 客户端-----------------服务器 动态请求和静态请求 #增加动静分离的情况 客户端--------------代理服务器--------------专门处理静态请求的服务器 动态请求和静态请求 | 静态请求 | | 动态请求 | 专门处理动态请求的服务器 这样就可以加快处理速度了。这样的好处是，如果静态请求处理完了，我们就可以先展示Web页面，不让客户干等着，在客户看页面的时候处理动态请求，这样客户关闭页面的概率会变小。\n和HTTP服务器交流 现在让我们真正地和HTTP服务器交流一下（而不是通过浏览器）。我们使用telent程序和百度的HTTP服务器交流。\n首先在终端输入以下命令：\n1 telent www.baidu.com 80 第一个参数是百度网址，第二个参数是你要请求的端口（所以telnet还可以请求其他端口，我们在后面会用到）。\n然后回车，看见这个就是成功了：\n1 2 3 Trying 112.80.248.76... Connected to www.a.shifen.com. Escape character is '^]'. 然后我们想要得到百度的首页，那我们得写一个请求报文对吧。我们就照着上面的例子改一个简短的：\n1 2 GET / HTTP/1.1 Host: www.baidu.com 然后敲两下回车，你就能看到百度首页的html文件内容了。\n网络邮件服务 网络邮件有很多的服务，下面分开看\nSMTP SMTP是网络邮件传输和查询和核心协议。其要求每个报文采用7位的ASCII编码。如果有图像等也需要将其编码为7bits ASCII码。端口号25。基于TCP。\n这个协议很复杂，这里就不细说了，如果想要使用telnet连接的话可以看这篇文章。总之来说就是可以收发邮件\nPOP3 POP3是一个只能查阅邮件的协议，和SMTP不一样，他不能发。端口号为110。基于TCP。\n这个协议非常简单，我们这里连到QQ邮箱试一下。\n先用telnet连接到QQ邮箱的POP3服务器（使用前得先打开QQ邮箱的pop3通讯功能）：\n1 telnet pop.qq.com 110 看到下面信息即成功：\n1 2 3 4 Trying 2408:8756:2cf2:19::11... Connected to pop.qq.com. Escape character is '^]'. +OK XMail POP3 Server v1.0 Service Ready(XMail v1.0) 然后你得登录，输入:\nuser 你的用户名（QQ号即可，不需要加@qq.com） 回车，如果成功会显示+OK。然后输入密码（这里的密码是QQ邮箱给你的加密密码）\n1 pass 你的密码 回车，成功显示+OK。然后你就可以使用list列出所有邮件，retr得到邮件内容，dele删除邮件，quit退出登录了。\nDNS服务 用于通过主机名查找IP地址的服务，端口号53，基于UDP。\n在浏览器上网的时候，你输入 www.baidu.com 就能请求到百度服务器。但是你要知道，程序是通过IP地址和端口号找到的服务器。那么 www.baidu.com 这个字符串是怎么转化到IP地址和端口号的呢？这就是DNS的功能了。\n像 www.baidu.com 这种比较好记的名字叫做主机名，或者叫做域名，是方便人记忆的，但是不包含任何主机信息。DNS可以通过域名来找到对应的IP地址。那么你的浏览器又是怎么知道端口号的呢？因为HTTP服务器的默认端口号为80，所以浏览器默认访问80端口。\n找到百度IP的过程类似如下：首先你的浏览器发送 www.baidu.com 给DNS客户端，然后你的DNS客户端会找一个DNS服务器请求这个域名的IP，这个DNS服务器被称为本地DNS服务器。\n然后本地DNS服务器会将顶级域名.com发送给根DNS服务器，由他来解析.com域名，然后返回给你一个IP地址。\n然后本地DNS服务器根据这个IP地址会找到TLD DNS服务器，这个服务器会解析baidu.com域名，然后返回给你一个IP地址。\n然后本地DNS服务器会根据这个地址找到权威DNS服务器，权威DNS服务器会解析www.baidu.com域名，返回IP地址。\n这个时候，本地DNS服务器就知道百度的IP地址了，将IP传回给原本的客户端，完成转换。\n从上面的情况我们可以发现，DNS服务器同时也是客户端，他也会发送请求给其他的DNS服务器。\n上面的情况可绘制成下图：\n但是有时会是这种情况：\n对比一下就知道这种情况是什么情况了。\n所以DNS服务器不仅仅只有一台，而是有许多台。可能ISP中就有一台，或者其他的有几台。而且DNS是程网状的，根节点处是根DNS。\n使用DNS服务 直接用telnet不行。这里得使用专用工具nslookup。你只要吧网址传给他他就可以返回IP地址和别名。你也可以通过参数来显示器查找的路径。\n","description":"","tags":null,"title":"计算机网络-2-应用层","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2-%E5%BA%94%E7%94%A8%E5%B1%82/"},{"categories":null,"content":"《计算机网络：自顶向下方法》的学习笔记。\n网络的基本组成（硬件方面） 先来看下图：\n像是计算机和服务器这种，处于计算机网络的末端的东西叫做端系统，一般来说称为主机(host)。一般而言，主机如果想要联网，需要经过路由器和调制解调器。\n路由器是用来将你上网的信息转发到其他路由器或者主机。因为网络传输信息靠的是电信号（通过导线）或者电磁波（wifi网络），那么这些信号显然没有办法直接从一个地点直接传达到另一个地点（如果距离很远的话），所以在传输了一段长度之后，需要经过其他路由器再次传播。这就像快递一样，你的快递不能直接从北京到安徽，而是先从北京到蚌埠转运中心，再从蚌埠转运中心到重庆转运中心，然后再到安徽。这里的转运中心就相当于路由器了。\n调制解调器是调制器和解调器所组合的机器，也就是即有调制的作用也有解调的作用。调制是将数字信号转化为模拟信号，解调是将模拟信号转化为数字信号。我们电脑发送的信息都是数字信号，但是数字信号不能以电形式或者电磁波形式借助介质传播，所以必须让调制解调器先将数字信号转化为模拟信号，然后发送给路由器，路由器转发信号，直到目的地，然后目的地的调制解调器再将模拟信号转化为数字信号，然后发给目的地电脑，这样就完成了一次信号传输。\n有时候信号需要通过链路层交换机，它也是转发信号，但是和路由器不同的是，它转发的是链路层信号，也就是按MAC地址找到目的地的。但是路由器转发的是分组，是通过IP地址来找到目的地的（这些概念下面都会说）。\nISP则是网络服务提供商，简单来说就是提供你上网的机构。可以是学校，政府或者其他的。我小时候的时候还是拨号上网，那个时候ISP就是电话局，因为电话局在提供你拨打电话功能的同时也提供你上网功能。由于ISP可以有很多个，但是信号却要发送到世界各地，所以各个ISP也是互相连接的。这样在不同的硬件和机构的连接下，世界上各个地方的人才能找到对方，互联网才能叫做互联网。\n网络的语言-协议 网络中不同的硬件需要相互传输信号，那么必然要相互通信，那么他们是怎么通信的呢?这就要使用协议。协议简单来说就是规定了网络上不同的硬件说同一种语言。如果我的电脑说中文，而你的电脑说英文，那我电脑将信号发送到你的电脑上，你的电脑就识别不了了。那这个时候我们就要定一个协议， 比如说我们都说中文，那么我们两个就可以相互通信了。网络协议也一样，只不过网络发送的是字节流，所以网络协议其实是规定这些字节流是如何排列表示信息的。\n关于协议方面，《TCP/IP详解》三件套讲的非常详细，有需要的可以看看。\n接入网 主机如何接入网络呢？\n接入的方式 家庭接入 一般来说，家庭接入有如下几种：\nDSL（数字用户线），这个我也不知道是什么，我印象中我家有网的时候用的是光纤。不过按照书上的解释，是在拨号上网的年代有的这个东西。拨号上网的线就是DSL，那个线可以同时传输电话信号和网络信号。具体做法是04kHz的频段当做电话信号，4kHz1MHz当做网络信号传输。也就是说是分频段传输。 电缆，这个也是拨号上网时候的东西，和DSL不同，这需要专门架设一条电缆来传输数据。一般都是电缆和光纤混合的导线。这种电缆不是双绞铜线，而是同轴铜线，也就是说不是两条线交织在一起的，而是一根线在另一根线里面。 FTTH（光纤入户），和上面的不一样，使用光作为传输信号，优点是速度快，抗干扰能力强，不易被破解和监听。 卫星，这个听说是通过卫星上网，不过太高级了从未用过。 WIFI，这个是现在常用的方式。 企业接入 企业接入一般是以太网和WIFI。\n物理媒体 传输信号的物理媒体一般分为两种：导引型媒体，指存在固体介质的，如导线，光缆。和非导引型媒体，如空气。\n常见的导引型媒体如下：\n双绞铜线，顾名思义是将两股铜线绞在一起的导线。绞在一起而不是平行放置是为了防止产生的电磁干扰信号。其中有无屏蔽双绞铜线（UTP)。 同轴电缆，顾名思义两根电缆是同轴的，也就是说其中一根包裹在另一根外面。这种电缆更有效地减少了电磁干扰。 光纤，通过不断反射光而以光为信号进行传输的导线。 陆地无线电，也就是我们常说的WIFI。 卫星无线电信道。通过卫星发射信号。 网络的核心 网络发送信息有两种核心方式：分组交换和电路交换。\n分组交换 分组交换是一个重要的技术。\n了解分组交换之前需要了解报文和分组的概念。\n报文就是你要传输出去的一份信息，但是这份信息可能非常大，比如几个G。但是路由器的话可能只能一次性转发几百兆，那么这个时候就要对报文进行分段，分成一段一段的分组（fragment），然后将分组传输出去。\n分组交换是由分组交换机和链路层交换机做的，其实就是指它们得到分组之后再转给另一台交换机的过程。\n但是看起来很简单的分组交换机制中也有很多问题：\n存储转发传输 指交换机在发送分组之前，必须接收到这个分组的所有字节。因为分组是以电或者光信号传播的，存储转发传输就告诉我们不能在接收到一半的分组之前就把信息传出去，而是要等到整个分组接收到之后再传出去。\n排队时延和分组丢失 分组交换机一次能存储很多分组（存在缓冲区中），这些分组先到先发，后到的就只能排队等着。由于排队产生的延时就叫做排队时延。\n那么如果分组交换机的缓冲区装满了，装不下分组了怎么办呢？那这个时候交换机就会丢弃新来的分组或者缓冲区里的分组。这个情况就是分组丢失。\n转发表和路由选择协议 当一个分组到达路由器的时候，路由器怎么知道发到哪个地方去呢（要注意分组内部只记录最终的目标，所以下一次转发到什么地方是由路由器决定的）？很简单，路由器内部有一个转发表，它会查这个表来确定转发给哪一个路由器。但是路由器可能走弯路啊，就像快递一样，明明从北京直接到安徽就行了，它非得先到一下重庆。这个时候路由选择协议会帮助路由器选择最近的路线，并且使用这些路线来配置转发表，让路由器转发地更快（这一部分《TCP/IP详解：卷一》说的很详细）。\n时延，丢包和吞吐量 时延 在分组经过由分组交换控制的交换机时，会经历四个时延：\n节点处理时延：这是分组刚刚到达时产生的时延，交换机需要分析分组信息，以找到目标地址，然后确定下一次转发的地址。 排队时延：上面提到过了 传输时延：指交换机将报文全部发送出去的时长 传播时延：指报文通过介质从这个交换机传到另一个交换机/路由器的时延 这四个时延加起来就是总体时延了。\n其实还有很多其他的时延，比如端系统时延：由于端系统传输而导致的时延；以及程序时延：应用程序处理信息而导致的时延。不过这些不在考虑范围内。\n丢包 上面其实也提到过了，就是在路由器缓冲区满的时候，新来的分组会被丢弃这件事情就叫做丢包。\n电路交换 电路交换和分组交换不一样，电路交换在主机通信会话的时候，会预留主机间沿路径通信所需要的资源（缓存，链路传输等），会话的报文按需使用这些资源。\n这是什么意思呢？很简单，分组交换和电路交换其实就和你去小菜园吃饭一样，分组交换你是直接去餐馆，到了餐馆，如果有位置，你就坐下来消费，没位置你就得等。这就和报文一样：先进入缓冲队列，等着把你发送出去。\n但是电路交换不一样，所有顾客是预约式服务，你要去你得先去预约，这个时候餐馆会记下你的信息（也就是预留主机间通信所需资源），然后等你去消费。如果你不预约直接去消费，那么餐馆即使有空位置你也不能坐，因为那些位置是被预约的。\n这里很显然看出电路交换和分组交换的优缺点：\n分组交换： 优点：多个主机可以同时通信 缺点：通信不稳定（后来的分组可能被丢弃） 电路交换： 优点：通信稳定，不允许打扰 缺点：不能多个注意同时通信，要通信得等电路空闲。显然电路交换还有静默期，也就是如果一个主机不发送信息了，但是没有断开连接，那么仍然不能将这个电路交给另一个主机使用。典型的就是打电话，你打电话的时候不说话，那另一个人也没办法打给和你通电话的那个人。 现在大多数都是使用分组交换。\n复用 电路交换提出了时分复用和频分复用的方式。顾名思义，时分复用就是将时间分成一块一块的，每一块时间专门服务一个主机。而频分复用则是将电信号和光信号的频率分段，每一段代表一个主机专门的信号。\nTraceroute程序 想要看到你的分组中间经过了哪些路由器和传输的时间？Traceroute程序可以帮助你看到。Traceroute的实现原理使用了ICMP协议，具体可以看《TCP/IP详解：卷一》。\n吞吐量 假设B在t时间内接受了一个大小为b的文件，那么在t时间内的吞吐量就是$\\frac{b}{t}$。这个吞吐量就是平均吞吐量，如果非要给这个时间取极限，那就是瞬时吞吐量。\n计算机网络的层 计算机网络被分为五层：\n应用层：应用程序所在的层，不涉及硬件，一般的网页制作和socket编程就是应用层的，也是程序员编程时解出的层 传输层：用于建立端到端连接的层，使用TCP和UDP协议。 网络层：负责数据报的产生和传递转发。 数据链路层：掌控数据链路的层。 物理层：涉及物理硬件的层，像网卡等。 注意传输层和网络层的区别：网络层才是传输数据的层，而传输层则是建立连接的层。也就是说，传输层建立了传输的通道，然后网络层再传输数据。\n","description":"","tags":null,"title":"计算机网络-1-基本概念","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"这里是我学习Perl的笔记，需要你了解Linux Bash脚本语言，Python语言的语法和常用的数据结构。\n如果你没有这些知识，也可以点进来看看我推荐的Perl书籍（在开头就有）。\nPerl 的介绍 什么是Perl Perl是一门广泛运用在Linux系统上的脚本语言。在Python出现之前Linux系统上大家基本上都使用Perl进行出现编写。比起其他语言，Perl的优势在于文本和表格的处理。Perl也一度在网络编程中占据重要优势，以前的CGI程序大部分都是Perl写的，以前的运维也必须学习Perl。\n虽然现在很多的语言抢走了Perl的工作，但是学习Perl无疑可以让我们在Linux系统上工作的更好。Perl和C语言一样，是大多数Linux系统自带的语言。\nPerl适合做什么？ Perl非常适合编写一次性程序，如果你现在有个问题，但是又不想太花时间使用C/C++的话，Perl是个好选择（我甚至觉得在这方面Perl比Python的表现还要好）。\nPerl也很适合编写快速的原型和文字处理程序。文字处理是Perl的强项。\n其实除了文字处理，Perl也可以干很多事情。和Python一样，Perl有被称为CPAN的包社区，里面有处理各种情况的包。\nPerl不适合做什么 首先和Python一样，由于是脚本语言，Perl没办法生成二进制文件，要想发布程序，必须连同源码发布出去。\n其次，大程序和工程可能并不适合使用Perl来编写，因为Perl的语法问题。。。\n使用的Perl版本 这里使用的是Perl5版本。6版本听说不受待见，而且据说改的像一门新语言，所以从5版本开始学习。\nPerl的语法特点 Perl是很多语言语法的混合体，你可以在里面看到Bash脚本，C/C++，Python的影子。所以如果你语言见得比较多，学习Perl会非常容易。\n学习Perl的资料 零基础入门推荐Perl三部曲，即骆驼书：\n《Learning Perl》初级入门（中文《Perl语言入门》） 《Immediate Perl》进阶 《Mastering Perl》高级Perl 实践方面可以看《Perl最佳实践》\n口袋书的话推荐《Perl 5 Pocket Reference》\nUnix网络方面的话可以看《Perl网络编程》。如果你觉得使用C/C++进行Unix网络编程太麻烦的话（比如直接看《Unix网络编程》系列），那么我十分推荐看这本。因为Perl的网络编程API几乎和Unix的API一模一样，但是Perl使用起来却很方便，这有利于你免去复杂的结构体配置，快速熟悉Unix网络方面的API和编程技巧，等学完之后再去看《Unix网络编程》会更加得心应手。\n另外，十分推荐在Linux系统上学习Perl。\nPerl自带的帮助文档 如果你安装了Perl，那么你应该也安装过了perldoc工具。这个工具的功能和Linux下的man差不多，也就是perl语言的帮助文档。有什么不会的可以查一查。\n开始Perl的学习 HelloWorld 1 2 #!/usr/local/bin/perl print \"Hello World!\\n\"; 和Python2很像对吧，第一行和Bash脚本类似，指定Perl的解释器在哪里。\n第二行的print是函数。你也可以加上括号:print(\"Hello World!\\n\")，但是如果解释器可以明确无歧义的判断参数类型话也可以不加括号。\n我要怎么运行？ 很简单，如果你写了第一行，那么直接将这个源代码文件变为可执行的，然后运行即可。\n如果没有第一行，你就只能通过Perl解释器来运行，和Python一样：\n1 perl helloworld.pl Perl的文件可以不加后缀名，但是如果你要加的话，可以加pl，这也是大多数编辑器默认的Perl文件后缀。\n分号是必须的吗？ 对，是必须的。\n区别大小写吗 区别\nPerl的注释 Perl只有行注释，使用#。\n变量 创建变量 和Python一样，变量拿来就可以用，不需要声明，但是需要在前面加上$：\n1 $a = 32;\t#显然是Bash的语法习惯 这里要注意的是：当你在块里面（即花括号里面）和函数里面，甚至循环，判断结构中直接使用变量的话，这些遍历全部都是全局变量！\n要想使用局部变量，必须使用my关键字：\n1 2 3 4 if(expression){ my $a = 20;\t#局部变量 $b = 30; #全局变量，出了if语句还能用 } 当然，变量仍然遵循就近原则：如果在内部声明了局部变量，那么全局变量会被隐藏。\n使用warning（见下）会帮助你在局部块中新创建了全局变量时给你一个警告⚠️。\n或者如果你想让Perl强制你使用my的话，可以使用严格模式：\n1 use strict; 这样即使在全局环境中你都得使用my关键字创建变量。\n基本数据类型 标量数据 标量数据指数字,字符串,undef。\n数字 无论是小数还是整数，Perl一律视为双精度浮点数。\n1 2 3 4 5 6 7 $a = 5.21; $b = 3.2e10; #3.2*10^10 $c = 61_289_9129_01\t#允许插入下划线，将若干位分开，这样看的清楚 $oct = 0377;\t#8进制 $hex = 0xff; #16进制 $binary = 0b11101101; #2进制 $d = 0xff_ee_3a;\t#同样可以使用下划线 操作 四则和位运算是和C/C++一样的运算符，但是由于所有数字都视为浮点数，所以不存在整数除整数还是整数的情况。\n字符串 使用双引号括起来的字符串内部可以转译。\n使用单引号括起来的不能转译。\n字符串可以内插，语法和Bash脚本一样：\n1 2 3 4 $str1 = \"Hello\"; $str2 = \"World\"; $c = 32 $expression = \"${str1} ${str2}! ${c}\" #\"Hello World 32\" 这里和Bash一样，${str1}中的花括号在没有歧义的时候也可以不加。\n支持UTF8 Perl原生支持Unicode。如果想要支持UTF8编码，需要在代码开头（#!/usr/local/bin/perl下面）加上\n1 use utf8; 操作 最主要的操作是连接操作：\n1 2 3 4 $str1 = \"Hello\"; $str2 = \"World\"; $expression = $str1 . \" \" . $str2; $str .= \" ${str2}\";\t#甚至有专门的.=符号（意义和+=意义） 使用.连接\n也可以进行重复：\n1 2 3 $str1 = 'a'; $multipul = str1 x 4;\t#'aaaa' $multipul = str x 4.6; #'aaaa' 小数会自动舍弃 使用x进行重复。\n数字和字符串的相互转换 在Perl中，数字和字符串被视为一个东西。什么时候将值视为字符串，什么时候视为数字，取决于你使用的操作符。\n比如3+2显然就是数字之间的操作，直接得到5。然而'3'+2这种情况也可以得到5。因为Perl会在需要数字的时候将字符串自动转换为整数(或者换句话说，因为+操作只能对数字有用，所以字符串会变为数字），而针对字符串的操作则会将数字变为字符串，如'3' . 2得到'32'。当转换字符串到数字时，Perl会从字符串开头的第一个字符开始看，直到遇到字符停止（小数点不算），也就是说：\n1 2 3 4 $str1 = \"0.322\" #转化为0 $str1 = \"3.221\" #转化为3.221 $str1 = \"321ab45\" #转化为321 $str1 = \"abe123\" #转化为0 所以3 x 2将会是'33'，因为3和2转换成字符串了。而3.2 x 2会得到3.23.2\n而且八进制和十六进制的前置0和0x技巧只对直接量有效，不能用于字符串转换：\n1 '0377'\t#转化为377 想要知道数字和字符串对应的操作符？请参阅perlop文档（使用perldoc perlop即可）。\n害怕转换？请使用警告 如果你担心Perl的这种自动转换会给程序带来风险，你可以使用use warnings;来让Perl在含糊不清的地方报一个警告。这样你就可以针对警告来修改你的代码。但是注意，抛出警告并不意味着Perl会自动帮你修改程序，它该怎么转换还是怎么转换。\n也可以使用use diagnostics来抛出更详细的警告。\n数字和字符串的逻辑运算符 由于Perl会根据运算符来视值为数字还是字符串，所以对数字和字符串有不同的比较操作符。\n数值的话使用常规的方法，字符串则是借鉴了Bash脚本的语法：\n等于 不等于 小于 大于 小于等于 大于等于 数值 == != \u003c \u003e \u003c= \u003e= 字符串 eq ne lt gt le ge undef undef即未定义，和C的NULL，Python的None差不多。undef会被视为假。\n对于undef的操作，主要是判断一个变量或表达式是否是undef。可以使用函数defined()来判断。\n列表（数组）和哈希 这两个结构的元素都是异质的，但是哈希的键必须是字符串。\n列表（也就是数组啦） Perl的列表是很宽泛的：\n1 2 3 $arr[0] = \"value1\"; $arr[2] = \"value2\"; $arr[3] = \"value3\"; 你可以像上面这样直接将普通变量当做数组，只需要在后面加上索引即可，而且索引是可以跳的。如果这个时候你使用$arr[1]会得到undef。\n任何可以求值得到数字的表达式都可以作为下标，如果不是整数，会自动舍去小数。\n使用$#arr_name来得到数组中最后一个元素的索引值。或者你可以像Python一样直接使用负数来得到最后一个元素。\n列表直接量和数组引用 除了像上面那样一个一个费劲地放入元素，还可以使用列表直接量：\n1 @arr = (1, 2, 3, 4) 这里括号包裹的一堆东西就是列表。\n如果想要使用列表这个整体（也就是引用列表），那么就必须使用@符号放在前面。\n使用范围操作符来生成数组 可以使用a..b的形式来生成[a, b]区间的所有整数：\n1 @arr = 1..3;\t#arr为 (1, 2, 3) 列表之间的赋值 列表和列表之间可以赋值，但是你能否想到这种方式：\n1 ($value1, $value2, $value3) = qw{a b c}; 这里利用了列表赋值的特性，这个语句等价于:\n1 2 3 $value1 = \"a\"; $value2 = \"b\"; $value3 = \"c\"; 如果你有不想要的元素，可以使用变量$_代替：\n1 ($value1, $value2, $_, $value3) = @arr 列表的输出 可以通过print函数直接输出列表，但是列表的元素之间不会有空格分开，连在一起很难看。\n解决办法是将列表内插到字符串中，这样在输出的时候就可以自动增加空格：\n1 print \"@arr\"; 简便的纯字符串列表创造方法 使用qw可以快速创建所有元素都是字符串的列表：\n1 2 @a = qw(Berk Slash GQ) #得到列表(\"Berk\", \"Slash\", \"GQ\") 使用qw的好处是在于不用在字符串外面加上双引号了。\nqw后面的括号可以换成其他的，比如方括号或者花括号。如果不是成对的字符就直接使用自己即可：\n1 2 @a = qw\\asd asd asd\\; @b = qw{wqm ewq olk}; 将列表当做栈 可以使用pop和push函数将列表当做栈，栈顶是列表的最后一位：\n1 2 pop @array; push @array; 也可以使用shift和unshift，这个时候栈顶是列表的第一位。\n在列表中间增加移动元素 使用splice可以做到\n1 splice @array, pos[, list_len][, @subt_arr]; 第一个参数是要控制的列表，第二个参数是从哪个位置开始。\n如果只给出上面两个参数，会返回这个列表的开头到pos的子列表。\n第三个参数指出要返回的长度（注意并不是结束位置），第四个参数是在拿出元素之后要加的元素，以列表存储。\n也就是说:\n1 2 3 @arr = qw{A B C}; @remove = splice @arr, 1, 2, qw{D E}; #remove为移出的元素，即(B,C)，然后arr为(A, B, D, E) 反转数组 使用reverse，这个在很多语言里面都有了，不讲了。\n排序 使用sort函数，排序的时候会将数字转换为字符串，然后按照ASCII码来对字符串排序。默认升序排序。\n哈希 哈希和我们常说的哈希表不太一样。这里的哈希更像是Python中的字典，C++中的map。由于Perl中的哈希的内部存储是通过哈希表存储的，所以被称为hash。\n哈希的键必须是字符串，值可以是任意数据类型。\n访问hash 访问哈希和数组差不多，但是要使用花括号：\n1 $hash{'key1'} = \"value1\"; 同时这也是给哈希赋值的一种方式。\n和列表一样，你可以手动地给哈希的每一个元素像上面一样赋值。\n如果访问了不存在的键，会返回undef。\n访问整个hash 哈希的特有前缀是%:\n1 %hash = %hash2; # hash之间的赋值 快速创建hash 列表可以转换为哈希，我们可以利用这种特性：\n1 2 3 4 %hash = (\"key1\", \"value1\", \"key2\", \"value2\"); # 相当于 %hash{\"key1\"} = \"value1\"; %hash{\"key2\"} = \"value2\"; 同样地，哈希也可以转换为列表:\n1 2 @list = %hash; #list 就是 (\"key1\", \"value1\", \"key2\", \"value2\") 但是不能保证列表中元素的顺序（但是相关联的键一定在其值前面）\n或者你可以使用更加清晰的赋值方式：胖箭头：\n1 2 3 4 5 %hash = ( key1 =\u003e 'value1', key2 =\u003e 'value2', key3 =\u003e 'value3' ); 其实胖箭头=\u003e在解释的时候会被解释为逗号，并且会将箭头左边的量自动视为字符串，所以这里的语法其实和上面的语法是一样的，而且你不需要在键上加上引号。当然在列表中你也可以使用：\n1 @list = (2 =\u003e 3 =\u003e 4 =\u003e 5); 不理解的话将胖箭头视为逗号即可。\n那么这里有人会问了：这里的2，3，4，5是字符串吗？其实这个问题没有意义，因为字符串和数字是一个东西，是不是字符串取决于你怎么使用它。\nhash函数 这里有一些常用的hash函数：\nkeys %hash得到hash的键所组成的列表 values %hash得到hash的值组成的列表 reverse %hash将hash的值变为键，键变为值 exists %hash, key检查hash内是否有键key delete %hash, key 删除hash内的key及对应的value。没有key的话不做操作。 和列表一样，你也可以使用each来在迭代中同时得到键和值：\n1 2 3 while(my ($key, $value) = each %hash){ #... } 环境变量%ENV %ENV哈希是系统自带的哈希，表示当前的环境变量。\n命令行参数变量@ARGV 也就是我们在C/C++中的int main(int argc, char** argv)和Java中的void main(String[] argv)中的argv了。存储命令行给出的参数的列表。\n$_变量 Perl中有个很奇特的变量，$_，当你的函数缺少参数，或者循环中缺少循环体的时候，这个变量就会自动补上。比如:\n1 2 3 4 @arr = qw{a b c d} foreach (@arr){ print; } 这里并没有指定循环遍历和print函数的参数，那么$_变量就会自动补上。所以上面的代码等价于：\n1 2 3 4 @arr = qw{a b c d} foreach $_ (@arr){ print $_; } 固有前缀 Perl中有一个令人迷惑的行为：列表和普通变量的名字可以是一样的！不仅如此，列表，变量，函数，字典等的名字都可以是一样的！那么如何区分它们呢？这就要使用前缀。每一个数据类型都有自己独有的前缀，比如变量就是$，列表就是@，然后字典是%，函数则是\u0026。那么$a就是a变量，而@a就是a列表了。\n引用 perl里的引用和C++的引用差不多，本质上就是C语言指针。\n使用\\来表示引用：\n1 2 @arr = qw(a b c d); $ref_arr = \\@arr; 这个时候$ref_arr就指向列表arr了。\n引用其他的也是一样的：\n1 2 $ref_scalae = \\$scala; $ref_hash = \\%hash; 解引用的话只要在引用前面加上固有前缀就可以了：\n1 @$ref_arr;\t#相当于直接使用@arr; 对于哈希和列表，也可以在不全部解引用的情况下使用内部元素：\n1 2 $ref_list-\u003e[3];\t#使用-\u003e取出元素，列表用下标 $ref_hash-\u003e{key1};\t#哈希用键取出 控制结构 条件判断 If语句 if语句的格式和C差不多：\n1 2 3 4 if(expression){ }elsif(expression){ }else{ } 需要注意的有两点：\n表示_else if_的语句是elsif 不能像C语言一样，如果只有一条语句的话不加花括号。Perl里面条循环语句，条件语句都必须加花括号。 表示假的东西有：undef,0和空的东西（空字符串，以及空列表，空哈希等）。\n这里有一点需要注意：字符串'0'和\"0\"由于会事先被转换为数字0，所以字符串'0'和\"0\"也是假！\ngiven-when结构 只能在5.10版本中及以后使用，所以你需要事先指定perl版本：\n1 use 5.010; 功能和C的switch差不多，语法如下：\n1 2 3 4 5 given(variable){ when(condition1){ expression1 } when(condition2){ expression2 } default { default-expression } } given会将variable一个一个和condition匹配，如果成功了就会执行后面的代码。\n和switch一样，如果你最后不加break，那么会导致继续向下匹配。\n循环语句 while循环和unless循环 while循环是当条件为真的时候循环，而unless是当条件为假的时候循环：\n1 2 3 4 5 6 7 while(expression){ } unless(expression){ } for语句和foreach语句 for语句和C的一样，只不过在变量声明的时候需要遵循Perl的语法：\n1 2 3 for(my $i=0;$i\u003c10;$i++){ print $i; } foreach语句必须在5.010版本下才能使用。\nforeach可以让你像Python一样遍历可遍历结构，比如遍历列表：\n1 2 foreach my $ele (@list){ } 也可以使用each操作符来遍历列表，可以同时得到列表的下标和元素:\n1 2 while(my($index, $value) = each @arr){ } 表达式修饰符 Perl有一个我很喜欢的功能，就是可以在表达式后面加一个控制行为的修饰符：\n1 print \"$n \u003c 0\" if $n\u003c0; 像这样，这样的话只有$n小于0的时候前面的语句才会执行。这种方法很简洁易懂。\n你也可以在后面加上or：\n1 chdir '../awe' or print $!; 这里如果chdir返回了表示假的值的话，会执行后面的print语句。这种语句广泛用于在函数出错的时候输出出错信息。\ndie和warn关键字 顾名思义，die关键字会让程序die，也就是让程序停止运行。相当于C/C++中的throw和assert(false)。die后面可以接一个字符串来让程序执行到die的时候输出这个字符串。也就是说在人工停止程序的时候给出一些信息：\n1 die \"I'm died\"; 配合上前面说的控制修饰符，我们可以这样写：\n1 chdir \"../era\" or die $!; 如果chdir函数出错，那么停止程序并输出出错信息。\nwarn的用法和die一样，只不过不停止程序，而是给出一个警告。\n子程序（函数） 定义子程序 1 2 3 sub function_name{ #function body } 采用sub关键字就可以定义。需要注意的是函数是没有参数列表和返回值类型的。\n参数在哪里？ Perl使用@_数组来存储参数。第一个参数存储在$_[0]，第二个存储在$_[1]，以此类推。\n这就导致一个情况：你可以给一个函数任意多个参数。参数的不确定性进而引起一个IDE方面的特性：由于没有办法通过函数签名来知道函数有多少个参数，进而也就没办法在自动补全的时候告诉你参数的类型和个数。但有些IDE可以通过分析Perl文档来提示参数，但这也意味着你需要给你的函数写文档。。。\n还有一个注意的地方：@_符号是函数内的私有变量，所以出了函数也就没办法使用，除非你自己定义了全局的@_。\n有了这种得到参数的方法，变长的参数想必也是很容易实现了。\n如何返回返回值？ 你可以像C/C++等语言一样使用return，但是Perl有一个更懒的方法：函数总会将其最后一行表达式的值返回（如果没有return的话）。这样，一来，不管你有没有return，函数总能返回值，只不过是返回的值有没有意义而已。\n如果最后一行是函数调用，那么调用的函数的返回值将会被返回。\n函数调用 像C/C++一样调用:\n1 print(\"param\"); 如果参数的类型不会因为上下文而导致歧义的话，也可以省略括号。\n由于函数和变量可以重名，所以在调用无参函数的时候，你要么加上一对括号，要么使用\u0026符号前缀，以和普通变量区别:\n1 2 max(); \u0026max; 简单来说，如果Perl可以判断出你调用的函数一定是函数，那么就可以省略\u0026符号。\n这里还有一个很重要的情况：用户自定义函数可以和系统自带函数重名！。在这个时候，如果你想要调用系统函数的话，必须在调用函数的前面加上\u0026，不然默认调用的是用户自定义函数。\n持久性私有变量 也就是C/C++中的静态变量，Perl里面使用state关键字声明：\n1 state $n = 2; 当然只能在函数内部使用。\n函数出错了？看一下$!变量吧 如果函数的返回值表示函数出错了，你可以输出$!变量来看看函数的错误信息（如果函数写了错误信息的话）。\n后调用的函数会重新将错误信息放入$!中（如果有错误的话），你也可以自己在函数出错的时候将信息写入$!中（但是我们默认不在函数成功的时候将成功信息放入$!中）。\n正则表达式 Perl最强大的功能莫过于正则表达式了。虽然Python和C++，Java都带有正则表达式，但是Perl的正则使用方法是他们中最简单的。这也使Perl特别擅长对文字的处理。\n如果你不会正则表达式的话，我推荐你去看看《精通正则表达式》（Mastering Regular Expression）。说实话，学Perl不用正则的话，很大程度体会不到Perl的方便。\n如果你使用过vim，那么Perl使用正则的方式你会感到很熟悉。\n使用正则表达式 和vim一样，使用/将正则括起来，需要转译的字符用\\转译：\n1 2 3 if(/*abc+/){ # some operators } 如果匹配成功，正则会返回真，否则返回假。像上面一样，如果不指定要匹配的字符，默认使用$_里的字符匹配。\n其实这是m//的简写。和qw语句一样，你也可以使用m{abc}或者m!abc!、当你不想加m的时候可以直接写//。也就是说，上面的语句和\n1 if(m{*abc+}){} 一个道理。\n如果想要指定匹配的字符串，需要使用=~符号：\n1 if(\"uiqjabcc0o\" =~ /*abc+/){} 模式分组 模式分组是正则里面的一个功能。简单来说就是你可以在正则表达式中使用已经匹配到的内容，比如：\n1 /(abc)\\1/ 这里圆括号表示一个分组，这里的分组会匹配到abc。然后使用\\n的方式引用第n个分组（分组从1开始），所以这里的正则表达式相当于：\n1 /(abc)abc/ 当然你也可以：\n1 /(.)\\1/ 这样会匹配两个连在一起的一模一样的字符，比如abba中的bb。\n至于每个括号的分组编号是什么，很简单，从左往右看，第一个左括号代表的分组编号就是1，第二个左括号就是2，以此类推。\n模式匹配修饰符 这部分知识属于正则知识，不再赘述，只是说一下Perl中常用的修饰符：\n修饰符加载最右边:\n1 /ab/[修饰符1][修饰符2][...] i：大小写无关匹配 s：匹配任意字符（大部分情况下.号无法匹配换行符，使用这个来让.可以匹配换行符 x：加入空白符，加上x后可以在模式里面加入任意空白符（空格，制表符和换行回车符），所以原来的空白符Perl会直接忽略 模式中的内插 没错，正则中甚至可以内插变量：\n1 /asc$var1/ 当有歧义的时候，可以使用括号将变量单独括起来。\n捕获变量 当你使用括号扩起一组正则的时候，Perl会匹配这个正则，并且留下来匹配的内容在$n变量中，以便于你得到匹配的结果：\n1 /(*a)(.+?b)asd(cca)/ 这个时候有三个组*a,.+?b,cca。当你匹配的时候，匹配到的值会分别存入三个捕获变量$1,$2, $3中来方便你获得。\n捕获变量的值会一直存在，除非你手动改变它或有另一个正则匹配成功。注意，失败的匹配不会改变捕获变量，所以你应当只在匹配成功的时候使用捕获变量。\n不捕获模式 如果你不想让每一个括号都影响捕获变量呢？可以使用(?:pattern)的方法，在左括号右边紧接上?:即可避免这个括号影响捕获变量。\n命名捕获 如果你觉得$n这种捕获变量的名字太难记了，对又对不上号，那么你可以给捕获组命名，匹配成功后会自动放入哈希%+中：\n1 /(?\u003cname1\u003eacc*)acs/ 使用(?\u003cvar_name\u003epattern)的方式来指定名称，这样，第一个括号就不会影响到$1，而是放入$+{name1}中。\n自动捕获变量 有三个系统自带的捕获变量：\n$\u0026：匹配的部分会被存入 `$``匹配区段之前的部分会被存入 $'：区段之后的部分会被存入 只要你在程序中使用过一次上述变量，Perl机会在所有正则中将对应部分存入这些变量。这将导致正则的效率变慢。所以这些变量最好不要使用。\n替换 正则不仅能查找，也能替换。和vim一样，使用s///的方式替换：\n1 s/abc/bca/\t#将abc替换为bca 和vim一样，在最后加上g表示全局替换：\n1 s/abc/cba/g #这样就不仅仅替换找到的第一个字符串，而是所有找到的字符串都会替换 输入和输出 标准输入和输出 \u003cSTDIN\u003e,\u003cSTDOUT\u003e,\u003cSTDERR\u003e就是我们熟悉的标准输入，标准输出和标准错误流。在Unix中，你需要使用open函数打开，然后使用write函数写，read函数读。Perl也差不多，只不过不用打开而已：\n1 2 3 while(\u003cSTDIN\u003e){ print $_; } 上面的程序将用户的所有输入原样打在屏幕上。\nprint函数其实就是将ASCII写到\u003cSTDOUT\u003e中。你也可以使用printf函数来格式化输出（和C语言的一样用）。\n这个时候有人会问了：那我在print函数里面可以内插数组，那在printf里面怎么表示数组呢？很简单，假如@items是一个有10个元素的数组，那么你需要：\n1 printf \"the items are :\" . (\"%s \" x @items), @items; 这里首先使用x将%s重复10次（在标量上下文中，直接引用列表将会得到列表的大小），然后和格式化字符串连接，最后放入items列表当做参数即可。\n钻石操作符 \u003c\u003e符号被称为钻石操作符，可以将给入的命令行参数所指的文件内容读入。也就是说：\n1 2 3 4 5 while(\u003c\u003e){ print $_; } #然后执行 ./diamond.pl file1.cpp file2.pl file3.java 会输出file1.cpp,file2.pl,file3.java的内容。也就是说钻石操作符首先会从命令行参数中取出第一个参数，然后打开这个参数指向的文件，将文件的内容返回（这里直接返回到$_中）。\n在不同的上下文中其返回的结果也是不一样的，：\n1 @arr = \u003c\u003e; 在列表上下文中会返回所有文件的内容，以行分割。\n文件句柄 和其他语言一样，Perl有文件句柄。有6个文件句柄是Perl保留的：STDIN, STDOUT, STDERR, DATA, ARGV, ARGVOUT。\n在Perl程序打开的时候 ，print和say会和STDOUT关联，而warn和die会和STDERR关联。\nPerl程序员一般将文件 句柄的名字全大写，以和普通变量区别。\n文件句柄没有任何固定前缀，也就是说长这样：HANDLE。\n打开文件句柄（打开文件） 使用open函数打开：\n1 open HANDLE, $filename; oepn不会返回文件句柄，而是将文件句柄赋值给第一个参数。\n第二个参数是文件名称，如果你只是给入文件名称，那就是读（已存在）的文件，也就是C语言中的r操作。\n如果在文件名前加上\u003e表示以写的方式打开文件（C语言中的w）。\n如果在文件名前加上\u003e\u003e表示以追加方式打开（C语言中的a）：\n1 2 3 4 5 open FHANDL, \"\u003cfile.txt\";\t#读方式打开，\u003c可以忽略 open FHANDL, \"\u003efile.txt\";\t#截断文件，以写方式打开 open FHANDL, \"\u003e\u003efile.txt\";\t#追加方式打开 open FHANDL, \"+\u003efile.txt\";\t#截断文件，然后打开用于读写 open FHANDL, \"\u003c+file.txt\";\t#用于读写，不截断 在5.6版本之后，你也可以用更清楚的方式打开：\n1 2 open FHANDL, \"\u003e\", \"file.txt\";\t#可以将打开方式和文件名分开。 open FHANDL, \"\u003e:encoding(UTF-8)\", \"file.txt\"; #以写方式，UTF8编码打开。 那么如何用二进制方式打开呢？这需要使用binmode关键字：\n1 binmode FHANDL; 也就是说，你先用open打开文件，然后再用binmode将其变为二进制读写。\n如果你比较熟悉Unix的openAPI的话，你也可以使用sysopen，这个函数的用法和Unix的open函数完全一样：\n1 sysopen FILE_HANLE, $filename, $mode; 复制文件句柄 你也可以使用open来复制文件句柄：\n1 2 open FHANDLE2, \"\u003e\u0026STDOUT\";\t#使用\u003e\u0026来复制用于写的文件句柄 open FHANDLE3, \"\u003c\u0026STDIN\";\t#使用\u003c\u0026来复制用于读的文件句柄 关闭文件句柄 使用close函数关闭文件句柄。\n读取文件 读取的话分为两种：一行一行读取和按字符读取。\n一行一行读取的话和从STDIN读取数据一样：\n1 2 3 while(\u003cFHANDL\u003e){ print $_; } 上面的语句会将文件里的每一行读到$_中并输出\n如果想要按字读的话，那么就使用read和sysread函数：\n1 2 $read_byte = read FILE_HANDLE, $buffer, $length [, $offset]; $read_byte = sysread FILE_HANDLE, $buffer, $length [, $offset]; read和sysread的使用方法一样，将从开头偏移$offset,长度$length的内容读入$buffer中。而且注意这里的第一个参数后是由逗号的。\n区别在于read是阻塞函数，除非读到文件末尾，否则会一直读length长度。而sysread是非阻塞的。这一点在对socket编程的时候由很重要的区别。\n写文件 同样也是分一行一行写和写一堆。\n一行一行的话直接用print，printf和say均可。具体做法是将文件句柄放在第一个参数的位置：\n1 print FHANDL \"hello world\"; 注意中间是没有逗号的。\n如果要一次写一堆的话，使用函syswrite就可以了：\n1 $write_bytes = syswrite FHANDLE, $data [, $length][, $offset]; 这里注意，write函数和syswrite的功能是不一样的，不要混淆。syswrite是非阻塞的。\nselect函数 select函数有很多种情况，其中一个情况是只有一个参数：\n1 $previous = select HANDLE; 这会改变print指向的句柄。也就是说print原本是指向STDOUT的，你可以将其改变为你的文件句柄，然后直接输出，这样内容就会到文件句柄中。\n这个函数返回上一个句柄。\n检测文件尾 使用eof(FHANDLE)函数来检测文件末尾，如果下一次读取的时候到达了文件尾，那么会返回真。\n使用面向对象的方法操作IO Perl有一些模块可以通过面向对象的方法使用IO，常用的是IO::Handle（对文件句柄进行面向对象）和IO::File（对文件进行面向对象）。IO::File比IO::Handle用途更多。\n要使用模块，首先的使用use关键字：\n1 use IO::File; 对于IO::File，我们给出一个例子：\n1 2 3 4 5 $file = IO::File-\u003enew(\"test.txt\");\t#新建一个文件对象 while($file-\u003egetline()){\t#每次循环获得文件的一行 print $_; } $file-\u003eclose();\t#关闭文件 具体的用法请见perl文档。\n文件，目录操作 Perl的文件和目录操作基本上都是和Unix系统编程中同名的API函数，只不过需要在Perl的语法下使用而已。\n文件测试 Perl可以得到文件的一些信息，以及测试文件的一些属性。\n测试的方法和Bash脚本差不多:使用-X（X是一个字符）来表示测试。比如-e表示测试是否存在：\n1 if -e $filename;\t#如果文件存在返回真 所有的测试符可以见这里测试符的最下面。\n在5.10版本前，如果想要测试多个文件符，必须分开操作。在5.10之后可以将其放在一起：\n1 if -x -e $filename; stat和stat函数 stat是Unix系统编程的一个函数，perl里也可以使用这个函数。\n这个函数的功能是返回文件的一些信息，包括uid，符号链接的数量等。\nstat函数的参数可以是文件句柄，或者是文件名称。其返回一个含13个元素的列表（如果失败返回空列表）：\n1 （文件所在设备的设备编号，文件所在的inode编号，文件的权限位几何，文件或目录的硬链接数，uid，gid，设备标识符，文件大小[以byte计]，最后使用时间，最后修改时间，inode编号改变时间，最适IO大小，分配的系统特定块的实际数目） = stat $filename; localtime函数 localtime也是和Unix函数一样的。其参数为时间戳，返回值视上下文：\n标量上下文：返回一个可读的表示时间的字符串 列表上下文：返回($sec, $min, $hour, $day, $mon, $year, $wday, $yday, $isdst)列表。其中$mon是0-11的月份值，$year是从1900年开始的年份，所以 你得加上1900年才能得到现在的年份。$wday是从0-6的值，代表从周日到周六，$yday表示目前是今年的第几天，从0-364. 目录操作 改变路径 使用chdir即可改变路径：\n1 chdir \"../\";\t#到上一层路径 文件名通配符 像Bash一样，可以使用*来通配文件：\n1 2 3 4 5 6 #先写下如下程序files.pl： foreach $filename (@ARGV){ print $filename; } #然后执行: ./files.pl *.cpp 执行之后会打印出目录下的所有cpp文件。也就是说bash会帮助你展开通配符。\n在Perl程序中也可以使用通配符，使用glob函数即可：\n1 2 glob \"*.cpp\";\t#会得到当前目录中所有的cpp文件 glob \"*.cpp *.pl\";\t#匹配多个 glob的作用和Bash完全一样，所以不会列出开头为.的文件。\n文件和目录的操作 这里列举一些常用的操作：\n删除文件unlink：使用unlink删除，参数可以是以逗号分隔的文件名，或者直接是列表。返回删除成功的文件数目。\n重命名文件rename:第一个参数是原文件名，第二个参数是新文件名\n创建和删除目录mkdir/rmdir\n修改权限chmod\n修改隶属关系chown\n修改时间戳utime\n这些函数的用法可以在perldoc中找到。\n进程，管道和信号 perl也可以操作进程，而且其API函数和Unix的API几乎一致，很容易上手。\n进程 进程创建 和Unix一样，使用fork函数创建。\nfork函数会返回值，如果返回的是0，代表现在所在的进程是子进程（用fork创建的进程），而如果是大于0的，代表是刚刚创建的子进程的ID，也就是说现在仍然处于父进程：\n1 2 3 4 5 6 $pid = fork; if($pid==0){ print(\"我现在是子进程哦\"); }else{ print(\"我还是父进程，我的pid是${$}，我的儿子是${pid}\"); } 发生错误返回undef。\n$$变量里面存储着当前进程的pid，这个变量时只读不可写的。\n你也可以用getgpid([$pid])来得到指定进程的进程组id，如果没有参数，返回当前进程的进程组id。\n进程运行程序 当你使用fork之后，子进程和父进程还是使用一样的资源和代码。只有当你改变了子进程的代码或者改变了子进程的资源之后，子进程才会在内存中开辟一片内存。这种技术叫做写时复制（copy on write）。\n然而，和父进程运行一样的代码有什么意思呢？所以我们在创建子进程之后基本上立刻就要使用exec()函数来给子进程新的代码执行。exec的功能是以新的命令替换当前进程。所以exec从不返回，因为替换之后原来的代码已经没了：\n1 2 3 if(fork()==0){ exec(\"cat\", \"test.txt\");\t#相当于这个进程现在要执行cat程序，并且cat程序的参数是test.txt } 所以现在有两种情况让子进程运行和父进程不一样的代码：\n使用if语句判断fork的返回值，如果返回值为0代表是子进程，执行子进程专有代码 使用exec替换子进程原本的程序。 管道 就是Unix下的管道，可以通过Perl来打开。\n使用open打开管道 使用open可以打开管道：\n1 2 open FHANDL, \"|filename\";\t#打开写管道 open FHANDL, \"filename|\";\t#打开读管道 在文件名前面加|表示打开读管道，在后面加|表示打开写管道。\n但是你不能同时打开读写管道：open FHANDL, \"|filename|\"是错误的。\n直接管道 可以像Bash命令一样直接使用\\``来打开管道：\n1 $context = `ls`; 这样context变量会得到ls命令的输出结果。\npipe函数 这个是Unix下的标准打开管道的函数：\n1 $error = pipe RHANDLE, WHANDL; 其两个参数都是返回值参数，第一个参数为打开了的写管道，第二个参数为打开了的读管道。\n一般来说管道是让两个程序通信的东西，所以在同一个程序里面打开管道没什么意义，除非你用的多进程程序。如果想要两个进程之间通过管道通信，一般是创建管道后一个进程关闭读/写管道，另一个进程关闭写/读管道，这样让一个进程向另一个进程传输数据。\n虽然pipe返回两个管道，但是你不能保留两个管道同时进行读写操作。如果想要既读数据又写数据，必须再开一个管道，然后关闭其中的读/写管道。\n管道的判断 使用-p来判断一个句柄是不是管道，用-S判断是不是一个套接字，用-t判断文件句柄是不是又终端打开。\n信号 信号种类 信号是Unix系统传输给程序的信息。比如你每次程序死循环的时候，你会按下Ctrl-C来强制关闭程序对吧，这个时候其实是Unix发送了INT信号给程序，INT信号的默认操作是关闭程序，所以程序会被关闭。\n但是你也可以自己使用代码接受信号，然后自定义处理信号的方法。POSIX定义了19个信号：INT,QUIT,HUP,KILL,ILL,SEGV,PIPE,ALRM,CHLD,STOP,TTIN,TTOU,TSTP,USR2,USR1,FPE,ABRT,COUNT,TERM.其中最常用的是：\nINT：来自键盘的中断，默认终止程序 KILL，STOP：来自系统的中断，终止程序，不可捕获 CHLD：子进程终止 HUP：挂起 PIPE：写往没有读取者的管道 ALRM：来自闹钟的定时信号 其中KILL和STOP是不能够被捕获的，其一旦发出，程序必定被停止。\nHUP用于挂起程序，其实很常用：在你用命令行转一个程序的时候，关闭了命令行之后程序并没有死亡，而是被挂起了（其实我以前一直以为是死亡了。。。）。\nCHLD则是在程序的子进程终止的时候，其父进程会接收到这个信号。这个信号一般用来帮助我们解决僵死进程。\nALRM则是在使用alarm($second)函数下，经过second描述之后程序会接收到的信号。\n截取信号 你可以在%SIG哈希中注册信号函数来截取信号：\n1 2 3 %SIG{INT} = sub{ print \"你按下了CTRL-C\"; }; 这里截取INT信号，所以你在按下CTRL-C的时候不会终止程序，而是输出一行信息。\n发送信号 使用kill()函数发送信号：\n1 $count = kill($signal, @processes) 第一个参数是要发送的信号，以字符串表示，如'INT'。第二个参数是一组pid，表示你要发送信号的对象。返回能够被发送信号的进程数量。\n使用信号处理程序的建议 由于信号可能在程序的任何时候到达，而一旦到达程序就会执行对应的信号处理程序。所以你的信号处理程序最好不要改动内存啊，做IO操作等花里胡哨操作，这样可能和程序原本代码冲突。最安全的方法是设置一个全局变量的状态，然后在主代码中检查这个状态来判断下一步做什么。\n","description":"","tags":["perl"],"title":"Perl快速入门","uri":"/posts/perl%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"通过学习《x86汇编语言-从实模式到保护模式》一书，我终于明白了操作系统是如何安装的，以及自己写了一个小小的，算不上安装程序的helloworld啦。\n操作系统是如何安装的 这里只说如何从磁盘安装（其他的我也不知道啊）。是这样：intel CPU会先读取磁盘的第一个扇区，这个扇区被称为主引导扇区。ROM-BIOS会将其加载到0x0000:0x7C00的地方，然后判断是否有效（判断的方式是看扇区最后的两个字节是不是0x55和0xaa）。如果有效，那么就会跳到0x000:0x7C00去执行代码啦。\n也就是说，我们只要将安装程序放在磁盘的第一扇区，并且在最后加上0x55,0xaa就可以让BIOS在启动的时候执行我们安装程序的代码啦。这也就是操作系统通过磁盘安装的底层过程。\nHelloWorld 我自己按照书上编写了一个可以在屏幕上输出的HelloWorld程序：\nmov ax, 0xB800 mov es, ax mov byte [es:0x00], 'H' mov byte [es:0x01], 0x07 mov byte [es:0x02], 'e' mov byte [es:0x03], 0x07 mov byte [es:0x04], 'l' mov byte [es:0x05], 0x07 mov byte [es:0x06], 'l' mov byte [es:0x07], 0x07 mov byte [es:0x08], 'o' mov byte [es:0x09], 0x07 mov byte [es:0x0A], ' ' mov byte [es:0x0B], 0x07 mov byte [es:0x0C], 'W' mov byte [es:0x0D], 0x07 mov byte [es:0x0E], 'o' mov byte [es:0x0F], 0x07 mov byte [es:0x10], 'r' mov byte [es:0x11], 0x07 mov byte [es:0x12], 'l' mov byte [es:0x13], 0x07 mov byte [es:0x14], 'd' mov byte [es:0x15], 0x07 infi jmp near infi current equ 510-$ times current db 0 db 0x55, 0xaa 由于0xB800处是显存，所以我们只要将字符写入显存就可以在屏幕上显示字符了。这里我写入了hello world。然后使用一个无限循环来循环我们的程序，防止CPU无尽地向下执行。最后使用0填充了到磁盘末尾的所有空闲空间，然后db 0x55, 0xaa来放入055，0xaa。\n程序是使用nasm编写的，编译的话只要:\n1 nasm helloworld.asm -f bin -o helloworld.bin 即可。\n然后就是按照书上的方法，将bin文件刷到虚拟机的虚拟硬盘里面了。我自己写了一个刷固定VHD文件的小工具来方便我在Mac和Linux下刷（Windows也可以用）。刷进去之后放在虚拟机里面就可以转出来啦：\n","description":"","tags":null,"title":"操作系统安装的底层知识","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E7%9A%84%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"在学习《x86汇编语言-从实模式到保护模式》一书的时候，由于书上需要将编译后的代码写入到虚拟硬盘VHD文件中，而作者给出的又是Windows的写入程序，所以在这里我自己写了一个在Windows，Linux，Mac上都可以使用的，纯C++11的命令行工具。工具在github上。这里分享一下编写时出现的坑和编写过程。\n注：这个工具只能将数据写入固定VHD文件中\n固定VHD文件格式 既然要写文件，当然要先知道文件的格式了。这里我踩了第一个坑：在知网上找到一篇《VHD文件结构解析》，很可惜这个文章里面有错的。真正正确的格式请看百度百科。\n这里还是简单说一下固定VHD文件的格式：\nVHD是模拟磁盘的，所以其是通过一个扇区一个扇区划分的，每个扇区固定占512字节。最左边是0号扇区，号码向右递增。\nVHD和其他文件不同，将其信息放在尾部，也就是最后一个扇区中。所以我们应当首先读取最后一个扇区的内容。而百度百科上说的也就是这个VHD尾部各种字段的大小和意义啦。\n通过百度百科我们可以编写一下的结构体：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct _FixedVHD_Field_Creator{ uint8_t author[5]; /**\u003c 创建者, 4字节 */ uint16_t version[2]; /**\u003c 应用版本, 4字节 */ uint8_t system[5]; /**\u003c 应用系统, 4字节 */ };//12字节 struct FixedVHD_Head{ uint8_t identification[9]; /**\u003c 开头的标识,8字节 */ uint32_t feature; /**\u003c 特性,4字节 */ uint16_t version[2]; /**\u003c 版本,4字节 */ uint64_t offset; /**\u003c 数据偏移 8字节 */ uint32_t timestamp; /**\u003c 时间戳 4字节 */ _FixedVHD_Field_Creator creator; /**\u003c 创建者字段 12字节 */ uint64_t init_len; /**\u003c 初始长度，创建时的初始大小 8字节 */ uint64_t fixed_len; /**\u003c 即时长度，VHD的长度 8字节 */ uint32_t geomentry; /**\u003c 记录了C/H/S（磁道，磁头，扇区）信息 4字节 */ uint32_t type; /**\u003c 类型 4字节 */ uint32_t crc; /**\u003c 校验和 4字节 */ uint8_t uuid[16]; /**\u003c 通用唯一识别码 16字节 */ uint8_t saved; /**\u003c 是否在保存状态 1字节 */ uint8_t hidden; /**\u003c VDI是否隐藏 1字节 */ //uint8_t reserv[427]; /**\u003c 保留字段，全部为0 426字节 */ }; 这里由于最后的426字节都是空，对我们来说没有任何意义，所以就不去读取了。\n那么接下来就是逐个读取结构了。这里的第二个坑是VHD是采用大段存储的，但是C++是采用小端存储的，所以你在读取的时候得把字节反过来，而表示字符串的字节又不能反过来。所以我写了一些辅助函数来进行读取：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void ReadByte(ifstream\u0026 f, uint8_t\u0026 byte){ f.read((char*)\u0026byte, 1); } void ReadWord(ifstream\u0026 f, uint16_t\u0026 word){ unsigned char tmp[2]; f.read((char*)\u0026tmp[1], 1); f.read((char*)\u0026tmp[0], 1); memcpy(\u0026word, tmp, 2); } void ReadDoubleWord(ifstream\u0026 f, uint32_t\u0026 doubleword){ unsigned char tmp[4]; for(int i=3;i\u003e=0;i--) f.read((char*)\u0026tmp[i], 1); memcpy(\u0026doubleword, tmp, 4); } void ReadQuad(ifstream\u0026 f, uint64_t\u0026 quad){ unsigned char tmp[8]; for(int i=7;i\u003e=0;i--) f.read((char*)\u0026tmp[i], 1); memcpy(\u0026quad, tmp, 8); } void ReadString(ifstream\u0026 f, uint8_t* str, int len){ f.read((char*)str, len); str[len] = '\\0'; //自动在末尾加\\0防止输出乱码 } 然后就可以读写了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 void Open(string filename){ ifstream file(filename); this-\u003efilepath = filename; char byte[4]; char word[8]; if(file.fail()) failed = true; else failed = false; file.seekg(-512, ios::end); ReadString(file, head.identification, 8); ReadDoubleWord(file, head.feature); uint8_t tmp4[4]; for(int i=3;i\u003e=0;i--) file.read((char*)\u0026tmp4[i], 1); memcpy(\u0026head.version[0], tmp4, 2); memcpy(\u0026head.version[1], \u0026tmp4[2], 2); ReadQuad(file, head.offset); ReadDoubleWord(file, head.timestamp); ReadString(file, head.creator.author, 4); for(int i=3;i\u003e=0;i--) file.read((char*)\u0026tmp4[i], 1); memcpy(\u0026head.creator.version[0], tmp4, 2); memcpy(\u0026head.creator.version[1], \u0026tmp4[2], 2); ReadString(file, head.creator.system, 4); ReadQuad(file, head.init_len); ReadQuad(file, head.fixed_len); ReadDoubleWord(file, head.geomentry); ReadDoubleWord(file, head.type); ReadDoubleWord(file, head.crc); uint8_t tmp16[16]; for(int i=15;i\u003e=0;i--) file.read((char*)\u0026tmp16[i], 1); memcpy(head.uuid, tmp16, 16); ReadByte(file, head.saved); ReadByte(file, head.hidden); file.seekg(0, ios::end); //这里顺便得到了文件的大小 totlesize = file.tellg(); contentsize = totlesize - 512; file.close(); } 这里就有人会问了：哎我只要把结构体声明好了，每一部分对应VHD结构中的每个字段，然后直接file.read((char*)\u0026head, 512)不就行了，你干嘛要每个字段都手动读取，多累啊。 这样看上去可行但是实际上是不可行的。因为结构体的定义会遵守内存对齐，导致其最终大小比看上去的要大。所以我们不能直接read 512字节。\n写入固定VHD文件把 接下来就是写入固定VHD文件了。VHD文件规定读写需要针对磁道，也就是说你每次读写必须要在某个磁道的开头处，然后读取n个磁道（也就是n*512字节）。如果你的数据不够512的倍数VHD是不管的。所以我们在写入的时候需要将数据凑到512字节的倍数，多的补0:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 bool Write(unsigned int start, void* data, int size, int contentsize){ //看看是不是试图写到超出文件外的部分 if((size+start)*SECTION_SIZE\u003econtentsize){ cerr\u003c\u003c\"Beyond the scope of VHD\"\u003c\u003cendl; return false; } if(size\u003c0){ cerr\u003c\u003c\"size most big than 0\"\u003c\u003cendl; return false; } if(size==0) return false; //输出提示xin x cout\u003c\u003c\"write \"\u003c\u003csize\u003c\u003c\" at \"\u003c\u003cstart\u003c\u003cendl; //这里也是一个坑，放在《C++小知识点，注意点》文章里面了。 fstream file(filepath, ios::binary|ios::out|ios::in); file.seekp(start*SECTION_SIZE, ios::beg); char* buffer = nullptr; unsigned int final_size; //这里将大小凑齐512的倍数 if(size%SECTION_SIZE!=0) final_size = (size/SECTION_SIZE+1)*SECTION_SIZE; else final_size = size; cout\u003c\u003c\"final size:\"\u003c\u003cfinal_size\u003c\u003cendl; buffer = new char[final_size]; memset(buffer, 0, final_size); memcpy(buffer, data, size); file.write(buffer, final_size); file.close(); delete buffer; return true; } 这样我们就可以写入了。\n整个程序我最后编写成了类，源代码放在github上了，需要的拿下来编译就可以了。\n使用dd命令读取和写入 你也可以使用dd命令读取和写入vhd文件，比如将main.bin文件写入到test.vhd文件的第一个扇区中：\n1 dd -if=main.bin -of=main.bin bs=512 count=1 conv=notrunc -if指令代表要写入的文件，-of指令代表要写入的文件，bs代表依次写入多少字节，这里是一个扇区512字节，count代表写入多少个bs，这里是一个。最后的conv=notrunc代表不截断文件。如果你的VHD文件是虚拟VHD，那么根据其文件格式，文件尾会附加VHD的信息。使用notrunc可以不覆盖这个信息。\n","description":"","tags":null,"title":"用C++读取固定VHD文件","uri":"/posts/%E7%94%A8c++%E8%AF%BB%E5%8F%96%E5%9B%BA%E5%AE%9Avhd%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"关于脚本 对于游戏脚本有两种解释，一般的解释是“外挂”，也就是自动刷怪等等的那种挂。一种是让脚本和游戏主体沟通，将逻辑单独拎出来的编程技术。我们这里说的不是外挂，说的是如何使用Lua语言做脚本，并且辅助我们自己的游戏主体的编程手段。\n预备知识 这个例子使用C++和SDL2制作游戏的主体，Lua作为游戏的脚本。另外需要知道Lua和C/C++互相通信的方法，见这篇博客\n注意事项 这个例子是在MacOS系统下编写的。由于用到了动态链接库的创建，如果你是Windows系统的话，需要修改动态链接库部分的代码和编译过程。\n例子的目标 我们的例子很简单，场上有两个方块，红色的是敌人，绿色的是玩家，玩家要保持移动不让敌人追上即可。如果追上了就会弹出游戏结束的对话框，并且关闭游戏：\n让我们开始吧！ 首先让我们把主体的代码框架搭出来，下面的main.cpp可以创建一个800x800大小的窗体：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 //main.cpp #include \u003cstring\u003e #include \u003cSDL2/SDL.h\u003e #include \u003ciostream\u003e using namespace std; SDL_Window* window = nullptr; SDL_Renderer* render = nullptr; int main(int argc, char** argv){ SDL_Init(SDL_INIT_EVERYTHING); window = SDL_CreateWindow(\"lua script\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 800, 800, SDL_WINDOW_SHOWN); render = SDL_CreateRenderer(window, -1, 0); SDL_Event event; bool isquit = false; //flag1 while(!isquit){ SDL_SetRenderDrawColor(render, 100, 100, 100, 255); SDL_RenderClear(render); while(SDL_PollEvent(\u0026event)){ switch(event.type){ case SDL_QUIT: isquit = true; break; } //flag2 } //flag3 SDL_RenderPresent(render); SDL_Delay(30); } SDL_Quit(); return 0; } 这里的几个flag是我们后面要添加代码的地方。\n接下来我们要编写关于人物的类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 //role.hpp #ifndef __ROLE_HPP__ #define __ROLE_HPP__ #include \u003cSDL2/SDL.h\u003e #include \u003clua.hpp\u003e //导入lua文件 #include \u003ciostream\u003e #include \u003cstring\u003e #define WIDTH 50 //方块的宽度 #define HEIGHT 50 //方块的高度 using namespace std; //敌人和玩家的基类 class Role{ public: Role(int nx, int ny); //初始化和Lua交互的lua_State栈 virtual void initLua(string luafile, SDL_Renderer* render); //绘制 virtual void draw(SDL_Renderer* render); //获得X和Y坐标 int getX(); int getY(); //析构函数，我们要在这里关闭lua栈 ~Role(); protected: int x; int y; SDL_Color color; int speed; lua_State* S; }; class Player:public Role{ public: Player(int nx, int ny); //玩家需要接受按键控制，这个是处理按键的函数 void dealEvent(SDL_Event\u0026 event); }; class Enemy:public Role{ public: Enemy(int nx, int ny); //这个函数让敌人跟踪玩家 void follow(Role\u0026 role); }; #endif 接下来是实现这些类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 #include \"role.hpp\" Role::Role(int nx, int ny):x(nx), y(ny){ speed = 5; S = nullptr; } int Role::getX(){ return x; } int Role::getY(){ return y; } Role::~Role(){ lua_close(S); } void Role::initLua(string luafile, SDL_Renderer* render){ //首先创建栈并且打开Lua标准库 S = luaL_newstate(); luaL_openlibs(S); //加载Lua脚本文件 int error = luaL_loadfile(S, luafile.c_str()); //判断脚本是否有效 if(error != LUA_OK){ cerr\u003c\u003cluafile\u003c\u003c\" not found\"\u003c\u003cendl; lua_close(S); return; } //调用一下初始化函数来初始化Lua栈 lua_pcall(S, 0, 0, 0); //我们的库名称叫做extlib，这里获得库 error = lua_getglobal(S, \"extlib\"); if(error == LUA_TNIL){ cerr\u003c\u003c\"init render in lua failed\"\u003c\u003cendl; return ; } //将我们用于绘图的渲染器放到extlib.render变量中 lua_pushlightuserdata(S, (void*)render); lua_setfield(S, -2, \"render\"); //将栈清空 lua_settop(S, 1); } void Role::draw(SDL_Renderer* render){ //找到脚本中的draw函数 int error = lua_getglobal(S, \"draw\"); if(error == LUA_TNIL){ cerr\u003c\u003c\"not found draw() function\"\u003c\u003cendl; return ; } //将参数压入栈 lua_pushinteger(S, x); lua_pushinteger(S, y); lua_pushinteger(S, WIDTH); lua_pushinteger(S, HEIGHT); lua_pushinteger(S, color.r); lua_pushinteger(S, color.g); lua_pushinteger(S, color.b); //调用draw函数 lua_pcall(S, 7, 0, 0); //清空栈 lua_settop(S, 1); } Player::Player(int nx, int ny):Role(nx, ny){ color.r = 0; color.g = 255; color.b = 0; color.a = 255; speed = 10; } void Player::dealEvent(SDL_Event\u0026 event){ if(event.type == SDL_KEYDOWN) switch(event.key.keysym.sym){ case SDLK_a: x -= speed; break; case SDLK_d: x += speed; break; case SDLK_w: y -= speed; break; case SDLK_s: y += speed; break; } } Enemy::Enemy(int nx, int ny):Role(nx, ny){ color.r = 255; color.g = 0; color.b = 0; color.a = 255; speed = 2; } void Enemy::follow(Role\u0026 role){ int dx = role.getX(); int dy = role.getY(); //找到脚本中的follow函数 int error = lua_getglobal(S, \"follow\"); if(error == LUA_TNIL){ cerr\u003c\u003c\"follow function not in lua file\"\u003c\u003cendl; return; } //将参数压入栈 lua_pushinteger(S, x); lua_pushinteger(S, y); lua_pushinteger(S, dx); lua_pushinteger(S, dy); lua_pushinteger(S, speed); //调用follow函数 lua_pcall(S, 5, 2, 0); //获得follow函数的返回值，并更新敌人的坐标 x = lua_tonumber(S, -2); y = lua_tonumber(S, -1); //清空栈 lua_settop(S, 1); } 其实调用脚本的方法很简单，就是先找到对应函数，将参数压入栈之后调用这个函数，然后再获得函数的返回值即可（如果有的话）。最后不要忘记将栈清空（如果函数没有返回值的话就不用清空，因为lua_pcall会将函数的参数和函数一起弹出栈，如果有返回值的话就要清空，因为lua栈最大只能容纳20个元素（不同机器不一样，但是都不是很大），如果返回值一直驻留在栈里面，会导致后期参数无法入栈）。\n接下来我们需要为Lua脚本编写相应的接口，让脚本文件可以调用一些绘图函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 //extlib.cpp #include \u003clua.hpp\u003e #include \u003cSDL2/SDL.h\u003e #include \u003cSDL2/SDL_image.h\u003e #include \u003ciostream\u003e using namespace std; /** * @brief 在屏幕上绘制矩形 * * Lua的参数： * SDL_Renderer渲染器, x, y, w, h, r, g, b * * warning: * 我们假设所有的绘制函数里面都有渲染器render */ extern \"C\" int drawRect(lua_State* L){ //函数的第一个参数是渲染器，取出来 SDL_Renderer* render = (SDL_Renderer*)lua_touserdata(L, 1); //取出其他的参数 const int x = lua_tointeger(L, 2), y = lua_tointeger(L, 3), w = lua_tointeger(L, 4), h = lua_tointeger(L, 5), r = lua_tointeger(L, 6), g = lua_tointeger(L, 7), b = lua_tointeger(L, 8); //绘制矩形 SDL_Rect rect = {x, y, w, h}; SDL_SetRenderDrawColor(render, r, g, b, 255); SDL_RenderDrawRect(render, \u0026rect); return 1; } //绘制实心矩形 //Lua的参数 // SDL_Renderer渲染器, x, y, w, h, r, g, b extern \"C\" int drawFillRect(lua_State* L){ SDL_Renderer* render = (SDL_Renderer*)lua_touserdata(L, 1); const int x = lua_tointeger(L, 2), y = lua_tointeger(L, 3), w = lua_tointeger(L, 4), h = lua_tointeger(L, 5), r = lua_tointeger(L, 6), g = lua_tointeger(L, 7), b = lua_tointeger(L, 8); SDL_Rect rect = {x, y, w, h}; SDL_SetRenderDrawColor(render, r, g, b, 255); SDL_RenderFillRect(render, \u0026rect); return 1; } //注册函数到函数表 const struct luaL_Reg l[]={ {\"drawRect\", drawRect}, {\"drawFillRect\", drawFillRect}, {NULL, NULL} }; extern \"C\" int luaopen_extlib(lua_State* L){ //设置库的名称 const char* libName = \"extlib\"; luaL_newlib(L, l); lua_setglobal(L, libName); return 1; } 这样的话接口就定义好了。 我们需要将接口编译成动态链接库供脚本使用： g++ extlib.cpp -fPIC -shared -o extlib.so ${LUA_CONFIG} ${SDL_CONFIG} -std=c++11\n然后我们就可以编写脚本了：\n1 2 3 4 5 6 --player.lua require(\"extlib\") function draw(x, y, w, h, r, g, b) extlib.drawRect(extlib.render, x, y, w, h, r, g, b); end 这里玩家的脚本，里面只有一个绘制函数。我们调用了extlib.drawRect函数来实现绘制。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 --enemy.lua require(\"extlib\") require(\"math\") --辅助函数，用于获得向量的大小 function getlen(x, y) return math.sqrt(x*x+y*y) end --绘制函数 function draw(x, y, w, h, r, g, b) extlib.drawFillRect(extlib.render, x, y, w, h, r, g, b) end --跟随玩家的函数。返回更新后的坐标 function follow(mx, my, dx, dy, speed) deltax = dx-mx deltay = dy-my len = getlen(deltax, deltay) vec = {x=deltax/len, y=deltay/len} return mx+vec.x*speed, my+vec.y*speed end 这样整个脚本和人物都做好了。接下来我们将这些东西整合到main函数中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 //使用Lua作为绘图脚本的一个小例子，绘图引擎是SDL2 #include \u003clua.hpp\u003e #include \u003cstring\u003e #include \u003cSDL2/SDL.h\u003e #include \u003ciostream\u003e //导入头文件 #include \"role.hpp\" using namespace std; SDL_Window* window = nullptr; SDL_Renderer* render = nullptr; //声明的碰撞检函数 bool Collision(Player\u0026 p, Enemy\u0026 e){ SDL_Rect rect = {p.getX(), p.getY(), WIDTH, HEIGHT}; SDL_Point point1 = {e.getX(), e.getY()}, point2 = {e.getX()+WIDTH, e.getY()}, point3 = {e.getX()+WIDTH, e.getY()+HEIGHT}, point4 = {e.getX(), e.getY()+HEIGHT}; return SDL_PointInRect(\u0026point1, \u0026rect) || SDL_PointInRect(\u0026point2, \u0026rect) || SDL_PointInRect(\u0026point3, \u0026rect) || SDL_PointInRect(\u0026point4, \u0026rect); } int main(int argc, char** argv){ SDL_Init(SDL_INIT_EVERYTHING); window = SDL_CreateWindow(\"lua script\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 800, 800, SDL_WINDOW_SHOWN); render = SDL_CreateRenderer(window, -1, 0); SDL_Event event; bool isquit = false; //flag1 创建敌人和玩家对象，并且读入相应的脚本文件 Enemy enemy(400, 400); enemy.initLua(\"enemy.lua\", render); Player player(200, 200); player.initLua(\"player.lua\", render); while(!isquit){ SDL_SetRenderDrawColor(render, 100, 100, 100, 255); SDL_RenderClear(render); while(SDL_PollEvent(\u0026event)){ switch(event.type){ case SDL_QUIT: isquit = true; break; } //flag2 玩家的按键监控 player.dealEvent(event); } //flag3 敌人的行动策略，以及绘制敌人和玩家 enemy.follow(player); player.draw(render); enemy.draw(render); //碰撞检测 if(Collision(player, enemy)){ SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_INFORMATION, \"GamOver\", \"你被追上了\", nullptr); isquit = true; } SDL_RenderPresent(render); SDL_Delay(30); } SDL_Quit(); return 0; } 这样，整个例子就写完了。\n总结 其实使用lua作为脚本语言很简单，只需要定义好给Lua的接口，然后在文件里调用脚本中相关的函数即可。\n","description":"","tags":null,"title":"利用Lua做游戏脚本","uri":"/posts/%E5%88%A9%E7%94%A8lua%E5%B5%8C%E5%85%A5%E5%BC%95%E6%93%8E%E5%81%9A%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC/"},{"categories":null,"content":"这几天在看Martin的《代码整洁之道》，感觉说的真的很好啊。其中最重要的思想和重构有一些相似：代码不止是给机器看的，更是给人看的。良好的编码风格可以帮助你更快速地找到Bug以及更新代码。\n这里总结出每一章的要点，以便后期回顾。\n有意义的命名 在“有意义的命名”这一章里，Martin强调**命名需要有意义，让人一目了然，见名知义。**其实这个思想在《重构》里面也体现了不少了。一般来说，对于用在循环中的临时变量你可以使用没有意义的名称i,j等，在其他的时候基本上变量和函数等名称都需要有意义。其实我在有些时候对循环中的临时变量也会给出有意义的名称，比如在编写矩阵运算的时候：\n1 2 3 4 5 for(int row=0;row\u003cm.row();row++){ for(int col=0;col\u003cm.row();col++){ ... } } 可能有人的英文不是很好，对命名很头疼。那么这里推荐你一个自动生产名称的网站，他会帮助你生成名称。\nMartin还建议不要害怕长的变量名，越长的变量名越能告诉人们变量的作用（当然不要特别特别长）。名称的长短应该按其作用域决定，作用域长的名称长。\nMartin不建议使用编码，像是匈牙利标记法（其实我以前也用的这个），因为那时候编译器是不做类型检查的，所以需要匈牙利标记法来帮助程序员快速知道变量类型。但是现在的IDE，你把鼠标放上去，直接把整个变量声明给你显示出来。所以不再需要这些特有的命名方法了。也不要用成员前缀（像是表示成员变量的m_,表示接口的I和类的C），道理一样。\n不要在命名的时候使用废话或者令人迷惑的命名，这样可能会误导别人。尤其是使用一些专有的，业界常见的词的时候。比如accountList就会让人觉得这个变量是一个List类型。你可以改成accountBunch或者accountGroup。\n函数 简单来说就一句话：函数就要短小精悍。Martin十分不推荐特别长的函数，因为读起来会很头疼（的确是）。我们应该使用重构的方法将函数变成一小块一小块的，然后给每一块函数一个有意义的名字。一个函数最好在20行左右。\n而且函数需要符合单一职责原则，一个函数只做一个事情。处理底层的代码和抽象层的代码不应该在一个函数中同时出现。\n判断函数是否已经够小的方法是看这个函数内的代码在不在同一抽象层级上。也就是说一个函数要不就都调用接口，要不就都实现底层，不要混着用。\n接下来又是switch躺枪的时间。你只要用了switch，函数代码肯定会增多。Martin的方法是将switch中的每个case返回工厂产出的对象。但是在C++中这或许不是一个好办法。尽管如此，我们仍然可以将switch单独提出到一个函数中来减少其他函数的负担。\n函数的参数也不要过长，一般来说两个就够了，三个都比较长了。如果函数参数很长的话，建议将参数打包（虽然是这么说，但是我看很多C/C++库的参数都很长啊😂）。不过将表示相同东西的参数打包成一个结构体还是很舒服的。比如我在编写OpenGL的时候需要一个自动绘制几何图形的类：\n1 GL_GeoMesh(GeoType type, GLfloat* vertices, unsigned int num, string imagepath, GLenum wrap_s, GLenum wrap_t, GLenum format, GLenum innerformat, arma::fvec pos, arma::fvec nangle) 这个参数的确长的过分啊。所以我就将一些用于创建贴图的参数集成到一起，将一些表示集合图形信息的参数集成到一起：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct TexInfo{ string path; GLint wrap_s_type; GLint wrap_t_type; GLint format; GLint internalformat; }; struct GeoMeshInfo{ GeoType type; GLfloat* vertices; unsigned int num; arma::fvec pos; arma::fvec nangle; }; GL_GeoMesh(GeoMeshInfo meshinfo, TexInfo textureinfo); 这样就将参数缩小到两个了，看上去好多了，而且也很清晰。\n对于参数，Martin还建议不要传入Bool量，因为布尔量总是表示“在true的时候做一件事，在False的时候做另一件事”，容易让编写者违反单一职责原则。所以像show(bool isshow)这种函数就要拆分成showWindow(), hideWindow()两个函数。\n还有就是对函数命名的规则，使用动词，最好是动词和名词的方式，比如writeFiled()就比write()好，表示对字段写入。我觉得，如果你的函数是成员函数，在没有使用到内部变量的时候或者不想让，没必要暴露出内部对象类型的情况下，可以直接使用动词，比如file.close()，而如果你是编写面向过程的函数的话，最好将类型列出来，比如InitLinklist(), InitBinaryTree()等。\n最后函数需要无副作用，也就是说，你的函数在做这件事的时候不要做多余的事情。比如我编写OpenGL代码中，绘制几何体类中这样的代码：\n1 2 3 4 5 6 7 8 9 10 11 void Draw(GL_Program* program){ arma::fmat model = getTranslate(position[0], position[1], position[2])*getRotateXYZ(angle[0]+180, angle[1], angle[2]); program-\u003euniformMatrix4fv(\"model\", model.memptr()); glBindVertexArray(VAO); GLenum texturetype = GL_TEXTURE_2D; glBindTexture(texturetype, Texture); glDrawArrays(drawtype, 0, vertex_num); glBindVertexArray(0); glBindTexture(texturetype, 0); program-\u003euseProgram(); } 这里倒数第二行就额外使用了着色器。其实使用着色器不是这个函数要做的事情，这个在这里就是副作用了，到时第二行代码应当删去。\n而且也不要将参数当作返回值输出（其实我在很多很多的面向过程的代码中经常看到这种情况），容易误导别人，而且也不好记忆。的确是这样。我在看Linux编程的时候，里面的函数有时候是要传入参数，有时候参数是当作返回值的。如果是错误标志error还好认一些，但是有些参数实在是不记得，每次都要查询API文档。\n注释 有关注释的要点就是：没有注释的注释就是好注释。除非万不得已，否则别写注释。 我们要争取让程序自己描述自己（比如良好的命名，易懂的代码体），而不需要过度的注释来修饰程序。因为注释存在以下的缺点：\n很容易被人忘记维护。我们常常不定期维护代码，但是注释的话可能就不是很重视了。但是没有维护的代码就是过期的注释，可能会给人误导（注释的内容和现状不符） 注释不能美化代码。注释是为了让人们更好地阅读代码。但是如果你代码本身很糟的话，再多的注释都拯救不了你（而且你维护的注释也多了起来）。尝试让自己的代码自描述。 Martin也提倡一些注释：\nDoc文档注释，像是JavaDoc或Doxygen。这些注释在编写API接口的时候还是很有必要注上去的。但是不要对每个函数写Doc文档，那样你维护的注释会特别多。像那种小的，一看就知道怎么用的函数就不用写注释了（比如getX(), getPosition()） TODO注释。这种注释可以告诉你还有什么工作没做，防止你忘记。大多数IDE都可以自动识别并列出TODO（比如vscode的TODOList插件），便于你的定位。当然，事情做完之后一定要删除注释。（我就常常在代码中留下TODO注释，方便下次接着写，不得不说TODO是个好东西，记录了之后忘记的东西少多了） 法律信息。这个不用多说，你基本上随便找一个库的源代码，他们源文件开头基本上都有法律信息。比如SDL2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Simple DirectMedia Layer Copyright (C) 1997-2018 Sam Lantinga \u003cslouken@libsdl.org\u003e This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software. Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions: 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required. 2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software. 3. This notice may not be removed or altered from any source distribution. */ 提供信息的注释。这种注释会提供一些信息，像是返回值是什么之类的。但是仍然建议让代码自己描述自己。 对意图的解释。有时候你的代码中可能用了什么较为复杂，生僻的算法，或者一些“黑科技（短小但是能表示复杂逻辑的代码）”，你可以为这些代码写一些注释来阐述。或者当你在if语句中给了一堆花里胡哨的逻辑判断之后，你也可以注释（但是更好的做法是重构这个代码，用有意义的变量来代替判断中较小的表达式） 警示。当你的代码有某些缺陷，或者你想要告诉其他人一些警示的时候，你可以写一些注释。 下面是坏注释的典型代表：\n喃喃自语：自己说给自己听的注释。 误导性注释：不要在注释里面写和显示不符，误导性的话语 日志式注释：现在都有git这种版本管理器了，你还在注释里面写日志干啥！ 废话注释：比如/*这是一个默认构造函数*/这种。 括号后面的注释：不知道你有没有看过这种注释： 1 2 3 4 5 6 7 8 9 return new Scaffold ( appBar: new AppBar( title: new Text('Startup Name Generator'), actions: \u003cWidget\u003e[ new IconButton(icon: new Icon(Icons.list), onPressed: _pushSaved) ], //Widget[] ), //AppBar body: _buildSuggestions(), );//ScaffFold 没错这就是Flutter的代码。要不是这些括号后面的注释是vscode给我自动生成，不计入总代码的提示代码，我TM再多写几个嵌套得疯！说真话，这种一层套一层，俄罗斯套套套套娃的代码，就应该重构！（什么？你说我怎么不给这个代码重构？这是我学习Flutter写的测试代码，重构个头）\n归属和署名：就是这种author VisualGMQ这种啦。放心，git会记得是谁写的，到时候一blame你也跑不掉。 注释掉的代码：这种是最占空间，遗留时间最长的代码。你说这注释的代码没用把，诶没准是重要代码，到时候要还原回去的。你说有用吧，诶他可能就没用。所以在你准备停止休工的时候，至少在git push上去的时候，把所有没用的注释代码删了，将所有的有用的注释代码上写上为什么留下来的理由，以便于下次回忆起来。 HTML注释：我是不是很懂在注释里面写HTML是干啥。除非你是为了Doxygen或者JavaDoc写的。HTML代码看上去格式一片混乱，难以下眼。 非本地信息：当你写代码的时候，一定要写在离需要注释的最近的地方。不然你让人上哪找对应的地方去。 信息过多：不要写许多信息，像是实现的细节等。 格式 这里Martin提出了两种编写代码的格式：竖直格式和水平格式 格式就要像阅读报纸一样，先是大纲，然后才是细节。这也就要求我们在设计类的时候，将大的函数放在前面，将那些大函数使用的小函数放在后面。这样从上往下读的时候，你就可以很顺溜。试想你如果将小函数放上面，你在读下面的函数的时候就要不断向上滚动。 在竖直方向上，距离也很重要。一般每个函数实现之间会空一行，用以分割函数。在函数声明中呢用途一样的函数会放在一起。如果有函数被调用，那么尽量将被调用函数放在调用函数下面。这样在看调用函数的时候一眼就可以读到被调用函数。而且一般变量需要放在最上面。因为函数里面总是需要用到变量的，代码阅读者需要提前知道这些变量。\n我的做法一般是将公共变量放在最上面，代表需要他人了解。然后是公共函数。然后是私有和保护变量，函数（代表我不希望别人关注这些）:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Vector{ public: static unsigned int Vector_Num; Vector(float x, float y); Vector operator+(const Vector\u0026 other); Vector operator-(const Vector\u0026 other); Vector operator*(const Vector\u0026 other); void normlize(); float getX(); float getY(); void setXY(float x, float y); ... private: float x; float y; }; 关于水平格式，不要在水平方向上写很多很多的代码。反正我是不喜欢左右划屏。\n而且关于空循环，请一定要将分号另起一行。这样的代码:\n1 while(bufer.size()!=0 \u0026\u0026 i\u003c=2); 不知道多难看到最后那个分号，改成:\n1 2 while(bufer.size()!=0 \u0026\u0026 i\u003c=2) ; 这样会好很多。\n最后就是，如果团队规定了规则，按照团队的来。一个团队的代码就要整整齐齐。\n总之，代码要又瘦又长\n对象和数据结构 对象和数据结构分别是面向对象和面向过程的产物。其两者有反对称性：**类在改变成员变量的时候比较方便，但是在改变函数的时候比较麻烦。数据结构（指纯数据，像是C的struct）则修改变量方便，修改函数麻烦。**所以怎么使用对象和数据结构，完全看你的需求。\n而且对象不应该“和陌生人说话”。也就是说如果B对象里面包含了C对象，A对象里面包含了B对象，那么不应该有办法从A对象中通过B对象获得C对象。因为如果在B和C对象之间增加了D对象的关联，你的getB().getC()方法可能就要变成getB().getD().getC()了。这就是得墨忒尔规则\n","description":"","tags":["cpp"],"title":"如何写出整洁代码","uri":"/posts/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E6%95%B4%E6%B4%81%E4%BB%A3%E7%A0%81/"},{"categories":null,"content":"分享一下Python3里面用*产生列表的坑\n这里需要注意以下，Python3生成列表有两种方法：\n1 2 a = [[0, 0, 0], [0, 0, 0], [0, 0, 0]] a = [[0]*3]*3 都会生成\n1 2 3 a = [ [0, 0, 0], [0, 0, 0], [0, 0, 0]] 但是这中间是有区别的。假如我要改变a[2][0]:\n1 a[2][0] = 1 那么上面两个的结果是不一样的:\n1 2 3 a = [[0, 0, 0], [0, 0, 0], [1, 0, 0]] a = [[1, 0, 0], [1, 0, 0], [1, 0, 0]] 使用*来产生的列表，好像其每一个子列表的地址是一样的。所以会导致改一个所有其他的都会改。\n","description":"","tags":["python3"],"title":"Python3使用*产生列表的问题","uri":"/posts/python3%E4%BD%BF%E7%94%A8_%E4%BA%A7%E7%94%9F%E5%88%97%E8%A1%A8%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"这两天在看OpenGL光照的时候，教程上提到了法向量变换。这里就来推导一下。\n法向量变换 为什么要法向量变换 很简单，因为如果你直接对法向量采用模型矩阵model或者其他比那还的话，会改变法向量的方向。你可以将法向量$(x,y)$看作一个位置向量，然后对其做$M$变换。可以知道，这个点的坐标必定变化。那么其方向向量就会变化，这样法向量也就变化了（除非它是沿着其方向向量移动）。\n法向量变换矩阵的推导 推导很简单。首先给出空间中齐次坐标的平面方程：\n$$ n_xX+n_yY+n_zZ+n_wW = 0 $$ 写成矩阵就是：\n$$ \\begin{bmatrix} n_x \u0026 n_y \u0026 n_z \u0026 n_w \\end{bmatrix} \\begin{bmatrix} X \\ Y \\ Z \\ W \\end{bmatrix} =0 $$\n然后我们在中间乘上变换矩阵$M$和其逆$M^{-1}$来方便我们寻找法向量变换方程:\n$$ \\begin{bmatrix} n_x \u0026 n_y \u0026 n_z \u0026 n_w \\end{bmatrix} M^{-1} M \\begin{bmatrix} X \\ Y \\ Z \\ W \\end{bmatrix} =0 $$\n这个时候，$M\\begin{bmatrix} X \\ Y \\ Z \\ W \\end{bmatrix}$就是经过变化之后的顶点了，那么显然$\\begin{bmatrix} n_x \u0026 n_y \u0026 n_z \u0026 n_w \\end{bmatrix}M^{-1}$就是变换后的法向量了，也就是说存在：\n$$ \\begin{bmatrix} n_x \u0026 n_y \u0026 n_z \u0026 n_w \\end{bmatrix} M^{-1} \\begin{bmatrix} n_{x_{eye}} \\ n_{y_{eye}} \\ n_{z_{eye}} \\ n_{w_{eye}} \\end{bmatrix} $$\n那么对左边式子转置一下，得到:\n$$ (M^{-1})^T \\begin{bmatrix} n_x \\ n_y \\ n_z \\ n_w \\end{bmatrix} \\begin{bmatrix} n_{x_{eye}} \\ n_{y_{eye}} \\ n_{z_{eye}} \\ n_{w_{eye}} \\end{bmatrix} $$\n所以我们就可以知道，通过$(M^{-1})^T$变换之后，可以将原本的法向量变换到观察空间中了。所以法向量变换矩阵就是$(M^{-1})^T$其中$M$是将点变换的新空间的矩阵（如果你只将点变换到全局空间中就是model，变换到观察空间中就是model*view）\n","description":"","tags":["OpenGL"],"title":"OpenGL-法向量变换","uri":"/posts/opengl-%E6%B3%95%E5%90%91%E9%87%8F%E5%8F%98%E6%8D%A2/"},{"categories":null,"content":"这里记录了各种好用的Linux命令\nconvert convert工具可以转换图像的格式，包括很多的图像格式（PG, BMP, PCX, GIF, PNG, TIFF, XPM和XWD等）\n使用的方法很简单：\n1 convert src.xxx dst.xxx 就可以将src.xxx转化为dst.xxx了，比如convert image.jpg image.png将image图像转化从jpg转化为png格式。\n在你使用libpng等库的时候，可能会出现这个警告：\n1 libpng warning: iCCP: known incorrect sRGB profile 这个是因为你的图片里面有一些格式不对，这个时候你可以convert image.png image.png来将格式整理为最规范的。就不会报警告啦。\n这个命令甚至还可以旋转，缩放图像：\n1 2 3 convert -resize 1024x768 xxx.jpg xxx1.jpg //改变成1024x768 convert -sample 50%x50% xxx.jpg xxx1.jpg //缩小为原来的一半 convert -rotate 270 sky.jpg sky-final.jpg //旋转270度 有了这个再也不用打开软件去转换图片了，直接一个命令搞定全部。\n参考 Linux之convert命令\ntmux 这个工具可以让一个窗口开启多个会话。\n简单来说就是，当你使用终端的时候，如果有程序在执行的时候关闭终端，那么这个程序也会被关闭。但是使用tmux可以讲程序和会话分离，即使终端窗口关闭了也可以保证程序不关闭。\n参考 阮一峰大神的介绍\nmusikbox 使用ncursors库做界面的，CUI的音乐播放器。在没有GUI界面的Linux系统上十分好用，得劲的一批:\ngithub地址：github地址\n","description":"","tags":null,"title":"好用的Unix命令行工具(持续更新)","uri":"/posts/%E5%A5%BD%E7%94%A8%E7%9A%84unix%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"categories":null,"content":"立方体贴图中所有的图片大小必须一样！\n可把我坑坏了，一下午都在调试这个问题😭\n","description":"","tags":["OpenGL"],"title":"OpenGL-关于立方体贴图的注意事项","uri":"/posts/opengl-%E5%85%B3%E4%BA%8E%E7%AB%8B%E6%96%B9%E4%BD%93%E8%B4%B4%E5%9B%BE%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"categories":null,"content":"在Learning-OpenGL的教程中，作者是使用stbi_image这个单头文件库来加载纹理的。当时我就在想：SDL2这么强大，自己应该也可以加载纹理数据的吧。所以就做了一些尝试。\n其实stbi_image从图片文件获得了下面的信息：\n图片的数据（纯像素数据，不包括头数据） 图片的大小 图片的通道 那我想我们也可以使用SDL2_image库来实现。\n首先把图片加载进来：\n1 SDL_Surface* surface1 = IMG_Load(\"resource/Block.png\"); 然后把数据，大小拿到手：\n1 2 3 4 int width, height, channel; width = surface1-\u003ew; height = surface1-\u003eh; unsigned char* data = (unsigned char*)surface1-\u003epixels; 关于通道的话，surface本身并没有存储通道，但是我们可以计算出来：\n1 channel = surface1-\u003epitch/surface1-\u003ew; 这个地方不清楚的请参考我的“SDL-Surface结构体详解”。\n这样所有的东西都获得了，就可以绑定纹理了。\n需要注意的是：和stbi_image库一样，载入的图片是反过来的，你需要通过一些手段把它翻转。\n","description":"","tags":["OpenGL"],"title":"使用纯SDL2库给OpenGL纹理","uri":"/posts/%E4%BD%BF%E7%94%A8%E7%BA%AFsdl2%E5%BA%93%E7%BB%99opengl%E7%BA%B9%E7%90%86/"},{"categories":null,"content":"这里我们来使用SDL2从零开始制作一个基础的粒子系统。\n最后的成果像下面这样：\n基础理论 首先我们来看一下实现粒子系统需要哪些基础理论。 粒子系统中最基本需要三个东西：\n世界：用于对发射出来的粒子操控，产生物理运动 粒子 发射器：用于发射粒子 我们在世界中会维护一个粒子池。每次发射器需要从粒子池里面将没有发射出去的粒子拿出来发射，世界会自动计算已经发射的粒子的物理运动，并且在他们死亡的时候在此放回粒子池里面。\n每一个粒子，最基本需要一个生命值，这个生命值随着时间而减少。当减少到0的时候就是粒子死亡的时候，这个时候粒子需要回到粒子池里面。\n这里让世界控制粒子而不是发射器控制粒子，首先方便了管理：所有的粒子都在粒子池里面，而不是零散的分散在发射器中。其次如果发射器被销毁了，其发射过的粒子仍然可以继续运动，不会出现粒子突然消失的情况。\n实现 这里我们采用SDL2来实现粒子系统。 首先我们把所有的结构体全部给出来：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 typedef struct{ int hp; /**\u003c 粒子的生命值*/ SDL_Vector direct; /**\u003c 粒子的发生方向*/ bool isdead; /**\u003c 粒子是否死亡*/ SDL_Color color; /**\u003c 粒子的颜色*/ SDL_Pointf position; /**\u003c 粒子的位置*/ }_PS_Partical; typedef struct{ SDL_Vector gravity; /**\u003c 重力*/ int partical_num; /**\u003c 粒子池中的粒子个数*/ _PS_Partical* particals; /**\u003c 粒子池*/ SDL_Renderer* render; /**\u003c SDL2要求的渲染器*/ }PS_World; typedef struct{ SDL_Vector shoot_dir; /**\u003c 粒子将要发射出去的方向*/ int partical_hp; /**\u003c 每个粒子的生命值*/ float half_degree; /**\u003c 发射口里发射中心的最大角度*/ SDL_Color color; /**\u003c 粒子的颜色*/ PS_World* world; /**\u003c 发射器所在的世界*/ int shoot_num; /**\u003c 一次性发射出去的粒子个数*/ SDL_Point position; /**\u003c 粒子发射器的位置*/ }PS_ParticalLauncher; 这里关于粒子发射器的各个参数，其实就是下图：\n这里我们不希望将粒子暴露给其他程序员，所以这里加上_表示私有的，不想要被访问。\n这里的思路是这样的：首先我们需要创造一个世界，然后需要创造一个粒子发射器。粒子发射器会从世界的粒子池里面找到isdead=true的粒子，设置它的属性，并且将其唤醒(isdead=false)。然后在每一帧的时候世界会遍历粒子池里面的每一个粒子，对已经被唤醒的粒子计算物理运动。\n这里有一些宏定义，先给出来：\n1 2 3 4 #define WORLD_PARTICAL_INIT_NUM 100 //当世界创建的时候粒子池里面粒子的个数 #define PARTICAL_SINK_INC 50 //每次粒子池里面粒子不够用的时候，新增加的粒子数 #define PARTICAL_R 5 //粒子的半径 #define PARTICALS_PER_DEGREE 0.15 //每1度内包含的粒子数目(你也可以改成粒子密度，但是我这里为了简单就以每度的方式定义了) 首先我们把所有的创建函数给出来：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 PS_World PS_CreateWorld(SDL_Vector gravity, SDL_Renderer* render){ //初始化随机数生成器 srand((unsigned)time(NULL)); PS_World world; //赋值属性 world.gravity = gravity; world.render = render; world.partical_num = WORLD_PARTICAL_INIT_NUM; world.particals = (_PS_Partical*)malloc(sizeof(_PS_Partical)*WORLD_PARTICAL_INIT_NUM); //malloc粒子池 //如果malloc失败报错 if(world.particals == NULL) SDL_LogError(SDL_LOG_CATEGORY_ERROR, \"memory not enough, world partical malloc failed!!\"); //将粒子池里面的所有粒子设为死亡状态 for(int i=0;i\u003cworld.partical_num;i++) world.particals[i].isdead = true; //false和true是C99标准新增的，在头文件\u003cstdbool.h\u003e中 return world; } PS_ParticalLauncher PS_CreateLauncher(SDL_Point position, SDL_Vector shoot_dir, int partical_hp, float half_degree, SDL_Color color, PS_World* world, int shoot_num){ PS_ParticalLauncher launcher; //赋值属性 launcher.color = color; launcher.half_degree = half_degree; launcher.partical_hp = partical_hp; launcher.shoot_dir = shoot_dir; launcher.world = world; //根据角度计算一次性发射的粒子总数 launcher.shoot_num = (int)ceil(half_degree*2*PARTICALS_PER_DEGREE); launcher.position = position; return launcher; } 然后是一些辅助函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 //这个函数在粒子池不够用的时候给粒子池扩容 void _PS_IncreaseParticalSink(PS_World* world){ world-\u003eparticals = (_PS_Partical*)realloc(world-\u003eparticals, sizeof(_PS_Partical)*(world-\u003epartical_num+PARTICAL_SINK_INC)); if(world-\u003eparticals == NULL) SDL_LogError(SDL_LOG_CATEGORY_ERROR, \"memory not enough, partical sink realloc failed!!\"); for(int i=world-\u003epartical_num-1;i\u003cworld-\u003epartical_num+PARTICAL_SINK_INC;i++) world-\u003eparticals[i].isdead = true; world-\u003epartical_num += PARTICAL_SINK_INC; } //这个函数在粒子池中从idx开始寻找下一个死亡的粒子，并且返回这个粒子，将这个粒子的下标赋值给idx（idx相当于迭代器） _PS_Partical* _PS_GetNextDeadPartical(PS_World* world, int* idx){ int sum = 0; (*idx)++; if(*idx \u003e= world-\u003epartical_num) *idx = 0; while(world-\u003eparticals[*idx].isdead != true){ (*idx)++; if(*idx \u003e= world-\u003epartical_num) (*idx) = 0; sum++; if(sum \u003e= world-\u003epartical_num) break; } if(sum \u003e= world-\u003epartical_num) return NULL; return \u0026world-\u003eparticals[*idx]; } //这个函数和上面的一样，只不过是找到下一个没有死亡的粒子 _PS_Partical* _PS_GetNextUndeadPartical(PS_World* world, int* idx){ int sum = 0; (*idx)++; if(*idx \u003e= world-\u003epartical_num) *idx = 0; while(world-\u003eparticals[*idx].isdead == true){ (*idx)++; if(*idx \u003e= world-\u003epartical_num) (*idx) = 0; sum++; if(sum \u003e= world-\u003epartical_num) return NULL; } return \u0026world-\u003eparticals[*idx]; } //这个函数绘制粒子 void _PS_DrawPartical(SDL_Renderer* render, _PS_Partical* partical){ SDL_Color* color = \u0026partical-\u003ecolor; SDL_SetRenderDrawColor(render, color-\u003er, color-\u003eg, color-\u003eb, color-\u003ea); SDL_RenderDrawCircle(render, partical-\u003eposition.x, partical-\u003eposition.y, PARTICAL_R); //这个函数是我自己封装的，SDL2本身是不带有的。绘制圆的函数。 } //绘制圆函数的实现 void SDL_RenderDrawCircle(SDL_Renderer* render, int x, int y, int r){ float angle = 0; const float delta = 5; for(int i=0;i\u003c360/delta;i++){ float prevradian = Degree2Radian(angle), nextradian = Degree2Radian(angle+delta); SDL_RenderDrawLine(render, x+r*cosf(prevradian), y+r*sinf(prevradian), x+r*cosf(nextradian), y+r*sinf(nextradian)); angle += delta; } } 然后就是发射粒子和对更新世界的函数了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //发射粒子,其实就是给粒子的各个属性赋值，然后设置isdead为false void PS_ShootPartical(PS_ParticalLauncher* launcher){ PS_World* world = launcher-\u003eworld; int idx = 0; //这里需要发射shoot_num个粒子 for(int i=0;i\u003clauncher-\u003eshoot_num;i++){ _PS_Partical* partical; //这里循环获得下一个死亡的粒子。如果返回NULL表示粒子池里面的粒子都在活动，这个时候就要扩充粒子池。 while((partical=_PS_GetNextDeadPartical(world, \u0026idx))==NULL){ _PS_IncreaseParticalSink(world); } //这里对其发射的角度进行随机(在half_degree里) int randnum = rand()%(int)(2*launcher-\u003ehalf_degree*1000+1)-(int)launcher-\u003ehalf_degree*1000; float randdegree = randnum/1000.0f; //TODO 这个地方的赋值要不要使用指针呢？放在最后的时候优化吧 partical-\u003ecolor = launcher-\u003ecolor; SDL_Vector direct = Vec_Rotate(\u0026launcher-\u003eshoot_dir, randdegree); //旋转发射向量 partical-\u003edirect = direct; partical-\u003ehp = launcher-\u003epartical_hp + rand()%(10+1)-5; partical-\u003eisdead = false; partical-\u003eposition.x = launcher-\u003eposition.x; partical-\u003eposition.y = launcher-\u003eposition.y; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //旋转向量的代码在这里（如果看不懂可以参考我的“游戏编程中的旋转”一文） typedef struct{ float x; float y; }SDL_Pointf; typedef SDL_Pointf SDL_Vector; inline float Degree2Radian(float degree){ return degree*M_PI/180.0f; } SDL_Vector Vec_Rotate(SDL_Vector* v, float degree){ float radian = Degree2Radian(degree); SDL_Vector ret = {cosf(radian)*v-\u003ex-sinf(radian)*v-\u003ey, sinf(radian)*v-\u003ex+cosf(radian)*v-\u003ey}; return ret; } 然后就是最重要的世界更新函数了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void PS_WorldUpdate(PS_World* world){ _PS_Partical* partical; //遍历粒子池里面每一个粒子 for(int i=0;i\u003cworld-\u003epartical_num;i++){ partical = \u0026world-\u003eparticals[i]; //如果是活的，就计算其下一帧的位置 if(partical-\u003eisdead == false){ if(partical-\u003ehp \u003e 0){ partical-\u003eposition.x += partical-\u003edirect.x+world-\u003egravity.x/2.0; partical-\u003eposition.y += partical-\u003edirect.y+world-\u003egravity.y/2.0; _PS_DrawPartical(world-\u003erender, partical); } partical-\u003ehp--; } if(partical-\u003ehp \u003c= 0) partical-\u003eisdead = true; } } 使用 最后给出我们的使用方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \"SDL.h\" #include \"particalSystem.h\" #include \"log.h\" #define TEST_ALL int main(int argc, char** argv){ SDL_Init(SDL_INIT_EVERYTHING); SDL_Window* window; SDL_Renderer* render; SDL_CreateWindowAndRenderer(800, 800, SDL_WINDOW_SHOWN, \u0026window, \u0026render); SDL_Event event; bool isquit = false; SDL_Vector gravity = {0, 0}; SDL_Color color = {0, 255, 0, 255}; SDL_Color explodecolor = {255, 0, 0, 255}; SDL_Vector direct = {5, -5}; SDL_Point position = {400, 400}; SDL_Point explodePositon = {300, 300}; int partical_hp = 50; PS_World world; world = PS_CreateWorld(gravity, render); PS_ParticalLauncher launcher = PS_CreateLauncher(position, direct, partical_hp, 30, color, \u0026world, 10); while(!isquit){ SDL_SetRenderDrawColor(render, 100, 100, 100, 255); SDL_RenderClear(render); while(SDL_PollEvent(\u0026event)){ if(event.type == SDL_QUIT) isquit = true; if(event.type == SDL_KEYDOWN){ switch(event.key.keysym.sym){ case SDLK_SPACE: PS_Explode(\u0026world, explodecolor, explodePositon, 100); break; case SDLK_d: launcher.shoot_dir = Vec_Rotate(\u0026launcher.shoot_dir, 5); break; case SDLK_a: launcher.shoot_dir = Vec_Rotate(\u0026launcher.shoot_dir, -5); break; case SDLK_w: launcher.partical_hp+=2; break; case SDLK_s: if(launcher.partical_hp \u003e 0) launcher.partical_hp-=2; break; } } } PS_ShootPartical(\u0026launcher); //发射粒子 PS_WorldUpdate(\u0026world); //世界更新 SDL_SetRenderDrawColor(render, 255, 0, 0, 255); SDL_RenderDrawLine(render, launcher.position.x, launcher.position.y, launcher.position.x+launcher.shoot_dir.x*50, launcher.position.y+launcher.shoot_dir.y*50); SDL_RenderPresent(render); SDL_Delay(30); } PS_DestroyLauncher(\u0026launcher); PS_DestroyWorld(\u0026world); SDL_DestroyRenderer(render); SDL_DestroyWindow(window); SDL_Quit(); return 0; } ","description":"","tags":["SDL2"],"title":"从零开始制作一个基础的粒子系统","uri":"/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%9F%BA%E7%A1%80%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"转阮一峰大神的尾递归调用博客方便以后参考。\n","description":"","tags":null,"title":"尾递归和尾调用（搬运）","uri":"/posts/%E5%B0%BE%E9%80%92%E5%BD%92%E5%92%8C%E5%B0%BE%E8%B0%83%E7%94%A8%E6%90%AC%E8%BF%90/"},{"categories":null,"content":"这个库是非官方的第三方库，官网在这里。 在线API文档在这里\ngfx库简介 SDL2_gfx库用主要用于以下三件事：\n绘制图形（包括原本SDL不直接支持的圆，椭圆，圆角矩形（实心的和空心的）等等等）和文字（很简单的英文文字） 对SDL_Surface进行变换，包括旋转，缩放 控制帧率 其实我觉得主要还是他对绘制图形方面的支持（因为SDL_Surface不是很常用了，帧率的控制我们自己几行代码也能控制）比较好。\n绘制图形 你可以直接跳到其API文档里面的SDL2_gfxPrimitives.h文件部分（直接跳转），会看到各种各样的绘制图形的函数。函数都是直接使用render绘制，直接指定颜色和坐标。函数太多了，而且API很详细，所以大家自己去看吧。\n需要注意的是：绘制之后，render的颜色会一直被改变。所以在使用gfx库的时候要在每次的循环前加上SDL_SetRenderDrawColor()设置清屏颜色。而且绘制字符的函数很垃圾，有必要的时候还是用SDL_ttf和SDL_FontCache库吧。\n对SDL_Surface进行变换 这一部分直接API文档吧:直接跳转\n控制帧率 首先你需要声明一个FPSmanager结构体，这个结构体里面会存储有关帧率的信息：\n1 FPSmanager manager; 然后你需要初始化这个结构体：\n1 SDL_initFramerate(\u0026manager); 然后，如果有必要，你需要指定帧率（不指定默认30FPS)：\n1 SDL_setFramerate(\u0026manager); 最后，在主循环中，不要使用SDL_Delay()函数延时，使用它给的SDL_framerateDelay()函数延时。这个函数会帮助你控制帧率：\n1 SDL_framerateDelay(\u0026manager); 小声BB 其实在SDL1的时候有一个GUIlib可以绘制GUI控件的，但是SDL2的时候没了（难道是还没有开发出来？？？），很遗憾啊，现在GUI要自己写了。\n","description":"","tags":["SDL2"],"title":"SDL2第三方库：SDL2_gfx","uri":"/posts/sdl2-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93_sdl2_gfx/"},{"categories":null,"content":"SDL2除了自己本身的SDL2库，官方和其他开发者为了补充相应的内容，给出了很多有用的库。这里就来看一下适用范围最广的SDL2_image库。\n所有的官方拓展库可以在这里找到。\nSDL2_image库 由于SDL2本身只有SDL_LoadBMP()函数，只能够载入位图，所以官方给出了SDL_image库，允许SDL2加载其他各种格式的图片资源。可以加载BMP, GIF, JPEG, LBM, PCX, PNG, PNM, SVG, TGA, TIFF, WEBP, XCF, XPM, XV。 其文档在这里\n使用流程 使用的流程十分简单：\n首先使用IMG_Init()函数初始化SDL_Image库。这里也需要像SDL_Init()函数一样给入flag。flag有IMG_INIT_JPG, IMG_INIT_PNG, IMG_INIT_WEBP, IMG_INIT_GIF。可以使用按位或来传入多个。默认可以载入位图。 使用IMG_Load()函数载入图像。 关闭SDL_image库IMG_Quit() 主要函数 主要的函数分为两种：载入图片的函数，判断图片函数，存储图片函数和错误处理函数。\n载入图片 一般最通用的函数是IMG_Load()，可以载入你在IMG_Init()里面立的flag相关的图片。 或者使用IMG_Load_RW()来从raw资源载入图片。raw资源可以通过SDL_RWFromFile()函数获得。但是一般不这样做（直接IMG_Load不就行了）。\n而且还有各种IMG_LoadXXX_RW()函数用于读取特定格式的raw资源，比如IMG_LoadPNG_RW()函数。这些函数基本上没什么用。\n判断图片资源 所有的判断函数都是IMG_isXXX()形式，其中XXX是你的图片格式的大写。比如IMG_isCUR(),IMG_isJPG()。所有的判断函数的参数都是SDL_RWops*，可以使用SDL_RWFromFile()获得。\n这些图片判断函数的作用在于，如果你的图片的后缀名不是平常的后缀名（比如.png被改成.xxx了），你可以使用这些函数判断你的图片的类型。\n存储图片 你可以使用IMG_SaveJPG(), IMG_SavePNG()函数来保存图片。对于jpg图片会有一个额外的“质量”参数。 需要注意的是存储图片的函数在文档里没有被提及，但是确实是存在的。\n错误处理 通过IMG_SetError(), IMG_GetError()函数获得和设置错误。\n","description":"","tags":["SDL2"],"title":"SDL2第三方库：SDL2_image库","uri":"/posts/sdl2-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93_sdl2_image/"},{"categories":null,"content":"TTF库的文档在这里。 FontCache库的github地址在这里。\nSDL2_ttf库介绍 SDL本身是没有绘制文字的功能的。但是官方给出了SDL2_ttf拓展库，让程序员可以绘制文字。注意SDL2_ttf只能够处理ttf文件。\nSDL2_ttf库的使用流程 初始化库TTF_Init()，不需要参数 使用库： 使用TTF_OpenFont()函数打开一个字体文件，会返回一个TTF_Font*。 使用绘制函数TTF_RenderText_Solid()将字体转换为SDL_Surface*。 将SDL_Surface*转化为SDL_Texture*绘制到指定位置。 关闭字体描述符TTF_CloseFont()。 关闭库TTF_Close() SDL2_ttf库的使用 基本上可以分为三大函数：\n打开字体函数 设置/获得字体函数 将文字转换为SDL_Surface* 打开子图和设置/获得字体属性的函数就不说了，手册里面说的很清楚\n将文字转换为SDL_Surface* ttf库是不能直接绘制的，必须将字体转换为surface。这里的转换函数大体分为：\nTTF_RenderXXX_Solid():直接转换 TTF_RenderXXX_Shaded():转换为有阴影的（质量高，效率低） TTF_RenderXXX_Blended()：使用混合转换（质量最高，效率最低） 其中XXX可以是Text, UTF8, UNICODE, Glyph，分别代表从文本，UTF8字体，Unicode字体和轮廓转换。\nSDL_FontCache库 SDL_ttf库虽然可以绘制文字，但是非得先转化为Surface，然后再绘制。而且对字体的控制也不是很容易。这里强力推荐一个github上的库SDL_FontCache()库，十分好用。\nSDL_FontCache库的使用 首先使用FC_CreateFont()创建一个字体描述符FC_Font* 然后使用FC_LoadFont()载入一个字体 然后使用FC_Draw()就可以绘制了，直接绘制到目标地点哦。 使用完之后使用FC_FreeFont()释放描述符就OK了 这个库是不是相比来说很快很简单呢？而且官方说这个库比SDL2_ttf更快哦。\n","description":"","tags":["SDL2"],"title":"SDL2第三方库：SDL2_ttf库和SDL_FontCache","uri":"/posts/sdl2-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93_sdl2-ttf%E5%92%8Csdl_fontcache/"},{"categories":null,"content":"什么是Docker Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。\n其实说白了就是Docker是一个存储开发环境的容器，每个开发环境之间没有任何接口。我们可以通过docker来共享开发环境。\n什么是镜像 镜像(image)，通俗的来说，就是一份描述软件的清单。docker通过镜像来构建容器，说白了就是通过软件描述清单来构建容器。\n什么是容器 容器(container)其实就是根据镜像构建出来的软件实体。镜像和容器就像类和对象的关系一样。\nMac下Docker服务的开启 在Docker官网下载Docker文件，安装之后点击Docker的图标就会自动开启服务。 和Linux不同，Mac下只能通过Docker程序启动服务，不能使用命令启动。\nDocker镜像相关命令 查看本地镜像 使用docker images来查看本地的所有镜像:\nREPOSITORY TAG IMAGE ID CREATED SIZE redis latest 4cdbec704e47 6 days ago 98.2MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB Repository: 镜像的名称，这里是Ubuntu系统 TAG: 镜像的版本号，latest表示最新版本 IMAGE ID: docker给与的每个镜像的唯一ID CREATED: 创建的时间 SIZE: 镜像大小 搜索镜像文件 使用docker search xxx在镜像仓库中来搜索你想要的镜像。 比如搜索python：docker search python\nNAME DESCRIPTION STARS OFFICIAL AUTOMATED python Python is an interpreted, interactive, objec… 5076 [OK] django Django is a free web application framework, … 946 [OK] pypy PyPy is a fast, compliant alternative implem… 237 [OK] kaggle/python Docker image for Python scripts run on Kaggle 139 [OK] arm32v7/python Python is an interpreted, interactive, objec… 48 nikolaik/python-nodejs Python with Node.js 44 [OK] ... NAME: 镜像名称 DESCRIPTION: 镜像的描述 STARS: star的人数，和github的star差不多 OFFICIAL: 是否是官方的镜像 如果不想下载列表中有的版本，可以上docker hub中来搜索你想要的镜像版本。如果有的话就可以下载。\n拉取（下载）镜像文件 使用docker pull xxx:version下载 其中xxx是你的镜像名称，version是镜像的版本，如果省略默认为latest。\n删除镜像文件 使用docker rmi id即可。 其中id是镜像ID。 如果存在相同ID的镜像会报错（存在相同ID的原因是你的镜像名称和版本都一样，也就是说你下载了多个一模一样的镜像）,这时可以使用docker rmi name:version的方式删除。\n查看所有镜像的ID 使用docker images -q可以查看到所有镜像的ID。那么就可以使用:docker rmi \\docker images -q``来删除所有的镜像。\nDocker容器相关命令 查看容器 docker ps来查看现在正在运行的容器 docker ps -a来查看现存的所有容器:\nCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ca319f908c4e ubuntu \"/bin/bash\" 4 days ago Exited (0) 4 days ago helloworld CONTAINER ID:容器的ID IMAGE: 容器所承载的镜像 COMMAND: 进入容器时默认执行的命令（对于Ubuntu镜像默认进入Bash） CREATED: 创建时间 STATUS: 容器状态，这里是退出状态（运行状态会显示Up） PORT:容器端口号 NAMES: 容器名称 也可以使用docker inspect container_name来获取容器的详细信息\n创建容器 使用docker run ...来创建容器。这个命令需要加上一些参数：\n--name=:容器的名称 -i:容器保持一致运行（在客户端连接断开还能连接） -t:给容器分配一个伪终端，方便我们输入一些命令 -d:后台运行容器，需要通过额外命令进入容器 image_name:version :镜像名称:镜像版本（默认latest版本或已存在的唯一镜像版本） command:初始化指令，在进入容器时默认执行的指令，可选 如: docker run -it --name=c1 ubuntu /bin/bash 会创建一个基于ubuntu镜像的容器，并且进入时默认执行/bin/bash指令\n在回车之后docker会自动进入容器内部，想要退出的话使用exit命令即可。退出之后容器默认自动关闭\n进入容器 docker exec container_name/container_id 命令进入容器\n启动容器 docker start container_name/container_id启动容器\n停止容器 使用docker stop container_name来停止容器\n删除容器 使用docker rm container_id/container_name删除。 使用方法和删除镜像一样，后面跟容器ID或者容器名称\n得到所有容器的ID是docker ps -aq\n数据卷操作 配置数据卷 通过docker run ... -v 宿主机目录/文件:容器内目录/文件来将容器内的目录或文件挂载到容器内。 注意事项:\n目录必须是绝对路径 如果目录不存在会自动创建 一个容器可以挂在多个数据卷（通过多个-v来指定） 比如: docker run -it --name=c1 -v /root/data:/root/data_container ubuntu来将本机的data挂载到/root/data_container目录中。\n有了挂载，我们就可以解决如下问题：\n不同的容器内文件相互共享：只需要将同一目录或文件挂载到不同容器即可 容器文件和宿主机文件共享 数据卷容器 如果想要多个容器进行数据交换，那么需要很繁杂的挂载操作。数据卷容器就是为了处理这个情况而诞生的。\n配置数据卷容器 首先使用-v参数来设置容器目录（不设置数据卷目录）： docker run -it --name=c2 -v /volume ubuntu\n然后通过--volumes-from参数将多个容器挂载到这个数据卷上: docker run -it --name=c3 --volumes-from c2将c2和c3绑定。 这样我们在c3中就可以看到c2中的/volume目录了。\n如果想看当前挂载到那个目录了，可以通过docker inspect命令找到Mount字段，里面的destination就是挂载的目录了。\n将容器转移到镜像 通过docker commit container_id image_name:image_version来将容器转化为镜像。 通过docker save -o 咋锁文件名称 镜像名称:版本号将镜像压缩成压缩包。 通过docker load -i 压缩文件包来将压缩好的镜像文件加载进来。\n有了镜像压缩包之后，就可以将镜像发给其他的人，这样就可以共享开发环境了。\n","description":"","tags":["Docker"],"title":"Docker学习笔记","uri":"/posts/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"cmake拓展应用\n使用CMake产生不同形式的编译文件 默认情况下是产生Makefile文件，但是你可以选择系统支持的编译文件。 首先在终端输入\n1 cmake --help 在输出信息的最下面会有当前支持的编译文件格式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 Generators The following generators are available on this platform (* marks default): * Unix Makefiles = Generates standard UNIX makefiles. Ninja = Generates build.ninja files. Xcode = Generate Xcode project files. CodeBlocks - Ninja = Generates CodeBlocks project files. CodeBlocks - Unix Makefiles = Generates CodeBlocks project files. CodeLite - Ninja = Generates CodeLite project files. CodeLite - Unix Makefiles = Generates CodeLite project files. Sublime Text 2 - Ninja = Generates Sublime Text 2 project files. Sublime Text 2 - Unix Makefiles = Generates Sublime Text 2 project files. 这里前面有*的就是默认的文件格式，我这里是Unix的Makefile。 如果想要改变输出的编译文件，需要加上-G选项：\n1 2 cmake -GXcode . cmake -G\"Sublime Text 2 - Unix Makefiles\" . cmake编译工程的其他方式 我们最熟悉的就是两种方式：在工程目录下使用cmake .和创建一个build目录，进入之后使用cmake ..。\n其实你也可以在含有CMakeCache.txt文件的文件夹下执行cmake .来编译。比如在build文件夹下。CMakeCache.txt文件本身就是存储着cmake编译信息，减少重复编译时间的文件。\n或者你可以使用cmake [-S source_file_path] [-B build_path]来编译。其中-S指令指定了CMakeLists.txt文件所在位置（一般是不写-S指令的，直接写出路径就可以了），-B指定要将编译结果放在哪个文件。这样你以后就可以写\n1 cmake . -B build 而不需要写三条语句了。\ncmake生成工程时的有趣选项 --graphviz --graphviz=\u003cfilename\u003e选项很有意思，他会给你生成一个用graphviz软件（dot语法）描述的文件，文件名称是filename。这个文件描述的图片描述了你生成的可执行文件。\n--system-information --system-information=\u003cfilename\u003e会生成系统信息。系统信息里面包含了这个系统中链接库的后缀，可执行文件的后缀等。\n编译二进制文件 一般我们都是先cmake ..，然后cmake生成了Makefile，再使用make编译。\n然后又有多少人知道，直接make只是编译所有的目标，你还可以在后面指定目标名称来进行单独编译呢？ 目标的名称就是你CMakeLists.txt中语句add_excutable()的第一个参数。\n还有一个冷知识：但是cmake自己也可以编译，使用的是cmake --build命令。只不过没人用就是了。\n安装 一般都是使用sudo make install安装的。但是这里有一个很烦人的问题：如果我在cmake ..的时候指定错了安装目录，那我还得先清理build文件夹，然后再重新cmake ..。这个时候这个cmake --install指令就有用了。\ncmake --install本身也可以安装文件（比如cmake --install .），但是更好的用途是使用--prefix选项再次定义CMAKE_INSTALL_PREFIX变量来改变安装路径:\n1 cmake --install --prefix /usr/local/GMQ/include . ","description":"","tags":["cmake\u0026make"],"title":"CMake拓展应用","uri":"/posts/cmake%E6%8B%93%E5%B1%95%E5%BA%94%E7%94%A8/"},{"categories":null,"content":"编写含有函数实现的头文件的问题 我们都知道可以这样编写头文件：\n1 2 3 4 5 6 7 8 9 //header.hpp #ifndef __HEADER_HPP__ #define __HEADER_HPP__ int mysum(int a, int b){ return a+b; } #endif 但是考虑下面的文件包含情况:\n这里function.hpp包含了header.hpp,然后main.cpp包含了function.hpp。\n在这种情况下按照左下角的方式编译，会报错说mysum函数重复。\n我个人认为是这个原因： 首先function.cpp会包含function.hpp,function.hpp会包含header.hpp,这样生成的functino.o就会有一份mysum函数了。 然后main.cpp会包含function.hpp，这样生成的main.o中就有一个mysum函数了。\n最后再对main.o,function.o编译，这样由于两个中间文件有同一个函数，就会重复。\n解决办法 解决办法就是在mysum前面加上static。 之所以加上static，是因为static关键字会保证其后面的函数（或变量）在全局中只有一份。这样的话在对main.o,function.o编译的时候就只会留下一份拷贝，也就避免了函数重复了。\n另：关于#pragma once 和#ifndef...#define语句的区别 一般写程序，为了防止头文件重复包含，会通过#ifndef XXX #define XXX #endif这种语句来保证不被包含。其实还有另一种方式#pragma once也可以。\n区别在于：#ifndef形式是C/C++支持的，在语言标准内的。而#pragma once是由编译器保证的，有些编译器是不支持。而且#pragma once只能对全部文件进行包含检测，#ifndef格式却能对局部进行检测。所以平常用#ifndef多一些。\n参考 C/C++中#pragma once的使用\n","description":"","tags":["cpp"],"title":"如何将函数实现放在头文件内","uri":"/posts/%E5%A6%82%E4%BD%95%E5%B0%86%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%94%BE%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E5%86%85/"},{"categories":null,"content":"今年要学些计算机网络的知识了，打算学好之后自己做一个小的联机游戏。最好是可以让大家一起玩的。像我这种穷屌丝买不起服务器，只能在自己的电脑上搭建服务器咯。\n使用node.js搭建一个简单的服务器 首先可以使用node.js搭建一个简单的服务器（或者你使用python，java也可以）:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \"use strict\"; const http = require(\"http\"); const fs = require(\"fs\"); const hostname = '127.0.0.1'; const port = 8080; const index_context = fs.readFileSync(\"./web/index.html\", \"utf-8\"); console.log(`本地调试:http://${hostname}:${port}`); var server = http.createServer(function(req, res) { res.writeHead(200); res.end(index_context); }); server.listen(port); 这里会将web/index.html文件展示在页面上。绑定在本地的8080端口。\n在局域网下玩耍 现在你有了一个用node.js写的小型服务器了，并且可以运行展示一个页面。那么接下来你就可以将这个页面展示给小伙伴了。你可以在局域网下展示给他们，方法是让你的小伙伴和你共同连接一个局域网（你可以分享你电脑的无线网，或者直接都连接你的手机热点），然后将服务器的监听端口改变成你的无线网IP就行了。\n在Mac系统下，你可以这样查看你的无线网IP：\n然后改写node.js中的这一行:\n1 2 const hostname = '你的手机热点IP'; const port = 8080; 之后你的小伙伴输入你的手机热点IP就可以看到你的网页啦。\n将网站放到公网上 如果你的小伙伴和你不在一个局域网下，那么就没办法看到你的网站了。这个时候就要使用网络穿透的手段将自己的电脑穿透到公网上去。\nngrok 最著名的网络穿透工具是ngrok，官网在这里，你只要进去下载它们的工具，并且注册一个账号就可以使用了。使用的方法很简单，官网教程也说的很清楚教程。\n如果你想要使用http协议，那么你就写\n1 ngrok http port port是你本地的端口号（比如上面的程序就是8080）\n如果是tcp协议你就吧http换成tcp就行了。\n虽然说这个很有名，但是我的电脑运行之后网站登不上去啊，不知道是不是被墙了。如果你和我一样，那可以看看下面这个。\nnatapp natapp是我们国内的，基于ngrok的网络穿透工具。官网在这里。 进去之后和ngrok一样，下载他们的命令行程序，注册一个账号，创建一个网络隧道即可。网上也有很多教程，这里就不赘述了。\nnatapp一个人可以免费创建两个网络隧道，我就创建了一个http类型的一个tcp类型的。\n当你准备好之后，首先在本地把你的nodejs写的服务器转起来，然后再使用natapp指定你的端口号转起来就行了：\n这里我点击 http://2psa8j.natappfree.cc 就可以访问我的网站了。\n需要注意的是，ngrok和natapp每次打开的时候的域名都是随机的。如果你想要绑定域名的话，ngrok是可以直接绑定的，但是natapp需要付费\nhttp类型的隧道只能展示网页，如果你想要做服务器游戏的话需要tcp类型的隧道，并且还需要一个客户端程序和一个服务器程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #file: client.py #-*- coding:UTF-8 -*- #!/usr/bin/python3 import socket if __name__ == '__main__': sock = socket.socket() host = socket.gethostname() sock.connect(('server.natappfree.cc', 32775)) while True: context = sock.recv(1024) if context: print(context.decode('utf-8')) break sock.close() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #file: server.py #-*- coding:UTF-8 -*- #!/usr/bin/python3 import socket import threading def server_func(c, addr): c.settimeout(5) print(\"connect address:\", addr) text = 'I recieved your require'.encode('utf-8') c.send(text) c.close() if __name__ == '__main__': sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) sock.bind(('localhost', 5050)) sock.listen(10) print(\"server is running...\") while True: try: c, addr = sock.accept() if c and addr: t = threading.Thread(target=server_func, args=[c, addr]) t.start() t.join() except socket.timeout: print(\"time out\") except: break sock.close() print(\"server closed\") 这里客户端一连接，服务器就会打印出客户端的信息，并且返回一个\"I recieved your require\"。\n这里首先得运行natapp，使用你的tcp隧道的authtoken来转，这样就会自动切换到tcp隧道方式：\n1 natapp -authtoken=你的TCP隧道authtoken 然后屏幕上会显示tcp的地址：\n这个时候再将你的客户端程序的连接和端口号改成这个：\n1 sock.connect(('server.natappfree.cc', 40798)) #client.py 注意服务器程序不要更改。\n然后运行你的服务器程序，现在你的服务器程序就对应了这个域名了。\n然后再运行你的客户端程序，可以看到来自服务器的响应：\n这样的话学期末的时候就可以编写服务器游戏啦，到时候如果写出来了Demo我会把源码放在我的github上的。\n免费域名 最后再给两个免费域名的资源，你可以在这个网站上申请免费的域名： gearhost这个可以终身使用，但是你的域名后面会有gearhost.xxx的后缀。 freenom这个最长可以免费使用12个月，但是没有自带的后缀。\n参考 廖雪峰的node.js教程 ngrok内网穿透教程\n","description":"","tags":null,"title":"论穷屌丝如何在自己的电脑上搭建服务器","uri":"/posts/%E8%AE%BA%E7%A9%B7%E5%B1%8C%E4%B8%9D%E5%A6%82%E4%BD%95%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E7%94%B5%E8%84%91%E4%B8%8A%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"这里记录一下extern和static在C/C++中的用法。\nstatic 首先是static，我们都知道在局部变量前使用static会让局部变量的生命周期变为全局变量：\n1 2 3 4 void inc(){ static a=0; a++; //这里的a每次都自增一个，而不是每次都是1 } 但是static作用在全局变量，或者函数上有什么用呢？\n如果static作用在全局变量上，那么这个变量就是专门属于这个文件的，其他文件是不能够访问的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //file header.hpp #ifndef __HEADER_HPP__ #define __HEADER_HPP__ #include \u003ciostream\u003e using namespace std; static int a = 0; static void say(){ cout\u003c\u003c\"hello extern\"\u003c\u003cendl; } #endif //file main.cpp #include \u003ciostream\u003e #include \"header.hpp\" using namespace std; int main(){ cout\u003c\u003ci\u003c\u003cendl; say(); return 0; } 编译出错：\n1 2 3 4 main.cpp:6:8: error: use of undeclared identifier 'i' cout\u003c\u003ci\u003c\u003cendl; ^ 1 error generated. 包括函数也是不能调用的。\n静态函数和变量的好处就是：\n此函数/变量之存在于本文件，所以其他文件可以定义同名函数和变量而不会冲突 由于此函数/变量只存在于本文件，所以其他文件也没办法使用本函数/变量 extern extern的作用是将变量或者函数“导出”。也就是说变量/函数的声明和实现分离:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //file header.hpp #ifndef __HEADER_HPP__ #define __HEADER_HPP__ extern int i; void incI(){ i++; } #endif //file main.cpp #include \u003ciostream\u003e #include \"header.hpp\" using namespace std; int i=3; int main(){ cout\u003c\u003ci\u003c\u003cendl; incI(); cout\u003c\u003ci\u003c\u003cendl; return 0; } //输出 3 4 可以看到我们是在header.hpp中定义的i，在main.cpp中实现（赋值）的i。所以使用extern关键字的变量不能够直接赋初值，当然extern也不能和static连用。\n函数之所以可以实现和声明分离，就是因为函数其实是默认的extern方式,所以函数需要在头文件中声明。但是如果你在函数前面加上static，那么就不会有extern。\n参考 C语言中extern用法详解 c语言中static 函数和普通函数的区别？\n","description":"","tags":["cpp"],"title":"C/C++中的extern,static","uri":"/posts/c++%E4%B8%AD%E7%9A%84externstatic/"},{"categories":null,"content":"Lua这个语言常常作为游戏引擎的游戏脚本，用于控制人物逻辑。一般Lua在游戏引擎中需要和其他语言进行沟通，而由于Lua是使用纯C写的语言，所以Lua当然也可以和C/C++沟通。\nC++，Lua沟通的方式 C++和Lua沟通的方式其实是在内存中维护一个栈。需要注意的是：栈顶的index是-1，栈底的index是1：\n也就是说，在这个图里你可以通过-3和5来指定同一个元素。\n然后通过一些lua提供的API函数，Lua会将其变量，函数，表等放入栈中，然后C/C++再通过lua的API从栈中提取出来。同样C/C++也可以使用Lua的API将元素放入栈中供Lua使用。也就是说这个栈其实就是一个暂存，用于Lua和C/C++交流的通道。\nC++调用Lua 头文件 首先需要知道要包含的头文件：\nlua.hpp\n这个头文件需要注意一下，如果你打开头文件，会发现里面是：\n1 2 3 4 5 extern \"C\" { #include \"lua.h\" #include \"lualib.h\" #include \"lauxlib.h\" } 其实是包含了三个文件。那么如果你使用的是C语言，就直接包含这三个文件就可以了。\n预备步骤 首先我们有如下的Lua文件：\n1 2 3 4 5 str = \"I am so cool\" tbl = {name = \"shun\", id = 20114442} function add(a,b) return a + b end 首先我们需要初始化一个内存栈来作为交流中介：\n1 lua_State* state = luaL_newstate(); 使用luaL_newstate()函数创建一个栈，栈的结构体就是lua_State*。\n然后需要将Lua文件和这个栈关联起来，不然怎么知道是和哪个Lua文件通信呢：\n1 int luafile = luaL_loadfile(state, \"hello.lua\"); 然后使用lua_pcall()初始化栈（或者说将luafile中的信息记录出来）：\n1 luafile = lua_pcall(state, 0, 0, 0); 以上就是预备步骤了。\n获得数据 接下来需要获得数据。获得数据的方法是使用API让Lua把数据（变量）放入栈中，然后C/C++再获得：\n1 2 3 lua_getglobal(state, \"str\"); if(lua_isstring(state, -1)) cout\u003c\u003clua_tostring(state, -1)\u003c\u003cendl; 首先使用lua_getglobal()获得全局变量str。这个时候Lua就会把变量str的值放入栈中了。接下来使用lua_isstring()函数来判断栈顶元素是不是字符串（第二个参数是栈中元素的index，这里只有一个元素str所以直接在栈顶），如果是，则使用转换函数lua_tostring()来返回这个变量（同样第二个参数也是index）。\n需要注意的是：使用转换函数获得元素值之后是不能自动将这个元素从栈中删除的，想要删除需要使用void lua_remove (lua_State *L, int idx);来移除idx上的值\n也有其他的函数：\nint lua_gettop (lua_State *L); //返回栈顶索引（即栈长度） void lua_settop (lua_State *L, int idx); //设置栈索引 void lua_pushvalue (lua_State *L, int idx);//将idx索引上的值的副本压入栈顶 void lua_insert (lua_State *L, int idx); //弹出栈顶元素，并插入索引idx位置 void lua_replace (lua_State *L, int idx); //弹出栈顶元素，并替换索引idx位置的值 获得表的操作有点麻烦，你需要首先使用lua_getglobal()函数将表放到栈中，然后使用lua_getfield()来将里面的字段放到栈中，然后再从栈里面获得字段值：\n1 2 3 4 5 lua_getglobal(state, \"tbl\"); lua_getfield(state, -1, \"name\"); lua_getfield(state, -2, \"id\"); cout\u003c\u003clua_tostring(state, -2)\u003c\u003cendl; cout\u003c\u003clua_tonumber(state, -1)\u003c\u003cendl; 这里首先使用lua_getglobal()将tbl放在栈顶，然后使用lua_getfield()将tbl中的name属性入栈，再将id入栈，这样栈里面按顺序就是id, name, tbl三个值。所以这里的lua_tostring()作用在-2上。\n调用函数 函数不能够直接通过转换函数，只能直接调用。 首先一样先让Lua将函数放到栈顶：\n1 lua_getglobal(state, \"add\"); 然后你需要将函数要用到的参数压入栈中：\n1 2 lua_pushinteger(state, 2); lua_pushinteger(state, 7); 然后使用函数lua_call();来调用函数：\n1 lua_call(state, 2, 1); 这个函数第二个参数是表示这个函数需要多少个参数，第三个参数是这个函数会返回多少个参数（Lua函数可以返回多参数）。然后Lua就会从栈里面获得参数和函数，然后调用，并且将返回值压入栈：\n1 2 if(lua_isnumber(state, -1)) cout\u003c\u003c\"2+7=\"\u003c\u003clua_tonumber(state, -1)\u003c\u003cendl; 输出当然是2+7=9。\nLua调用C++函数 想要在Lua中调用C/C++函数，我们可以首先将C/C++编译为链接库，然后在Lua中调用。（其实还有一种在C++代码中调用Lua，使用Lua调用C++代码的方法，但是好像没什么用，就不说了）\n首先我们需要编写一个库：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u003clua.hpp\u003e #include \u003ciostream\u003e using namespace std; //由于是C++文件，但是Lua是纯C写的，所以我们需要使用extern \"C\"导出成纯C的编译方式。 extern \"C\" int say(lua_State* L){ const char* str = luaL_checkstring(L, 1); //使用luaL_check\u003ctype\u003e()函数从栈中获得参数 cout\u003c\u003cstr\u003c\u003cendl; return 1; } extern \"C\" int addNum(lua_State* L){ int num1 = luaL_checknumber(L,1); int num2 = luaL_checknumber(L,2); lua_pushnumber(L, num1+num2); //这里将计算的结果作为返回值压入栈中 return 1; } //这个luaL_Reg是用来注册C/C++函数的 const struct luaL_Reg mylibs[]={ //{函数在Lua中的名称， 函数在C/C++中的名称} {\"say\", say}, {\"addNum\", addNum}, {NULL, NULL} //最后一对函数注册是NULL,说明已经到底了没有函数了 }; //这是Lua唯一的库函数获取函数，以luaopen_xxx来命名，在Lua中也要写require xxx extern \"C\" int luaopen_mylib(lua_State* L){ //下面是一系列常规步骤，将函数名称和函数压入栈中 const char* libName = \"mylib\"; luaL_newlib(L,mylibs); lua_pushvalue(L,-1); lua_setglobal(L,libName); return 1; } 然后要生成动态链接库mylib.so：\n1 g++ -bundle -undefined dynamic_lookup -o mylib.so main.cpp `pkg-config --libs --cflags lua ` -std=c++11 然后你就可以在Lua中使用这库了：\n1 2 3 4 5 6 7 8 require \"mylib\" mylib.say(\"hello c++\") mylib.addNum(2,3) --输出: hello c++ 5.0 参考 Lua与C++交互详解 Mac下Lua调用C生成的so文件\n","description":"","tags":["cpp","lua"],"title":"C++和Lua的交互","uri":"/posts/c++%E5%92%8Clua%E7%9A%84%E4%BA%A4%E4%BA%92/"},{"categories":null,"content":"这两天心血来潮，想在此重拾一下单片机。于是从STM32开始。但是以前的单片机开发都是在虚拟机上的Windows环境下使用Keil开发的，现在磁盘空间只有5G了，也没有办法装虚拟机了。。。所以就研究了一下如何在Mac上开发STM32.\n网上有很多方法，比如下载arm-none-eabi-gcc编译器使用Makefile进行工程构建啊，或者直接下载STM32CubeIDE软件来进行构建。但是我最后还是选择了使用vscode来作为开发环境，因为vscode上配置最简单（其实STM32CubeIDE好像也挺简单的，但是那个固件库我死活下不下来。。。）\n使用PlatformIO IDE开发 首先去vscode下搜索PlatformIO IDE这个插件：\n安装好之后左边的快捷栏里面会有一个蚂蚁头的图标，点击之后选择Open就可以打开PlatformIO IDE的界面了：\n然后选择New Project，会弹出对话框让你填入项目名称，开发板和开发板的库：\n点击finish之后就可以开始开发啦，令人惊讶的是居然提供Arduino的库，这样编写起来会方便很多。\n使用ST-Link下载器下载 编写好代码之后就可以开始下载了。我这里使用的是ST-Link下载器下载。\n首先要打开开发板的原理图，找到SWDIO和SWCLK两个端口，然后将ST-Link上的SWCLK和SWDIO链接到对应的位置上，3.3V和GND连接到对应的位置上即可。我这个板子上直接有一个JTag/SW下载口，我就直接用了：\n然后点击vscode中最下方的对勾来编译工程，点击指向右边的箭头来下载程序即可：\n","description":"","tags":["STM32"],"title":"如何在Mac上开发STM32","uri":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E5%BC%80%E5%8F%91stm32/"},{"categories":null,"content":"SDL2以来的，相对于SDL1的一大改变就是添加了SDL_Renderer和SDL_Texture，这两个结构体和对应的函数。这两个结构体用于进行软件加速以便于更快更好地绘制出图形，其使用方法也比SDL_Surface要简单（至少不用底层修改像素来绘制几何图形了）。\n其实SDL_Texture是基于SDL_Surface的，有很多东西都很相似。SDL2较SDL1的优点就是，其SDL_Texture是运行在GPU上的，SDL会视情况使用D3D或OpenGL，效率更高。\n创建 创建SDL_Texture有两种方法：\nSDL_CreateTexture()：直接创建一个Texture SDL_CreateTextureFromSurface()：从一个Surface上创建一个Texture 其实第二个函数底层包含了第一个函数的调用。那么我们就先从第一个函数入手看看如何创建：\n1 2 3 4 5 SDL_Texture* SDL_CreateTexture(SDL_Renderer* renderer, Uint32 format, int access, int w, int h) 首先需要一个SDL_Renderer*，然后需要指定format和access，format就和SDL_Surface的format-\u003eformat成员一样（就是RGB8A888那种），access是Texture新增加的：\nSDL_TEXTUREACCESS_STATIC:很少改变的texture SDL_TEXTUREACCESS_STREAMING:常改变的 SDL_TEXTUREACCESS_TARGET:可以被设置为render的目标的 一般都会使用第三个。 然后就是宽和高了。\n这样就可以得到一个Texture了。\n接下来你可以通过SDL_RenderDrawxxx系列函数在Texture上绘制图形（要先设定为render的目标）。如果你想要从底层走的话有这个函数：\n1 2 3 4 int SDL_UpdateTexture(SDL_Texture* texture, const SDL_Rect* rect, const void* pixels, int pitch) 这里的rect表示需要更新的大小（为NULL更新全部），然后是更新的像素信息pixels和一行的像素个数pitch（以字节计）。 通过上面这个函数，我们也可以将Surface的内容放到Texture上：\n1 2 3 4 5 SDL_Surface* surface = SDL_LoadBMP(\"image.bmp\"); SDL_Texture* texture = SDL_CreateTexture(render, surface-\u003eformat-\u003eformat, SDL_TEXTUREACCESS_TARGET|SDL_TEXTUREACCESS_STATIC, surface-\u003ew, surface-\u003eh); SDL_UpdateTexture(texture, nullptr, surface-\u003epixels, surface-\u003epitch); SDL_FreeSurface(surface); 上面的过程其实和函数SDL_CreateTextureFromSurface()的作用是一样的：\n1 2 SDL_Texture* SDL_CreateTextureFromSurface(SDL_Renderer* renderer, SDL_Surface* surface) 这样就从Surface到Texture了。\n其他函数操作 关于Texture的操作都是很简单的。\n获得Texture信息 首先Texture不能像Surface一样直接获得成员，所以我们有函数来获得信息：\n1 2 3 4 5 int SDL_QueryTexture(SDL_Texture* texture, Uint32* format, int* access, int* w, int* h) format,access,w,h都会以参数形式返回。\n设置渲染方式 如果不将渲染方式设置为Blender方式的话，透明色将不起作用：\n1 2 int SDL_SetRenderDrawBlendMode(SDL_Renderer* renderer, SDL_BlendMode blendMode) 其中blendMode:\nSDL_BLENDMODE_NONE:dstRGBA = srcRGBA SDL_BLENDMODE_BLEND:dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA));dstA = srcA + (dstA * (1-srcA)) SDL_BLENDMODE_ADD:dstRGB = (srcRGB * srcA) + dstRGB;dstA = dstA SDL_BLENDMODE_MOD:dstRGB = srcRGB * dstRGB;dstA = dstA 同样你可以通过SDL_GetRenderDrawBlendMode()函数来获得渲染方式。\n改变颜色和透明度 可以使用\n1 2 int SDL_SetTextureAlphaMod(SDL_Texture* texture, Uint8 alpha) 来设置透明度，当Texture被渲染的时候，会执行这个公式：srcA = srcA * (alpha / 255)。 这个函数可以来让透明度更加显眼。\n同理对RGB也有：\n1 2 3 4 int SDL_SetTextureColorMod(SDL_Texture* texture, Uint8 r, Uint8 g, Uint8 b) 计算公式如出一辙：srcC = srcC * (color / 255)\n这个函数可以帮助你凸显RGB三分量中的一种，比如我可以将r设置为255，将g和b设置为0: ","description":"","tags":["SDL2"],"title":"SDL2-Texture","uri":"/posts/sdl-texture/"},{"categories":null,"content":"SDL_Surface是用于存储图像，可以用于图像绘制的结构体。 这里我们来看一下SDL2中的SDL_Surface结构体和与其有关的函数操作。\nSDL_Surface结构体 其实操作SDL_Surface的函数有很多，而且都很简单。但是如果不先认识SDL_Surface这个结构体的话，函数上的学习会比较困难。\n1 2 3 4 5 6 7 8 9 10 typedef struct{ SDL_PixelFormat* format; //存储着和像素有关的格式 read-only int w; //图像宽度 read-only int h; //图像高度 read-only int pitch; //pixels中一行有多少个像素（以Bytes计） read-only void* pixels; //实际的像素数据 read-write void* userdata; //用户数据，用户可以自己随意存储，读取 read-write SDL_Rect clip_rect; //裁切矩形 read-only int refcount; //引用计数，一般由SDL函数自己改变 }SDL_Surface; 本来还有Uint32 flags,int locked, void* locked_data, SDL_BlitMap* map四个属性的，但是这四个属性是SDL内部使用的，所以我们就不去在意了。\n接下来对上面列出的每一个属性进行详细的解释。\nformat format属性存储着像素有关的格式，是一个很重要的结构体：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 typedef struct{ Uint32 format; //这个说明了像素在内存中存储的方式 SDL_Palette* palette; //调色板（如果没有是NULL） Uint8 BitsPerPixel; //每一个像素使用多少个Bit存储 Uint8 BytesPerPixel; //每个像素使用多少个Byte存储 Uint32 Rmask; //R分量的掩码 Uint32 Gmask; //G分量的掩码 Uint32 Bmask; //A分量的掩码 Uint32 Amask; //B分量的掩码 //下面都是内部使用属性 Uint8 Rloss; Uint8 Gloss; Uint8 Bloss; Uint8 Aloss; Uint8 Rshift; Uint8 Gshift; Uint8 Bshift; Uint8 Ashift; int Refcount; SDL_PixelFormat* next; }SDL_PixelFormat; 有一些内部属性还是有用的，如果会用到的话我会说。\nformat 首先是format属性，他的值是SDL_PixelFormatEnum枚举类型里面的一个。看了这个枚举类型相信你就知道这个属性是做什么的了，完整的在这里：\nSDL_PIXELFORMAT_RGB332 SDL_PIXELFORMAT_ARGB4444 SDL_PIXELFORMAT_RGBA8888 SDL_PIXELFORMAT_UYVY 没错这一个个枚举常量就是表示像素点在内存中的存储方式，比如我们最熟悉的SDL_PIXELFORMAT_RGBA8888就是表示本像素有四个分量R,G,B,A，并且这四个分量的存储顺序是RGBA，每个分量占8Bits。那么以此类推，SDL_PIXELFORMAT_ABGR8888就是A分量在最前面存储，R分量在最后存储。SDL_PIXELFORMAT_RGB332就是只有三个分量R，G，B，并且R占3Bits，G占3Bits，B占2Bits。 YUV颜色空间同理。\n这里还有比较特殊的SDL_PIXELFORMAT_INDEX8，其实这个是指只有RGB三分量，每个分量8位的存储方式，如果有对应的枚举类型的话应该命名为SDL_PIXELFORMAT_RGB888。\n如果你想要以人类可读的方式查看自己的surface是怎么存储图像的话，这里有一个const char* SDL_GetPixelFormatName(Uint32 format)函数，你可以把format放进去，他会返回给你一个和枚举类型一模一样名称的字符串。\npalette 这个是调色板，也是一个枚举类型：\n1 2 3 4 typedef struct{ int ncolors; //指出调色板里面有多少颜色 SDL_Color* colors; //颜色数组 }SDL_Palette; 调色板有说明用呢？这里还得说一下位图的存储方式。需要注意的是：SDL_Surface本身只能存储位图数据（因为其官方只给了SDL_LoadBMP()函数来加载位图，而没有函数去加载其他格式的图片），虽然有SDL_Image库，但那是第三方的不算在讨论范围内，所以我们首先得搞清楚调色板在位图中的用途。\n调色板在位图中的用途 位图里面也有一个称为调色板的东西，和SDL_Surface里面的很像，具体作用是这样的： 首先位图中每个像素可以由8Bits, 16Bits, 32Bits, 64Bits等长度的位存储。其中小于24位的位图需要调色板，大于等于24位的位图没有调色板（所以如果你的Surface-\u003eBitsPerPixel\u003e=24的话palette属性就是NULL）。之所以有调色板是为了减少存储空间设计的。\n在我们的印象中，图片应该是这样存储的（假设以RGB888格式存储）：\n这也是OpenCV这种库存储的方式：以R，G，B三种分量值的循环来存储。\n对于BitsPerPixels\u003e=24的位图的确是这样存储的，但是这样存储的话每个像素点就要花费$24(或者更多)*3=72bits$。那么计算机科学家就想出，能不能有一种方法在不减少像素的情况下存储少量的数据。这个方法就是调色板。\n调色板中记录了这个图片中所有要用到的颜色（对于256色位图，就会记录256色），这也就是ncolors属性的作用。然后会将所有属性以RGBxxx(例子里面是RGB888)的方式存储在colors属性中。 然后原本的像素就不再以RGB888方式存储了，其会存储一个索引，这个索引指向colors属性中的颜色：\n这样本来一个像素点需要3*8=24位的，现在只要8位就OK了，虽然加了调色板，但是每个像素减少了3倍大小。\n所以：如果像素以24位一下存储，像素存储的是其值在调色板中的索引，如果以24位以上（包括24位）存储那么直接存储颜色数据，没有调色板\nBitsPerPixel,BytesPerPixel 这两个属性就是表示像素点以多大的内存空间存储。\n掩码 掩码的话是这样的：\n如果是带有调色板的位图（24位以下），那么掩码默认为0（因为颜色值都存储在调色板中了） 如果是没有调色板的位图，那么如果想要得到其像素点存储的颜色值，需要先和掩码做逻辑和运算。以RGBA8888格式为例：假设一个像素点的值是0xEA124256，想要取出来R分量，首先和Rmask（这里是0xFF000000）做逻辑和，得到0xEA000000，然后就需要用到一些内部属性了：再将结果右移Rshift，再左移Rloss长度即可得到最后的值。也就是说整个过程可以这样写： 1 temp = pixel \u0026 fmt-\u003eRmask; temp = temp \u003e\u003e fmt-\u003eRshift; temp = temp \u003c\u003c fmt-\u003eRloss; red = (Uint8)temp; ```\n宽度和高度 这个没什么好说的，就是图像的宽度和高度。\npitch 这个值保存着一行有多少个像素（以Bytes计），比如你的图像是RGB888存储的，假设pitch=24，由于是24位以下的位图，所以每个像素用8位保存，也就是每个像素用1Byte保存，那么一行就是24个像素。\n因为图像虽然显示是二维的，但是在内存中保存是一维的，所以必须知道一行存储了多少像素我们才能遍历整个点。\npixels 这个就是实际存储像素值的数组，24位以下存储调色板索引，24位以上直接存值\nuserdata 这个用户可以自己随意放入数据或者读取数据，默认为NULL。\nclip_rect 这个是在你使用SDL_BlitSurface()这样的绘图函数时，指定实际会绘制到目的地的图像范围。 可以使用SDL_SetClipRect()来改变，默认为全部图片.\nrefcount 这个是引用计数，是SDL函数在对Surface操作的时候会设置，我们不用关心。\n对SDL_Surface结构体的操作 接下来要展示以下如何对RGB888存储的SDL_Surface进行操作。我们会在上面绘制一条线，并且将绘制了线的图像保存下来。\n首先我们要有一个符合格式的位图：\n然后我们开始操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u003cSDL2/SDL.h\u003e #include \u003ciostream\u003e using namespace std; int main(int argc, char** argv){ SDL_Init(SDL_INIT_EVERYTHING); SDL_Surface* img = SDL_LoadBMP(\"./1.bmp\"); //这里判断图片是不是加载成功，以及是不是8位的 if(!img || img-\u003eformat-\u003eBitsPerPixel!=8){ cerr\u003c\u003c\"load 8 bits image failed\"\u003c\u003cendl; return -1; } //这里创造一个和原图像一样格式的surface SDL_Surface* surface = SDL_CreateRGBSurface(img-\u003eformat-\u003eformat, img-\u003ew, img-\u003eh, 8, 0, 0, 0, 0); if(!surface){ cerr\u003c\u003c\"create surface failed\"\u003c\u003cendl; return -1; } //这里将原图像的调色板赋值给surface，不然我们的surface没有调色板没办法绘图 SDL_SetSurfacePalette(surface, img-\u003eformat-\u003epalette); //接下来的循环遍历img中的所有点，一一赋值给surface，并且在行列相等的时候改变颜色索引 for(int i=0;i\u003cimg-\u003ew;i++){ for(int j=0;j\u003cimg-\u003eh;j++){ Uint8 index = *((Uint8*)img-\u003epixels + j*img-\u003epitch + i); //这里由于是8位存储，所以要转换为Uint8 if(i!=j) *((Uint8*)surface-\u003epixels + j*surface-\u003epitch + i) = index; else *((Uint8*)surface-\u003epixels + j*surface-\u003epitch +i) = 20; //改变颜色索引 } } //调用函数保存图像 SDL_SaveBMP(surface, \"result.bmp\"); //释放图像 SDL_FreeSurface(img); SDL_FreeSurface(surface); SDL_Quit(); return 0; } 最后保存的图像是：\n","description":"","tags":["SDL2"],"title":"SDL2-Surface结构体详解","uri":"/posts/sdl-surface%E7%BB%93%E6%9E%84%E4%BD%93%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"SDL2中想要展示对话框有两种办法：使用SDL_ShowSimpleMessageBox()来显示一个简单的对话框，或者使用SDL_ShowMessageBox()来显示一个自定义对话框。 SDL2中只能展示模态对话框（就是如果你不点掉它你原本的窗体就不会有响应的对话框）。\nSDL_ShowSimpleMessageBox() 1 2 3 4 int SDL_ShowSimpleMessageBox(Uint32 flags, const char* title, const char* message, SDL_Window* window) flag：是一个SDL_MessageBoxFlags枚举类型，可以是SDL_MESSAGEBOX_ERROR, SDL_MESSAGEBOX_WARNING, SDL_MESSAGEBOX_INFORMATION其中的一个，用于表示错误信息，警告信息和普通信息（相应的对话框icon和按钮也会改变） title：UTF-8的对话框标题 message：UTF-8的对话框内容 window：对话框所属的父窗体 这个函数很简单，没什么其他可说的。也是为了简单产生一个对话框。\n需要注意的是：这个函数在使用SDL_Init()函数之前就可以使用了，也就是说你可以使用这个函数来显示初始化SDL或者OpenGL是否成功\nSDL_ShowMessageBox() 1 2 int SDL_ShowMessageBox(const SDL_MessageBoxData* messageboxdata, int* buttonid) 这个函数可以让你自己定义对话框，其中buttonid参数会存储最后按下的按钮的id。 这里主要需要介绍的结构体就是SDL_MessageBoxData:\n1 2 3 4 5 6 7 8 9 typedef struct{ Uint32 flags; //就是上面说的SDL_MessageBoxFlags枚举类型 SDL_Window* window; //父窗口，可以是NULL const char* title; //标题 const char* message; //内容 int numbuttons; //按钮的个数 const SDL_MessageBoxButtonData* buttons; //按钮的信息 const SDL_MessageBoxColorScheme* colorScheme;//对话框颜色的信息 }SDL_MessageBoxData; 这里其他的都比较好理解，想要对对话框进行自定义主要还是SDL_MessageBoxButtonData和SDL_MessageBoxColorScheme两个结构体：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 SDL_MessageBoxButtonData typedef struct{ Uint32 flag; //是0(没有特殊含义)，SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT(按下回车等于按 下这个按钮),SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT(按下ESC键等于按下这个按钮) int buttonid; //此按钮的ID，调用函数之后会返回按下按钮的id const char* text; //按钮上的文字 }SDL_MessageBoxButtonData; typedef SDL_MessageBoxColorScheme SDL_MessageBoxColor[5]; //没错它是另一个结构体数组的别名。。。 //这个结构体就是存储颜色的结构体，只不过专门用在对话框函数上 typedef struct{ Uint8 r; Uint8 g; Uint8 b; }SDL_MessageBoxColor; 这里需要说明一下的是SDL_MessageBoxColorScheme类型，这个类型其实就是一个包含5个SDL_MessageBoxColor元素的数组。而每一个SDL_MessageBoxColor又是存储颜色的结构体。那么这5个SDL_MessageBoxColor分别代表什么呢？看下方：\n1 2 3 4 5 [0]:SDL_MESSAGEBOX_COLOR_BACKGROUND [1]:SDL_MESSAGEBOX_COLOR_TEXT [2]:SDL_MESSAGEBOX_COLOR_BUTTON_BORDER [3]:SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND [4]:SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED 没错分别是背景颜色，文本颜色，按钮框颜色，按钮背景颜色，按钮按下颜色五个颜色。 所以你到时候自定义就需要按照这五个值的顺序来定义颜色了。\n需要注意的是：你也可以给SDL_MessageBoxColorScheme*成员赋值NULL，这样系统会采用默认配色。而且有些系统是不能够改变配色的（比如说我的Mac。。。）\n这里就给一个官方的例子吧，比较清晰明了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \"SDL.h\" int main(int argc, char *argv[]) { //设置按钮 const SDL_MessageBoxButtonData buttons[] = { { /* .flags, .buttonid, .text */ 0, 0, \"no\" }, { SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT, 1, \"yes\" }, { SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT, 2, \"cancel\" }, }; //设置对话框颜色 const SDL_MessageBoxColorScheme colorScheme = { { /* .colors (.r, .g, .b) */ /* [SDL_MESSAGEBOX_COLOR_BACKGROUND] */ { 255, 0, 0 }, /* [SDL_MESSAGEBOX_COLOR_TEXT] */ { 0, 255, 0 }, /* [SDL_MESSAGEBOX_COLOR_BUTTON_BORDER] */ { 255, 255, 0 }, /* [SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND] */ { 0, 0, 255 }, /* [SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED] */ { 255, 0, 255 } } }; //填充SDL_MessageBoxData结构体 const SDL_MessageBoxData messageboxdata = { SDL_MESSAGEBOX_INFORMATION, /* .flags */ NULL, /* .window */ \"example message box\", /* .title */ \"select a button\", /* .message */ SDL_arraysize(buttons), /* .numbuttons */ buttons, /* .buttons */ \u0026colorScheme /* .colorScheme */ }; int buttonid; //调用函数 if (SDL_ShowMessageBox(\u0026messageboxdata, \u0026buttonid) \u003c 0) { SDL_Log(\"error displaying message box\"); return 1; } if (buttonid == -1) { SDL_Log(\"no selection\"); } else { SDL_Log(\"selection was %s\", buttons[buttonid].text); } return 0; } ","description":"","tags":["SDL2"],"title":"SDL2-模态对话框","uri":"/posts/sdl2-%E5%AF%B9%E8%AF%9D%E6%A1%86/"},{"categories":null,"content":"日历时间 日历时间就是从Epoch开始计时的时间，以自从Epoch以来的秒数来定义的。Epoch时间也就是格林威治时间（1900年1月1日零点，又称为UTC时间）。\n在Linux系统中，存储时间秒数的都是time_t系统类型。\n获得日历时间 首先是包含在sys/time.h中的\n1 int gettimeofday(struct timeval* tv,struct timezone *tz); 第一个参数是一个timeval结构体：\n1 2 3 4 struct timeval{ time_t tv_sec; suseconds_t tv_usec; }; 用于存储时间。tc_sec成员用于存储自Epoch的秒数，tv_usec则指出在这个秒数上离现在时间还多出多少微秒。也就是说如果将时间全部换算乘秒数，那么有： $$ nowtime = time_{1900-1-1\\ 0:0:0} + tc_sec + tv_usec $$ 第二个参数是废弃的，总是应该是NULL。\n或者使用更加直接粗暴的函数time()，这个函数也是个常用函数，用于返回从Epoch到现在的时间。\n需要注意的是，time()函数如果你给了一个参数time_t* timeep，那么秒数会保存到timeep中。如果你给NULL，那么会直接返回秒数（出错返回-1）。但是因为返回值更好用，所以我们一般都是直接将参数传为NULL。\n将time_t转化为人话 因为time_t是自从Epoch的秒数，所以阅读起来很费劲。我们可以通过下面这个函数让其通俗易懂一点：\n1 char* ctime(const time_t* timep);\t//给入一个timep，返回一个可读的字符串（包含换行符），返回的值是静态分配的 time_t和分解时间的转换 由于time_t比较难表示具体的年月日，所以有了tm结构体：\n1 2 3 struct tm{ int tm_sec,tm_min,tm_hour,tm_mday,tm_mon,tm_year,tm_wday,tm_yday,tm_isdst\t//这里简写了，看的懂就行了 }; 参数意思一目了然，不解释。\n可以通过\n1 2 3 struct tm* gmtime(const time_t* timep) //将日历时间转换为对应于UTC时间的tm struct tm* gmtime(const time_t* timep)\t//将日历时间转换为当地时间 time_t mktime(struct tm* timeptr)\t//将tm转化为日历时间 分解时间和人话之间的转换 接下来是分解时间和打印时间的转换：\n1 2 3 char* asctime(const struct tm* timptr) size_t strftime(char* outstr, size_t maxsize, const char* format, const struct tm* timeptr)\t//outstr:要返回的打印时间的缓冲区。maxsize:outstr的大小。format是相当于printf函数的格式化字符串。返回最后打印时间在outstr中所占的大小。 char* strptime(const char* str,const char* format, struct tm* timeptr);\t//strftime的逆函数 这里strftime()函数其实就是日期打印版本的sprintf()\n时区 Linux所有的时区都是放在文件中管理的，在/usr/share/zoneinfo文件夹下。比如日本的Japan文件和香港的Hongkong文件\n如果想要修改时区的话，需要修改环境变量TZ（你完全可以用setenv等函数改变）。不敢过TZ的改变是有格式的：使用冒号开头，后面是基路径为/usr/share/zoneinfo的时区文件路径，路径分隔符用冒号代替。比如/usr/share/zoneinfo/Asia/Hovd（Hovd时区），那么你就要写:Asia:Hovd。如果是不在文件夹里面的时区（比如Hongkong），那么直接:Hongkong即可。\n更新系统时钟 你可以通过下面两个函数更新系统时钟：\n1 2 int settimeofday(const struct timeval* tv, const struct timezone* tz)//没错是gettimeofday的逆函数 int adjtime(struct timeval* delta, struct timeval* oldtime)//delta指定需要改变的秒和微妙，系统会自我调整 其中settimeofday是大调整（一般不会用到），adjtime()是小调整。\n进程时间 进程时间是值进程创建之后使用的CPU数量。有如下函数获得：\n1 2 3 4 5 6 7 8 9 clock_t times(struct tms* buf); struct tms{ clock_t tms_utime; clock_t tms_stime; clock_t tms_cutime; clock_t tms_cutime; }; clock_t clock(); 一般使用clock()函数居多，用于检测算法的运行时间。\n","description":"","tags":["Linux"],"title":"《Linux/Unix系统编程手册》时间","uri":"/posts/linux-unix%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C%E6%97%B6%E9%97%B4/"},{"categories":null,"content":"进程和程序 首先要区分一下进程和程序\n进程：进程是内核定义的抽象的实体，包含用以执行程序的各种资源 程序：程序是文件，里面存放的信息告诉内核如何创建一个进程 也就是说，程序其实和进程不是一个概念。程序是一个用以描述进程的文件，包括\n二进制文件标识：描述进程的元信息，现在的Linux系统一般都是ELF格式 机器语言指令：也就是代码，将要存放在汇编语言中的.text段中 程序入口地址：也就是对应汇编中的_start标号地址 符号表和重定位表：描述函数和变量的位置和名称，将要存放于.data .bbs段中 共享库和动态链接信息：记录了链接库的信息 其他信息 进程号和父进程号 使用\n1 pid_t getpid() 获得当前进程号，使用\n1 pid_t getppid() 获得当前进程的父进程号。\n注意这两个函数都一定会执行成功，总是返回0\n所有的进程都是由init进程（进程号为1）的父进程创建的。\n进程的内存布局 当内核打开一个程序的时候，会自动创建一个进程，进程包含的内容其实在Unix汇编中以及提到过了：\n文本段.text 初始化数据段.data 未初始化数据段.bbs 栈 堆：运行时动态为变量分配的内存空间 虚拟内存 虚拟内存会将程序使用的内存切割成小型的，固定大小的“页”。相应的会将RAM以页为单位分割。同一时刻只有部分内存放在页中，其他不用的内存放在交换区中（也就是磁盘上).这样就会导致程序使用的内存甚至超出了RAM的大小（多出的部分放在交换区中）。\n栈和栈帧 函数调用和返回会在栈上新增加一个栈帧（里面存放着参数等信息），当函数调用完毕之后会将栈帧从栈上移除。\n命令行参数小技巧 我们都知道C语言里面有argc, **argv两个命令行参数，而且argv[0]总是程序的名称，这里有一个小技巧（也是gzip,gunzip,zcat使用的）：通过文件名称来让同一个程序执行不同的操作。\n因为连接档运行之后argv[0]的名称也是连接档的，所以我们可以写类似下面的程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u003cstdio.h\u003e void gzipfunc(){ //... } void gunzipfunc(){ //... } void zcatfunc(){ //... } int main(int argc, char** argv){ if(strcmp(argv[0], \"gzip\")==0) gzipfunc(); else if(strcmp(argv[0], \"gunzip\")==0) gunzipfunc(); else if(strcmp(argv[0], \"zcat\")==0) zcatfunc(); return 0; } 没错可以根据不同的名称执行不同的功能，但是最后其实都是一个程序哦，只不过其他的不同名的程序是连接档罢了。\n环境列表 环境列表其实就是存储环境变量的列表啦。只不过里面的环境变量都是以变量名=变量值来定义的。\n子进程会将父进程的环境列表拷贝一份，这也就是为什么终端需要一个.bashrc .profile这种文件来存放环境变量的原因了，通过终端打开的程序都会获得终端的环境列表的一份拷贝，这也是进程之间传递信息的一种方式。\n从程序中访问环境列表 通过environ变量 C中提供了全局变量environ存储着本进程的环境列表,他是一个char**类型的，最后以NULL结尾的列表。\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003cstdlib.h\u003e #include \u003cerrno.h\u003e extern char** environ; int main(int argc, char** argv){ printf(\"10 environ variables in enviroment list:\\n\"); for(;i\u003c10\u0026\u0026environ[i]!=NULL;i++) printf(\"%s\\n\", environ[i]); return 0; } 结果：\n1 2 3 4 5 6 7 8 9 10 11 10 environ variables in enviroment list: PATH=/home/visualgmq/bin:/home/visualgmq/.local/bin:/usr/local/Trolltech/Qt-4.8.7/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin XDG_VTNR=7 MANPATH=/usr/local/Trolltech/Qt-4.8.7/man: XDG_SESSION_ID=c1 CLUTTER_IM_MODULE=xim XDG_GREETER_DATA_DIR=/var/lib/lightdm-data/visualgmq SHELL=/usr/bin/zsh QT_LINUX_ACCESSIBILITY_ALWAYS_ON=1 QTDIR=/usr/local/Trolltech/Qt-4.8.7 GTK_MODULES=gail:atk-bridge:unity-gtk-module 这里只输出了前10个环境变量。\n或者通过增加main函数的参数来直接获得!\n1 2 3 int main(int argc, char** argv, char* envs[]){ //... } 通过函数获得或修改 获得 可以通过char *getenv(const char* name)函数获得环境变量，参数是环境变量的名称，返回对应的值。\n注意：\n程序不应该修改此函数返回的值 允许使用静态分配的缓冲区返回结果 修改 通过\n1 2 int putenv(char* string)\t//失败返回0 int setenv(const char* env, const char* value, int overwrite)\t//失败返回-1 来修改环境变量\nputenv()通过写入name=value形式来创建变量。如果变量存在会覆盖。\n需要注意的是，函数不会拷贝参数，也就是说string参数后续改变会影响到环境变量，所以不应该是使用在栈上分配的字符串数组作为参数（一旦被改变会引起逻辑错误）。\nsetenv()不需要在env,value参数之间加上=，通过overwrite参数指定如果变量存在是否覆盖（0不覆盖，非0覆盖）\n清除 使用\n1 int clearenv(); 函数即可，其实内部就是environ=NULL语句。\n非局部跳转 需要引用setjmp.h\n非局部跳转就是从一个函数跳到另一个函数。其实在函数内部跳转已经有goto语句了。同goto语句一样，非局部跳转语句不提倡被使用（其实我自从离开了C语言教程之后还真没见过代码里面有goto的。。。）\n执行非局部跳转的话，首先你得有一个变量来保存跳转之前的状态，方便跳转之后返回原点，这个变量的类型是jmp_buf。\n然后需要跳转函数，int setjmp(jmp_buf env)函数将env传入进去保存当前的程序信息，以便于跳转。int longjmmp(jmp_buf env, int val)函数会依据env参数保存的信息跳转回去，并且让对应的setjmp函数返回val值。\n这里尤其需要注意一下setjmp函数的返回值。当你使用setjmp函数之后如果返回0代表成功了，然后此时的程序信息保存在env变量中。接下来如果你执行了longjmp(env, value)函数，那么会跳转回setjmp函数处，兵器setjmp函数会再次返回，返回值为longjmp指定的value。\n也就是说，value参数其实是为了方便程序员从setjmp函数处判断是哪个函数跳转回来的。\n例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003csetjmp.h\u003e jmp_buf env; void f2(){ longjmp(env, 2); //跳回17行 } void f1(){ longjmp(env, 1); //跳回17行 f2(); } int main(int argc, char** argv){ int ret = setjmp(env); switch(ret){ case 0: printf(\"called setjmp()\\n\"); f1(); break; case 1: printf(\"jumped to f1()\\n\"); break; case 2: printf(\"jumped to f2()\\n\"); break; } return 0; } 这里首先调用了setjmp然后对返回值判断，第一次setjmp返回0代表成功了，那么我们就进入case 0调用f1()函数。在f1()函数中执行了longjmp()函数跳转回setjmp处，这个时候setjmp会返回1,于是输出jumped to f1()。由于f2()的调用在longjmp下面，所以函数跳转回去并没有执行f2()\n1 2 called setjmp() jumped to f1() ","description":"","tags":["Linux"],"title":"《Linux/Unix系统编程手册》进程和程序","uri":"/posts/linux-unix%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C%E8%BF%9B%E7%A8%8B/"},{"categories":null,"content":"动态内存的底层表示 当我们使用malloc和free函数在内存中开辟新内存的时候，我们究竟是改变了什么呢？其实在内存中有一个program break，这个玩意儿是堆的边界。如果有新的内存被开辟了，这个指针_可能_会移动。\n开辟内存的函数 最底层的函数 首先是最底层的两个函数：\n1 2 int brk(void* end_data_segment); void* sbrk(intptr_t increment); brk()函数会将program break的位置设置为参数的位置，从而自动开辟内存。\nsbrk()函数需要指定一个偏移量，program break的位置会跟随这个偏移量偏移。\nC函数 malloc和free C的函数就是malloc和free了。但是我们还是得了解一下这两个函数的工作原理：\n首先malloc首先按会扫描program break内空白的部分，如果空白的部分大于分配内存，那么就将空白部分切片并且返回分配内存的内存地址;如果刚好合适就返回内存地址;如果没有合适大小的内存就移动program break来扩大堆大小。需要注意的是：\n其不仅会分配内存，还会在内存的前几个字节的地方记录分配内存的大小。 扩大堆的大小是按照页的大小来的，而不是按照分配内存大小来的（多分配一点防止下次还要分配） 而free函数的做法则是这样：\n首先free函数有一个空闲列表来以链表的方式存放空闲的内存（放在本身空闲的内存中），当调用free的时候会在列表中查找以便快速找到要删除的内存。\n其他函数 其他函数还有calloc(), realloc()等\n注意alloc()函数的用法虽然和malloc()很像，但是却不是在堆上分配的内存，而是通过增加帧栈的方式在堆栈上分配内存。所以使用alloc()函数分配的内存不能够（也不应该）使用free()函数消除。由于是在帧栈上分配内存，所以你不应该使用alloc()函数分配全局变量。\nalloc分配内存比较快，而且其分配的内存可以随着帧栈的移除而自动释放。\nalloc函数在alloca.h头文件中\n","description":"","tags":["Linux"],"title":"《Linux/Unix系统编程手册》内存分配","uri":"/posts/linux-unix%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"categories":null,"content":"文件IO IO有很多种，其中文件IO最为重要，因为Unix系统中所有的东西都可以被视为文件，所以必须要先学会如何对文件进行操作。\n打开文件open 这个函数在fcntl.h中\nopen()系统调用用于打开文件，既可以打开已经存在的文件也可以在文件不存在时创建。最神奇的时他可以在只读模式下创建文件！\n1 int open(const char* pathname, int flags, .../*mode_t mode*/) 第一个参数是要打开的文件名称（其实也可以是文件夹，管道啊等等） 第二个参数是打开的方式： 后面的可选参数是用来指定文件权限的，这里先不说 可以看出flag被分为了三种：\n第一部分是文件访问模式标志，也就是指定打开文件是以读写哪种方式 第二部分是文件创建标志 第三部分是已打开文件的状态标志 这里需要注意的是：文件访问模式标志一次只能用一个，不能通过逻辑或放在一起使用（可以和其他种类的flag逻辑或），因为O_RDONLY,O_WRONLY,O_RDWR的值分别是0，1，2，所以或了之后会发生逻辑错误。\n而且正是因为有了O_CREAT标志，让我们可以在读模式下创建文件：O_RDONLY|O_CREAT（注意这里O_CREAT不是O_CREATE）\n注意open函数返回一个_文件描述符_（这里不被称为句柄啊什么的）\ncreate函数 在很老的版本中是没有O_CREAT标志的，想要创建文件必须先用create系统调用。\n1 int create(const char* pathname, mode_t mode) 读写文件内容read/write 这两个函数在unistd.h中\n这个很简单，和C语言的fread(), fwrite()差不多，看一下原型应该就知道怎么用了：\n1 2 ssize_t read(int fd, void* buffer, size_t count); //返回读取的字节 ssize_t write(int fd, void* buffer, size_t count); //返回写入的字节 关闭文件close 这个函数在unistd.h中\n这个也简单:\n1 int close(int fd) 改变文件偏移量lseek 也就是移动文件指针啦，使用lseek函数：\n1 off_t lseek(int fd, off_t offset, int whence) //返回当前指针位置 第二个参数是偏移量 第三个参数取值如下： SEEK_SET相对于文件头 SEEK_CUR相对于当前位置 SEEK_END相对于最后 文件空洞 值得注意的是：就算lseek将偏移量移动到文件末尾后面去了，write函数照样可以写入。那么文件结尾到write函数写之间空出的这块地方被称为文件空洞。文件空洞不占用任何磁盘空间，只是名义上文件变大了（如果你用ll命令查看的话），如果下次写入在文件空洞内，那么kernel才会为其分配存储单元，也就是说你会看到文件没有变大，但是磁盘空间变小的奇特情况。 在大多Unix系统下内存以块分配（通常是1024倍数），如果文件空洞大小落在块边界，那么不会分配，但是如果落在块内，那么会直接分配内存，多出来的地方用0代替。\n","description":"","tags":["Linux"],"title":"《Linux/Unix系统编程手册》文件IO","uri":"/posts/linux-unix%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C%E6%96%87%E4%BB%B6io/"},{"categories":null,"content":"kernel kernel（核）是Unix操作系统内提供服务的东西，所有的进程想要完成什么操作都必须对kernel进行申请。\n系统调用和C库函数 kernel直接提供的操作被称为系统调用（System Call），比如后面说的open, close, read等函数。 像C语言的fopen,fclose等函数就不是系统调用，我们称这种函数为C库函数，是在系统调用之上进行封装的函数。\n所有的系统调用都是原子操作。也就是说所有的系统调用在线程中都是安全的，不可被分割的。这对于多线程编程来说至关重要，需要牢记。这也就是为什么在多线程中广泛使用系统调用而不是C库函数。 但是系统调用由于需要内核的处理，所以效率比较低，占用资源比较多。\n错误处理 由于Linux/Unix操作系统是使用C语言编写的，所以其库函数也没有什么异常之类的，都是使用返回值来捕捉异常。对于异常捕捉有如下几点：\n对于系统调用 大多数函数如果出错的话会返回-1 有一些函数是一定会成功的，比如用于返回当前线程id的getpid() 有一些系统调用即使成功了也会返回-1 对于C库函数调用 具体函数具体对待 对于系统调用，在sys/errno.h文件中有一个errno变量，每当系统调用出错的时候，会将errno变量设为一个正常数（比如EINTR之类的，以E打头）来表示出现的错误类型。但是当系统调用成功的时候却不会重置为0，所以在对某个操作进行错误判断的时候要手动将errno置0，然后待系统调用完成之后再查看errno的值。这也是检查系统调用是否出错的最可靠最通用的方法。\nC还提供了一些位于stdio.h中的库函数，通过errno变量来进行错误处理：\nint perror(const char* msg)用于在errno!=0的时候打印出msg和errno值对应的错误 char* strerror(int errnum)需要将错误号传入，然后会返回对应的错误描述字符串。这里的返回值是静态的，不能只给一个指针。 系统类型 Unix编程的时候会看到很多如size_t,time_t,gid_t这种系统使用typedef定义的类型。之所以定义这些类型，是为了兼容性。如果你都使用int的话，假设在A系统上int是32位， B系统上int是18位的，那么你的程序就可能因为int长度的原因出错。所以Unix在必要的时候会返回用typedef定义的系统类型，不同的系统中会有不同的定义（比如32位A系统是typedef unsigned char size_t，16位B系统是typedef int size_t)\n其他的可移植问题 对于协同结构体如\n1 2 3 4 5 struct sembuf{ unsigned short sem_num; short sem_op; short sem_flg; }; 在初始化的时候不要用列表初始化方式：\n1 struct sembuf sem={32,1,0}; 而要用一位一位的方式初始化：\n1 2 3 4 strucy sembuf sem; sem.sem_num = 32; sem.sem_op = 1; sem.sem_flg = 0; 因为在不同的Unix系列系统中同一个结构体的成员顺序不一定一样，比如在B系统中可能是\n1 2 3 4 5 struct sembuf{ unsigned short sem_num; short sem_flg; short sem_op; }; 如果用列表初始化就吧1赋值给sem_flg了。\n","description":"","tags":["Linux"],"title":"《Linux/Unix系统编程手册》编程注意事项","uri":"/posts/linux-unix%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C%E7%BC%96%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"categories":null,"content":"强枚举类型是C++11新增加的功能。其实强枚举类型和Java中的枚举类型有点像：\n不能够隐式转换为整数转换 并且还有比较新的特性：\n可以指定底层数据类型。原本所有的enum底层都是int类型，但是现在你可以指定除了wchar_t类型之外的所有整型类型作为底层数据了。 获得枚举常量必须通过::来获得 比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u003ciostream\u003e using namespace std; enum class Type{ TYPEA = 1, TYPEB, TYPEC }; enum class Class: unsigned char{ CLASSA=2, CLASSB, CLASSC }; int main(){ Type type = Type::TYPEA, type2 = Type::TYPEB; int value = int(type); type = Type(2); //cout\u003c\u003ctype\u003c\u003cendl; //int value = type; //Class c = CLASSA; Class c = Class::CLASSA; cout\u003c\u003c(type\u003ctype2)\u003c\u003cendl; return 0; } 这里直接输出type是不行的，因为以往的非强类型都是隐式转换为整型再输出的。也不能直接赋值给整型。但是可以使用强制转换再整型和强枚举之间转换。 可以看到Class c = CLASSA;也是不行的，只能通过域解析符来获得，加强了作用域。\n其实强枚举类型的底层不再是int，而是类。也就是说强枚举类型其实是用类实现的，要不然怎么叫enum class呢。\n","description":"","tags":["cpp"],"title":"C++强枚举类型","uri":"/posts/c++%E5%BC%BA%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"这是学习Makefile的总结\n目标 Makefile的目标名称不是随便取的：\n1 2 3 4 5 6 exe:main.o g++ main.o -std=c++11 main.o:defs.h .PHONY:clean clean: -rm *.o exe 这里如果你第二个目标不是main.o的话，那么后面是没有办法自动推导出main.cpp和g++ -c main.cpp这种的。\nmake总是执行第一个目标，然后根据依赖来执行其他目标。\n伪目标 伪目标跟在.PHONY后面，用于执行一些指令：\n1 2 3 .PHONY:clean clean: -rm *.o exe .PHONY后面也可以是多个伪目标，伪目标也可以有依赖项：\n1 2 3 4 5 6 7 8 9 10 main:main.o g++ main.o -o main -std=c++11 exe:exe.o g++ exe.o -o exe -std=c++11 main.o: exe.o: .PHONY:clean all clean: -rm *.o exe all:main exe 这样执行make all的话会制动执行main和exe目标\n变量 变量用=声明，用:=附加数据，用${}使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 OBJ=main.o OBJ:=exe.o #现在是main.o exe.o SRC=main exe main:main.o g++ main.o -o main -std=c++11 exe:exe.o g++ exe.o -o exe -std=c++11 main.o: exe.o: .PHONY:clean all clean: -rm *.o exe all:${SRC} 变量会在指定的地方准确的展开。\n带第三方库的编译 一般我们可以这样写：\n1 2 3 4 5 main:main.cpp g++ main.cpp -o main `wx-config --libs --cflags` -std=c++11 .PHONY:clean clean: -rm main 这是没有办法写成自动推导的，最多写成这样：\n1 2 3 4 5 6 7 drawShape:drawShape.o g++ drawShape.o -o drawShape `wx-config --libs` -std=c++11 drawShape.o: g++ drawShape.cpp -c `wx-config --cflags` -std=c++11 .PHONY:clean clean: -rm drawShape *.o 这里我们必须通过直接写出编译指令来找到头文件。所以这里就不能用自动推导了。\n","description":"","tags":["Cmake\u0026make"],"title":"Makefile总结","uri":"/posts/makefile%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"wxWidgets的绘图是采用MVC模式，你必须通知它要绘图了他才会绘制图形。\n绘图DC 首先wxWidgets给出了多个绘图DC：\nwxPaintDC：用于在重绘事件中绘制 wxClientDC:在重绘事件之外的情况下绘制 wxBufferedDC和wxBufferedPaintDC:分别对应wxClientDC和wxPaintDC的双缓冲绘制DC wxMemoryDC：双缓冲绘制的底层DC，在内存中绘制的DC。 绘图DC中有绘图函数和绘图要用到的wxPen,wxBrush,wxFont等属性设置。其实和Windows的绘图API差不多。\n绘图过程 重绘过程 重绘过程会触发wxEVT_PAINT和EVT_NC_PAINT事件，使用wxPaintDC,wxBufferedPaintDC。以下事件会触发重绘过程：\n自动事件： 程序初始化界面显示 窗口最小化后再重新出现。 窗口改变大小 窗口被挡住了 手动事件： 调用窗口（一般是wxPanel）的Refresh()或者ReflashRect()方法 一般都需要将事件处理函数绑定到wxEVT_PAINT事件中。\n其他绘制过程 用于在非重绘事件中绘制，比如你鼠标按下拖动绘制一条线的时候。使用wxClientDC,wxBufferedDC。\n绘制代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u003cwx/wx.h\u003e #include \u003cstring\u003e #include \u003ciostream\u003e using namespace std; class Canva:public wxPanel{ public: Canva(wxFrame* parent):wxPanel(parent, wxID_ANY, wxDefaultPosition, wxSize(800, 800)){ } //绘图函数，所有的绘图功能都得在这里进行 void OnPaint(wxPaintEvent \u0026event) { wxClientDC dc(this); //首先获得wxPaintDC dc.SetPen(*wxBLUE_PEN); dc.DrawLine(wxPoint(0, 0), wxPoint(100, 100)); dc.SetBrush(*wxGREEN_BRUSH); dc.SetPen(*wxGREY_PEN); dc.DrawRectangle(wxPoint(200, 200), wxSize(100, 200)); //对文字需要特殊的操作才能改变外貌 dc.SetTextForeground(wxColour(200, 100, 100)); //改变字体颜色 dc.SetFont(wxFontInfo(20).Bold()); dc.DrawText(\"this is a text\", wxPoint(100, 100)); wxInitAllImageHandlers(); dc.DrawBitmap(wxBitmap(\"img.bmp\", wxBITMAP_TYPE_ANY), wxPoint(300, 300)); } private: wxDECLARE_EVENT_TABLE(); }; wxBEGIN_EVENT_TABLE(Canva, wxPanel) EVT_PAINT(Canva::OnPaint) //画布事件绑定 wxEND_EVENT_TABLE() class MyFrame:public wxFrame{ public: MyFrame(string title):wxFrame(nullptr, -1, title, wxDefaultPosition, wxSize(500, 500)){ canva = new Canva(this); canva-\u003eShow(); } private: Canva* canva; wxDECLARE_EVENT_TABLE(); }; wxBEGIN_EVENT_TABLE(MyFrame, wxFrame) wxEND_EVENT_TABLE() class MyApp:public wxApp{ public: virtual bool OnInit(); private: MyFrame* frame; }; bool MyApp::OnInit(){ frame = new MyFrame(\"drawShape\"); frame-\u003eShow(); return true; } IMPLEMENT_APP(MyApp); 这里在Canva的OnPaint方法中绘制，首先获得wxPaintDC，然后使用DC的方法来绘制，可以绘制直线，折线，曲线，圆，矩形，文字等等。通过SetPen()函数来设置画笔（轮廓的样式），通过SetBrush()来设置画刷（填充的样式）。\n但是画笔和画刷不能对文字产生效果，文字另有自己的函数。通过SetTextForeground()来设置文字的前景色，通过SetFont()函数来设置文字。详细请看API文档。\n或者也可以通过Clear()函数清除所有的绘制，或者通过SetClippingRegion()来设置区域进行局部绘制，通过DestroyClippingRegion()删除之前指定的区域。\n绘制图片 绘制图片首先需要使用wxInitAllImageHandlers()函数来初始化图片管理器，然后使用DC的DrawBitmap即可，像上面的代码\n1 dc.DrawBitmap(wxBitmap(\"img.bmp\", wxBITMAP_TYPE_ANY), wxPoint(300, 300)); 需要注意的是:虽然wxBitmap的名称是Bitmap，但是并不是只能绘制bmp，如果将第二个参数设置为这里的wxBITMAP_TYPE_ANY，那么是可以加载JPEG,PNG等格式的图片的。\n参考 CSDN wxWidgets教程\n简书 wxWidgets绘图教程\n","description":"","tags":["wxWidgets"],"title":"wxWidgets绘图","uri":"/posts/wxwidgets%E7%BB%98%E5%9B%BE/"},{"categories":null,"content":"定时器在wxWidgets中和其他的控件其实是一样的，只不过定时器不显示出来就是了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u003cwx/wx.h\u003e #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; //定时器ID enum TimerID{ timer1 }; class MyFrame:public wxFrame{ public: MyFrame(string title):wxFrame(nullptr, wxID_ANY, title){ timer = new wxTimer(this, timer1); //产生一个wxTimer实例 timer-\u003eStart(1000); } //Timer函数 void OnTimer(wxTimerEvent\u0026 event){ cout\u003c\u003c\"timer triggered\"\u003c\u003cendl; } private: wxTimer* timer; wxDECLARE_EVENT_TABLE(); }; wxBEGIN_EVENT_TABLE(MyFrame, wxFrame) EVT_TIMER(timer1, MyFrame::OnTimer) //绑定到定时器函数 wxEND_EVENT_TABLE() class MyApp:public wxApp{ public: bool OnInit(){ frame = new MyFrame(\"timer\"); frame-\u003eShow(); return true; } private: MyFrame* frame; }; IMPLEMENT_APP(MyApp) 这里首先声明一个定时器变量timer，然后使用构造函数创建（构造函数第一个参数是定时器所属的窗体，第二个参数是ID）。然后在事件列表里面指定EVT_TIMER事件就可以了。\n定时器还有一些控制方法：\nStart()开始定时器 IsRunning()是否已经开始运行 StartOnce()只运行一次 Stop()停止运行 ","description":"","tags":["wxWidgets"],"title":"wxWidgets定时器","uri":"/posts/wxwidgets%E5%AE%9A%E6%97%B6%E5%99%A8/"},{"categories":null,"content":"介绍 wxWidgets是一个C++GUI库，用于创建跨平台的GUI程序。而且的确很好用，学习起来也很简单（至少比GTK+和QT简单多了）。\n如果你学习过Windows API编程或者Java的Swing编程的话应该可以很快上手这个库，里面的命名和一些专业词汇都和Windows API很像很像，用法分类上几乎和Swing差不多。\nHello World 首先还是我们最最熟悉的Hello World：\n显示窗口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \"wx/wx.h\"\t//头文件，不是全部的，其他附加的控件需要额外引用，布局器需要额外引用 using namespace std; //步骤一：继承wxApp并且重写方法 class myApp:public wxApp{ public: virtual bool OnInit() override { wxFrame* frame = new myFrame(nullptr, wxID_ANY, \"hello world\"); frame-\u003eShow(); return true; } }; //步骤二：调用宏实例化myApp类。 IMPLEMENT_APP(myApp); wxWidgets是一个纯粹的面向对象的。你必须继承wxApp类来作为当前要运作的类，并且重写里面的bool OnInit()方法（wxApp初始化的时候会调用，一切初始化过程都需要写在里面）。在这里我们实例化了窗体类wxFrame，并且调用了Show()方法来显示出来。\n然后使用宏IMPLEMENT_APP来让wxWidgets实例化myApp类并且运行起来。这个时候我们的GUI界面运作就交给wxWidgets管理啦。\n通过上面的步骤就会有一个窗体在屏幕上显示了。\n和Swing不同，窗体初始化之后不需要指定退出的方式，wxWidgets自己给出了默认退出方式（按下关闭按钮即可）。\n事件管理 事件管理的话就不能使用原来的wxFrame了，我们需要继承并且实现自己的功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u003cwx/wx.h\u003e #include \u003ciostream\u003e using namespace std; //第一步：继承wxApp class myApp:public wxApp{ public: virtual bool OnInit(); }; //第二步：继承myFrame class myFrame:public wxFrame{ public: myFrame(const wxString\u0026 title,const wxSize\u0026 size); //事件处理函数 void OnSize(wxSizeEvent\u0026 event){ cout\u003c\u003c\"resized\"\u003c\u003cendl; wxSize size = event.GetSize(); cout\u003c\u003c\"new width is:\"\u003c\u003csize.GetWidth()\u003c\u003c\" new height is:\"\u003c\u003csize.GetHeight()\u003c\u003cendl; } void OnButton(wxCommandEvent\u0026 event){ cout\u003c\u003cbutton-\u003eGetLabel()\u003c\u003cendl; } private: //第三步：声明事件表 wxDECLARE_EVENT_TABLE(); }; //第四步：处理事件 wxBEGIN_EVENT_TABLE(myFrame,wxFrame) EVT_SIZE(myFrame::OnSize) EVT_BUTTON(button1, myFrame::OnButton) wxEND_EVENT_TABLE() enum ButtonID{ button1 }; myFrame::myFrame(const wxString\u0026 title,const wxSize\u0026 size) :wxFrame(nullptr,-1,title,wxDefaultPosition,size){ wxButton* button = new wxButton(this, button1, \"this is a button\"); button-\u003eShow(); CreateStatusBar(); SetStatusText( \"Welcome to wxWidgets!\" ); } bool myApp::OnInit(){ myFrame* frame = new myFrame(\"hello world\",wxSize(400,400)); frame-\u003eShow(true); return true; } //第五步：实现myApp wxIMPLEMENT_APP(myApp); 这里myApp做的事情还是一样的：实例化Frame然后显示。但是这里的Frame是我们继承wxFrame的myFrame，继承的第一件事就是调用父类的构造方法（在成员初值列中调用了），然后在构造函数里面加了一个按钮和一个状态条（CreateStatusBar）。\n事件处理主要的地方在于两步：\n首先通过wxDECLARE_EVENT_TABLE()宏在类中创建一个事件列表（这个宏会给类创建一个成员变量用于存放事件，叫做事件列表） 然后在类外部通过wxBEGIN_EVENT_TABLE(thisclass, parentclass),wxEND_EVENT_TABLE()这对宏来表示我现在要在这个里面创建事件函数了（这里thisclass是要产生事件的类，parentclass是其父类）。然后在这对宏里面调用EVT_XXXX宏来处理事件。不同的事件宏不一样，参数也不一样。但是一般如果是窗口事件的话直接给出处理函数就行了，如果是窗口里面组件的事件的话一般要先给出组件的ID然后给出事件处理函数。 这里OnSize函数会在控制台输出窗体改变大小之后的值，OnButton会在按下按钮的时候在控制台显示按钮上面的文字。\n结尾 可能你会说：你这里许多new为什么没有delete呢？这是因为wxWidgets重写了控件的new运算符，导致其可以自动管理，不需要我们delete的。如果你想要删除的话使用Destroy()函数\n官方的快速指南 官方的快速指南的确快啊，代码都没有直接就一面讲完了，翻译过来如下：\n想要开始一个wxWidgets程序，你需要继承wxApp类并且重写其OnInit()方法。 一个程序必须有一个顶级窗口，像是wxFrame或者wxDialog。每一个框架包含一个或者多个wxPanels, wxSplitterWindow等其他类的实例。 你可以给框架一个wxMenuBar,wxToolBar,wxStatusBar和wxIcon来将窗口变的更加正规。 wxPanel用来放置控件（所有控件继承自wxControl）用来和用户交互，像是 wxButton, wxCheckBox, wxChoice, wxListBox, wxRadioBox, 和 wxSlider wxDialog的实例也可以用于控件，它们的优点是不需要单独的框架。 可以选择一种方便的通用对话框类，如wxMessageDialog和wxFileDialog，而不是创建对话框并使用项填充它。 绘图从来不是直接绘制在窗口上，而是绘制在DC上。wxDC是wxClientDC, wxPaintDC, wxMemoryDC, wxPostScriptDC, wxMemoryDC, wxMetafileDC 和 wxPrinterDC的基类，如果你的绘图函数含有一个wxDX参数的话，你可以给出上面列举出的任意一个DC，这样你就可以使用同一份代码在不同的设备（硬件）上就行绘制了。你可以使用wxDC的成员函数进行绘制，像是wxDC::DrawLine,wxDC::DrawText。用画笔(wxBrush)和钢笔(wxPen)控制窗口的颜色(wxcolor)。 要获得事件，您需要向窗口类声明中添加一个wxDECLARE_EVENT_TABLE宏，并放置一个wxBEGIN_EVENT_TABLE…wxEND_EVENT_TABLE块来实现事件处理。在这些宏之间，添加事件宏，将事件(例如鼠标单击)映射到成员函数。这些可能会覆盖预定义的事件处理程序，如wxKeyEvent和wxMouseEvent。 大多数现代应用程序将有一个在线的超文本帮助系统;为此，您需要wxHelp和wxHelpController类来控制wxHelp。 GUI应用程序并不都是图形化的。列表和哈希表的需求由wxList和wxHashMap来满足。毫无疑问，您将需要一些独立于平台的文件和目录，并且您会发现使用wxPathList维护和搜索路径列表非常方便。有许多操作系统方法和其他功能。\nwxWidgets总结 命名方式 所有的控件前面和事件枚举类型都会加上wx，所有的成员函数都是每个单词大写的。\n所有的事件函数(包裹在wxBEGIN_EVENT_TABLE,wxEND_EVENT_TABLE中的)都以EVT_开头，所有的事件枚举类型都以wxEVT_开头\n绘图的话首先要取得DC（Device Context，没错是windowsAPI中的词汇），然后调用DC的成员函数绘制，所以所有的DC类最后都是以DC结尾的。\n","description":"","tags":["wxWidgets"],"title":"wxWidgets快速回顾","uri":"/posts/wxwidgets%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/"},{"categories":null,"content":"这里是8086汇编语言的总结，使用的汇编器是nasm。\n汇编程序的基本构造 首先我们先来看一段C++代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \"header.hpp\" using namespace std; struct member{ int a; int b; }; struct data{ member m1; member m2; string name; }; int main(int argc,char** argv){ FILE* file = fopen(\"data.mem\", \"rb+\"); if(file == nullptr){ cout\u003c\u003c\"file not open\"\u003c\u003cendl; return -2; } data d; fread(\u0026d, sizeof(d), 1, file); cout\u003c\u003c\"read suuccessful\"\u003c\u003cendl \u003c\u003c\"data.m1:\"\u003c\u003cendl \u003c\u003c\"a:\"\u003c\u003cd.m1.a\u003c\u003cendl \u003c\u003c\"b:\"\u003c\u003cd.m1.b\u003c\u003cendl \u003c\u003c\"data.m2\"\u003c\u003cendl \u003c\u003c\"a:\"\u003c\u003cd.m2.a\u003c\u003cendl \u003c\u003c\"b:\"\u003c\u003cd.m2.b\u003c\u003cendl \u003c\u003c\"name:\"\u003c\u003cd.name\u003c\u003cendl; fclose(file); member m; memcpy(\u0026m, \u0026d, sizeof(member)); cout\u003c\u003c\"strong cast successful\"\u003c\u003cendl \u003c\u003c\"m.a:\"\u003c\u003cm.a\u003c\u003cendl \u003c\u003c\"m.b:\"\u003c\u003cm.b\u003c\u003cendl; return 0; } 这一部分代码是将二进制文件中的数据读出来并且存储到data结构体里面。\n我们就通过这个程序来分析一下一个程序最基本需要什么。\n首先他有代码。在汇编语言中，代码被放在代码段中，代码段中的代码就是程序要执行的代码。\n其次我们看到有d啊m啊这些变量，也就是说有数据。在汇编中，数据被放在数据段中。\n最后还有一个我们并不能从表面看出来的组成，被称为栈段，也就是作为栈使用的段。\n所谓段，其实就是对内存进行划分，将内存划分为一块一块的，这一块专门存储数据，我们就叫它数据段咯。这一块专门存储代码，我们就叫他代码段咯。\n带有段的程序 大多数情况下，程序是带有段的。段可以更好地帮助程序员来区分各部分代码的职责。在nasm汇编器中，你可以使用section来声明段:\n1 2 3 4 5 6 7 8 9 jmp _start section codes vstart=0 _start: mov ax, datas mov ds, ax section datas msg db \"helloworld\" 这里section codes声明了代码段，表示代码从这里开始执行。section datas声明了数据段，表示这里存放着数据。\n开头的jmp _start表示跳转到_start处开始执行。需要注意的是，声明了段并不代表你的寄存器也指向了段。所以这里的:\n1 2 mov ax, datas mov ds, ax 将datas（段名代表这个段开头在内存中的位置）放入ds。也就是我们必须手动关联段地址寄存器和段。开头的jmp _start当然也可以写成:\n1 2 3 mov ax, codes mov cs, ax mov ip, _start 来强制指定，不过这里使用jmp显然更快。\n没有段的程序 程序也可以是没有段的。这个时候整个程序是一个段（nasm规定没有section指定的地方自成一段）你自己就要想办法划分你的程序空间，比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 jmp near main ;一样先跳转到程序开始处。我们这里程序在main处开始 msg db 'Hello World' ;这里是数据 main: mov ax, 0xB800 mov es, ax mov di, 0 mov ax, 0x7c0 mov ds, ax ;这里直接将ds指向显存 mov si, msg mov cx, main-msg trans: mov byte al, [ds:si] mov byte [es:di], al inc di mov byte [es:di], 0x07 inc di inc si loop trans jmp near $ times 510-($-$$) db 0 db 0x55, 0xaa 可以看到这里没有将ds指向msg处，而是将es指向msg处，将ds指向显存。其实并没有什么硬性规定说ds就要指向程序的数据部分。只要是段地址寄存器就可以指向任意的段地址，ds被用于指向程序数据也只是惯用方法而已。\n所以如果你想要自己写汇编的话，必须把你的栈段，数据段，代码段管理好，不然可能会影响其他的程序。\n实模式和保护模式 8086是在实模式下工作的，而现在我们的32位和64位电脑是在保护模式下工作的。\n通俗来说，实模式就是程序之间可以互相干预，我可以通过汇编代码影响你的内存，你也可以影响我的内存。这样很显然系统不稳定。所以在之后Intel处理器就推出了保护模式，各个程序有自己的内存空间，通过寄存器引用其他程序的内存是非法的。\n8086是在实模式下编写的代码，可以有很大自由操控内存。\n寄存器 寄存器是CPU中存储数据的地方，8086CPU寄存器有AX,BX,CX,DX,DS,SS,ES,CS,SP,IP,DI,SI,BP,标志寄存器\n通用寄存器 通用寄存器可以存储任意的数据，有AX,BX,CX,DX四个。虽然说是通用寄存器，但是每个寄存器其实还是有自己不同的职责的。\nAX AX是最常用于\n作为数据中转站（将数据放入段地址寄存器中） 作为各种指令的参数存放处或者结果存放处（如mul和int指令） BX 一般来说称为“基址寄存器”，你可以将BX中的B理解为Base Address中的Base。\nBX广泛用于指定内存地址，而且在通用寄存器中也只有它可以指定内存地址。\nCX 计数寄存器(Count Register)，和循环有关的指令都是以CX内的值来决定循环次数的。\nDX DX和AX的用途差不多\n段地址寄存器及其匹配寄存器 段寄存器用于存储段的段地址。由于8086采用段地址*16+偏移地址的方式寻址，所以一般来说还有一个寄存器用于存储偏移地址，也就是和段地址寄存器匹配的辅助寄存器。\n由于8086内是16位寄存器，所以每个寄存器最大可以是0xFFFF地址，那么根据段地址*16+偏移地址可知，段地址和其辅助寄存器最大可以寻址0xFFFF*16+0xFFFF=0xFFFFF=2^20=1MB（由于溢出导致最大只能是0xFFFFF）。所以每个段最大不可能超过1MB。\n由于段地址*16+偏移地址的表示方法很常用，所以我们也使用段地址:偏移地址的方式来简写。\n段地址寄存器都是不能直接复制的，也就是说你不能mov ds, 0x3d这种，而必须通过一个通用寄存器间接赋值，比如：\n1 2 mov ax, 0x7C0 mov ds, ax 数据段DS(Data Segment) DS是数据段(data segment)寄存器。数据段用于存放数据。\n指令段CS(Construct Segment)和IP(Instruct Pointer) CS是指令段(construction segment)寄存器，指令段用于存放指令。\n你的指令就是在CS:IP处，每次CPU执行完一条指令就会将IP加上这条指令的长度来指向下一条指令。所以你可以通过改变CS和IP来改变指令的执行顺序。\n栈段SS(Stack Segment)和SP(Stack Pointer) SS是栈段(stack segment)寄存器，栈段用于当作栈使用，但是CPU不能保证栈段溢出，程序员要自己关心栈段的大小和是否越界。 SP指向栈段的栈顶。每次使用push和pop的栈指令时都会影响SP。\nES(Extra Segment) 这个寄存器也是段寄存器，但是是额外的段寄存器。他是当你不想改变DS，CS，SS的时候，可以通过ES来指向段：\n1 2 3 4 5 6 7 8 mov ax, 0x7C0 mov es, ax mov cx, 10 mov si, 0 l: mov byte [es:si], [ds:si] inc si loop 这里我们的DS指向数据了，但是我们想将DS中的10个字节的数据放到0x7C0中，但是DS又不能改变，那怎么办呢？这个时候就可以使用ES来窒息那个0x7C0处来帮助移动了。\n这里同时也展示了SI和DI寄存器的使用方式。\nDI, SI, BP DI, SI寄存器(Destination, Source)一般用于辅助内存中数据的移动。DI一般指向数据目的地，SI一般指向数据源地址。\nBP的话一般用于辅助栈段，一般用于取代SP来操纵栈。也就是说当你不想移动SP的时候你可以通过BP来辅助，就像ES辅助其他寄存器一样。\n标志寄存器 标志寄存器不是用于存放用户数据的，而是存储系统数据的，且是按位起作用的，也就是说每一位的作用都不一样。\nZF(Zero Flag) 0标志位\n表示算数运算，and，or等运算的结果是否为0\nPF(Parity Flag) 奇偶校验位\n记录算数运算，and，or等运算的结果中所有1的个数\n为奇数：0 为偶数：1 SF 负数标志位\n相关运算之后结果是否为负数。如果为负数SF=1否则SF=0\n需要注意的是只有我们将数据视为有符号数据的时候SF才有意义，虽然无符号数据在某些情况下也会改变SF， 但是这种改变是没有意义的\nCF(Count Flag) 进位标志位\n在进行无符号数运算的时候，记录了运算结果最高位有效位向更高位是否进位，或者是否借位，如果进位/借位CF=1否则CF=0。\n这个位通常在带位加减法或者大数据加减（用多个于16位保存一个数）中使用。\nOF(Overflow Flag) 溢出标志位\n在进行有符号数运算的时候，如果溢出位1，否则位0\nDF(Decrease Flag) 递减标志位\nDF表示用于控制在使用MOVSB,MOVSW指令之后SI,DI寄存器递增递减的问题。DF=1时SI,DI会自减，否则自增。\n使用CLD(CLear DF)指令置DF=0，STD(SeT DF)指令置DF=1\nIF(Interupt Flag) 可屏蔽中断位\n为1的时候CPU接收到可屏蔽中断时会响应，为0时不响应。\n使用STI(SeT IF)设置IF为1，CLI(CLear IF)设置IF为0\nTF(Trap Flag) TF跟踪标志,也被称为陷阱标志\nTF=1，机器进入单步工作方式，每条机器指令执行后，显示结果及寄存器状态，若TF=0，则机器处在连续工作方式。此标志为调试机器或调试程序发现故障而设置。\nAF AF是辅助进位标志\n通常在BCD码运算中用于判断是否发生一个字节中的低4位向高4位的进位或者借位。\n汇编指令 汇编指令是机器码的助记符，最后汇编的时候会将汇编指令变成机器码。\n需要注意的是，汇编指令有需要一个操作数的，两个操作数的和没有操作数的。一般来说有两个操作数的指令中，两个操作数不能都是内存地址和立即数或者两者的混淆，一般来说必须有一个寄存器。\n运算 加减 加减分别是ADD,ADC和SUB,SBB，格式是（四个格式一样）\nADD 操作数1， 操作数2 所有的结果都会放在操作数1中。\n其中ADD,SUB是不进位加减，ADC,SBB是进位加减，也就是说会使用CF寄存器中的值来加减。\n同样还有INC, DEC的单操作数指令将操作数内容自增/自减1:\n1 2 INC 操作数 DEC 操作数 乘除 分别是DIV和MUL\nMUL和IMUL MUL是无符号乘法,IMUL是有符号乘法，分为两个情况：\n乘数都是8位，那么其中一个乘数默认放在AL中，另一个放在内存或者8位寄存器中。结果存放在AX中 乘数都是16位，那么其中一个乘数默认在AX中，另一个上。结果的高位存放在DX中，低位存放在AX中 DIV和IDIV DIV是无符号数除法，IDIV是有符号数除法，除数总是需要被指定（可以是寄存器或者内存），分为两个情况：\n被除数为16位，除数为8位，那么被除数默认放在AX中，结果AL存放商，AH存放余数 被除数为32位，除数为16位，那么DX存放被除数高16位，AX存放低16位。结果商放在AX中，余数放在DX中 按位运算 和AND 或OR 非NOT 异或XOR TEST:将两个操作数进行逻辑与运算，并根据运算结果设置相关的标志位。但是，Test命令的两个操作数不会被改变。只是改变标志寄存器而已。 TEST和CMP指令的区别见这里\n移位运算 移位运算分为两种：\n逻辑移位：移出去的位丢弃，空缺位（vacant bit）用 0 填充。 算术移位：移出去的位丢弃，空缺位（vacant bit）用“符号位”来填充，所以一般用在右移运算中 还有一种特殊的叫做循环移位，就是移出去的位会补在新加的位上。\n那么显然也得有对应函数：\n逻辑左移SHL 逻辑右移SHR 算数左移SAL 算数右移SAR 循环左移ROL 循环右移ROR 会将最后移入/移出的位写入CF中。如果移动位数大于1，那么必须将位数放在CL中.\n移动指令 移动指令将一个地方的数移动到另一个地方\nMOV MOV指令应该是汇编语言中最常用的指令了。MOV指令需要两个参数，可以将后面参数的值移动到前面参数去。\nMOV 操作数1， 操作数2 MOVSB, MOVSW MOVSB和MOVSW是将DS:SI指向地址中的值送到ES:DI地址中，然后在根据DF标志觉得DS和SI是自增还是自减：\nDF=1自减 DF=0自增 其中MOVSB是对字节操作，MOVSW是对字操作\nXCHG XCHG用于交换寄存器或者内存地址之间的值：\nXCHG 操作数1， 操作数2 对栈的操作 对栈的操作就四个函数：\npush和pop，push将数据压入栈，pop将数据弹出栈\n需要注意：push和pop的参数只能是寄存器或者内存地址，不能是立即数\npushf和popf，分别将标志寄存器压入和弹出栈。这为操作标志寄存器的值提供了方法\npushf没有参数\n转移指令 转移分为\n段内转移：只会修改IP，段内转移按照转移的距离又分为： 段内短转移：转移范围为-128~127 段内近转移：转移范围为-32768~32767 段间转移：同时修改CS和IP JMP 无条件转移指令可以按照标号转移或者按照地址转移\n按照标号转移： JMP SHORT S段内短转移到S处 JMP NEAR PTR S段内近转移到S处 JMP FAR PTR S段间转移到S处 按照寄存器和地址转移： JMP 段地址:偏移地址，直接修改CS，IP，段间转移 JMP 寄存器，将寄存器的值赋予IP，段内转移 LOOP 条件转移指令，段内转移，作用是当CX的值不是0的时候跳转到标号，并且将CX值自减\nJCXZ(Jump if CX is Zero) 条件转移指令，段内转移，和LOOP很像，当CX为0的时候跳转到标号，但是不会改动CX的值\n子过程相关指令 CALL和RET，RETF CALL指令会先将CS和IP压入栈中，然后修改CS，IP的值（如果直接CALL保存和修改IP的值，如果是CALL FAR PTR保存和修改CS和IP的值）\nCALL指令不能实现短转移。\nRET指令用来和CALL搭配，从栈中弹出保存的IP的值并且修改现在的IP值\nRETF时用来和CALL FAR PTR搭配，弹出CS和IP的值并且修改现在的CS和IP的值\n带有参数的RET和REFT RET和REFT后面可以跟一个立即数，这样在弹出和修改CS和IP值之后还会将IP的值加上这个立即数的值。这个普遍用在栈传递参数的技术中。\nIRET 用于和中断INT搭配使用，返回原来的程序。在中断程序的最后必须加上IRET\n比较和比较相关的跳转指令 CMP 用于将两个数相减，本身不将结果存放在任何寄存器中，只是为了改变标志寄存器。\nCMP和TEST的区别 CMP和TEST的区别如下：\ncmp主要用于比较两数的关系，可以在有符号数和无符号数之间进行比较。两数相等影响ZF标志，无符号数影响CF标志，有符号数影响SF和OF标志。一般根据标志位的影响设置程序跳转，即根据不同的条件完成对应的程序片段，类似于高级语言的IF-ELSE结构。所有的有条件转移指令都可以用在这条指令之后。 test通常用于检测某些位是否为1，但又不希望改变操作数的场合。比如检查AL中的位6和位2是否有一位为1，可以用如下指令： test AL，01000100b，如果这两个位全为0.则ZF的值为1，否则清0，那么根据标志位设置的跳转就只能为jz或jnz 这两条指令的相同点是都不会影响操作数，只是通过标志寄存器的某些位反映运算结果。\nJE,JNE,JA,JNA,JB,JNB跳转指令 用于和CMP搭配使用\nJE：当ZF位为1时跳转到标号 JNE：当ZF位为0的时候跳转到标号 JA：当CF位为0且ZF为0的时候跳转 JNA：CF为1或ZF为1的时候跳转 JB：当CF=1的时候跳转 JNB：当CF为0的时候跳转 这些指令的英文很简单，分别是Jump Equal, Jump Not Equal, Jump Above, Jump Not Above, Jump Below, Jump Not Below\n中断指令 INT 用于执行中断，过程如下：\n取中断类型码n pushf，切令IF,TF为0 CS,IP入栈 (IP)=(n*4), CS=(n*4+2) 一般和IRET指令配合使用。\n所有的中断可以在这份文章中找到里面找到\n端口指令 IN IN指令用于从端口读入数据到寄存器，用法是\n1 2 3 4 5 in ax, dx in al, dl in ax, dl in al, dx in ax/al, 立即数 也就是说第一个数必须是AX或者AL（AH都不行），第二个必须是DX和DL\nOUT OUT用于将数据写入到端口的制定内存中，和IN指令相反：\n1 2 3 4 5 out dx, ax out dl, al out dx, al out dl, ax out 立即数m dx/dl ","description":"","tags":["asm"],"title":"8086汇编语言知识点汇总","uri":"/posts/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"},{"categories":null,"content":"序言 这份笔记记录的是从python到Lua，一个小时内入门Lua的教程。最好先熟悉python。\nLua的使用方法 首先你需要从官网上下载Lua：官网\n安装好Lua之后，和Python一样你可以直接在终端输入Lua打开Lua的交互式界面：\n需要注意的是，lua交互界面只能通过Ctrl+C或者函数os.exit()来退出。\n如果你想要执行脚本文件的话，也是和python一样直接使用lua filename就可以了：\nLua文件的后缀名为.lua\nLua的注释 Lua的行注释为--，块注释为--[,--]\n基本数据类型和流程控制 变量 Lua和Python一样，变量无需声明直接使用，变量区分大小写。 需要注意的是，如果在Lua中使用了没有给出值的变量，会返回nil，nil相当于python的None。 而且在Lua中，除了遵循变量命名规范之外，所有以_开头的，后面为因为字母的（比如_VERSION）都会被视为系统内置变量。所以我们起名字的时候不要开头为一个下划线。\n局部变量和全局变量 如果是局部变量，前面需要加local，如果是全局变量就不需要加。 但是在Lua里，只有加了local的是局部变量，也就是说即使在函数或者循环内部的变量，如果前面没有加上local都算是全局变量！出了函数体或者循环等封闭空间外面还是可以使用这个变量\nLua的基本数据类型 number, boolean, string, function, userdata, thread, table, nil 其中number又包含integer, double。没有float。 boolean类型的取值为true,false。\n和python一样，Lua也将函数视为数据类型function。thread是线程类型，userdata是Lua从C语言中获得的数据类型。因为Lua可以和C/C++原生嵌套使用，所以会又这样的类型。table相当于数组，后面会说明。\nstring类型 string类型可以使用'或者\"扩起来。这里需要注意的是，和python不一样，Lua中的string类型使用..进行连接，在字符串开头使用#获得字符串长度：\n你也可以使用[[,]]来扩起字符串，这样字符串中的特殊字符不会被转译。\n字符串函数 又很多字符串操作函数。注意下面的函数中string不能省略，而且就是string，而不是要替换其他字符串\nstring.upper(argument): 字符串全部转为大写字母。 string.lower(argument): 字符串全部转为小写字母。 string.find (str, substr, [init, [end]]) 在一个指定的目标字符串中搜索指定的内容(第三个参数为索引),返回其具体位置。不存在则返回 nil。 string.gsub(mainString,findString,replaceString,num) 在字符串中替换,mainString为要替换的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换） string.reverse(arg) 字符串反转 string.format(...) 返回一个类似printf的格式化字符串 这个格式化方法和python一样，比如string.format(\"this is %s\", \"a guy\") string.char(arg) 和 string.byte(arg[,int]) char 将整型数字转成字符并连接， byte 转换字符为整数值(可以指定某个字符，默认第一个字符)。 string.len(arg) 计算字符串长度。 string.rep(string, n) 返回字符串string的n个拷贝 string.gmatch(str, pattern) 回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。 string.match(str, pattern, init) string.match()只寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。 在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。 表 表的类型是table。相当于数组。使用{}扩起来就可以了：\n1 a = {\"stu1\", \"kil2\", \"pol3\"} 你可以通过下标来找到内部的值。但是注意下标从1开始：\n1 2 a[1] --stu1 a[3] --pol3 其实表是一个键值对，相当于python中的字典。其默认的键值对是这样：\n1 a = {1:\"stu1\", 2:\"kil2\", 3:\"pol3\"} 这也就解释了为什么下标从1开始。 你也可以像python一样，动态添加元素：\n你也可以在初始化的时候指定键，键如果是字符串的话不需要加上双引号，如果是数字的话需要加上[]\n如果表的键是字符串的话，你也可以使用table.key的形式来添加或者获得元素：\n1 2 a = {} a.name = \"Visual\" --等价于a[\"name\"] = \"Visual\" 你也可以使用#放在表的前面来获得表中的元素。需要注意的是：#获得的表的元素，其下标一定是要从1开始的连续下标，#会找到表中键为1的键，然后向后查找连续的键（2，3，4），每找到一个就会加1。也就是说下面这些都会返回0:\n1 2 t = {[2]=2,[3]=[3]} t = {name=\"A\", age=17} 而下面这些会返回非0值：\n1 2 3 t = {name=\"a\", age=123, [1]=10, [2]=20} --返回2 t = {[1]=10, [2]=20,[3]=30} --返回3 t = {name=\"a\", [1]=1, [2]=2, [3]=3, [5]=7, [6]=7} --返回3 由于表的键值对可以是任何的东西，你也可以使用函数来当作值：\n1 t = { fn = function() print(\"hello\") end} --传入了一个匿名函数 使用t:fn()或者t.fn()来访问即可。\n表的操控函数 同样的，下面的table不可以被替换：\ntable.concat (table [, sep [, start [, end]]]): concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。 table.insert (table, [pos,] value): 在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾. table.remove (table [, pos]) 返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。 table.sort (table [, comp]) 对给定的table进行升序排序。 运算符 数学运算符 +,-,*,/,%,^(幂),//(整除)\n逻辑运算符 和python一样,除了~=(不等于)。 需要说明的是。在赋值语句中，所有的非boolean量不可以自动转换为boolean量，就算是nil也不行。同样boolean也不会自动转换为其他量。 在条件判断中，只有nil是false，其他的所有值都会转换为true。\n关系运算符 and or not 这里需要注意一下关系运算符的返回值。 关系运算符的返回值不一定是true或者false。如果是not的话，的确会返回true或者false。但是and会让or不是这样。 and会根据短路原则，从表达式左边看向右边。并且如果在看到变量x的时候就已经确定表达式值的话，就会单击x。比如：\n1 2 nil and \"Hello\" --返回nil \"Hello\" and nil --返回nil 你也可以认为会返回从左往右的第一个为nil的值。如果所有值都不是nil的话，会返回最右边那个值。\nor的话也是遵循短路原则，和and一样，比如：\n1 2 3 nil or \"Hello\" --返回\"Hello\" \"Hello\" or nil --返回\"Hello\" \"Hel1\" or \"hel2\" --返回\"Hel1 也就是说他会从左向右返回第一个不为nil的元素。如果所有元素都为nil就返回nil。\n位运算符 和C/C++一样。（左移右移也一样）\n流程控制 注意Lua中只有break没有continue\nwhile循环和repeat...until循环 while循环的语法如下：\n1 2 3 while(statement)do --codes end repeat...until循环就是当条件为真的时候停止循环。这是从VB里面抄来的：\n1 2 3 repeat --codes until(statement) for循环 for循环有两种，普通的for循环和for_each循环。\n普通for循环 1 2 3 for i=exp1,exp2,exp3 do --codes end i的初值为exp1，循环到exp1，步长为exp3，exp3可以不写，默认为1。 用C++的话，相当于：\n1 for(int i=exp1;i\u003cexp2;i+=exp3){} 遍历for循环 这种循环和python一样，比如遍历表：\n1 2 for i,v in pairs(t) do end 这里使用pairs()函数来将表t中的键和值连接成对。\nif语句 1 2 3 4 5 6 7 8 9 if(statement1) then --code1 [elseif(statement2)] [then] --code2 [else] --code3 end 这个也是从VB抄来的。\n变量可见性 请看下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 x = 10 -- 全局变量 do local x = x -- 新的x print(x) --\u003e 10 x = x+1 do local x = x+1 -- 另一个x print(x) --\u003e 12 end print(x) --\u003e 11 end print(x) --\u003e 10 (全局的那个) 也就是说，使用local在局部范围内声明变量其实是创建了一个新的变量。如果你使用变量的话如果内部没有local变量，那么还是使用的全局变量。\n函数 函数的声明格式如下:\n1 2 3 4 [local] function funcname(args1, args2, args3, ...) --codes --return value end 参数可以是很多个，和python一样，你可以return多个值。但是这里要注意：和python不一样，返回多个值不代表你可以用一个变量去承接，如果你只有一个变量去承接多个返回值的话，Lua不会默认那个变量为表，而是将第一个返回值给那个变量，像这样：\n1 2 3 4 5 6 7 8 local function fn() return 1,2,3 end a = fn() --a=1 a,b = fn() --a=1, b=2 a,b,c=fn() --a=1,b=2,c=3 a,b,c,d=fn() --a=1,b=1,c=3,d=nil 函数参数不能有默认值\n函数可以有不定参数，通过...来指定：\n1 2 function fn(...) end 最扯的是这个...就是不定值，你如果想要获得不定值就要对这个...迭代。但是必须要先将其变成表（因为在Lua中只有表可以 迭代）：\n1 2 3 4 5 6 7 8 9 funnction fn(...) local args={...} --变成表 for i,v in pairs(args) do print(v) end end fn(1,4,2,6) --1426 如果函数只有一个参数，并且这个参数为表的话，我们可以省略括号：\n1 2 3 4 5 6 #!/usr/local/bin/lua function fn(param) print(param) end fn{1,4,2} 传值与传引用 和python一样，只有对象才能传引用。在Lua中table类型就相当于对象一样，所以只有table类型是传引用，通过赋值运算符也是浅拷贝。\n包 导入包 和python一样，可一个Lua文件都可以被视为一个包。 导入包的函数为require()。需要注意的是Lua的包搜索路径在环境变量LUA_PATH中。比如：\n1 require(\"model\") --Lua会在LUA_PATH中找名称为model.lua的文件 你也可以给导入的包取别名，只需要使用变量赋值就可以了：\n1 local m = require(\"model\") --model的别名为m 声明包 包其实是一个表。只不过在文件的最后部分你需要写上return 包名，比如这样:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 -- model.lua中 model = {} model.constant = \"this is a constant\" function model.func1() print(\"this is func 1\") end function model.func2() print(\"this is func2\") end local function func3() print('this is a local function') end return model -- main.lua中 #!/usr/local/bin/lua require(\"model\") model.func1() model.func2() print(model.constant) --[ 结果: this is func 1 this is func2 this is a constant --] 也就是说，导入包其实是导入文件中的那个表。注意函数前标有local的是局部函数，不能再包外面使用的\n文件IO Lua的文件IO也很简单，分为简单模式和完全模式。\n首先是打开文件的操作：\n1 file = io.opne(filename[, openmode]) 其中参数和python，C/C++一样。openmode是打开方式，可以是\"w,w+,r,r+,b\"等。\n简单模式 简单模式一次只能打开一个文件，像是这样：\n1 2 3 4 file = io.open(\"test.txt\", \"r+\") --打开文件 io.input(file) --将file放入io.input中表示接下来要对这个文件读取，如果是写入就放入io.output()中 print(io.read()) --读出一行并输出，如果是写的话就是io.write() io.close() 也就是说，在简单模式下我们必须将文件放入io.input或者io.output中才可以读取，这也就是为什么一次只能使用一个文件的原因。\n完全模式 完全模式在打开文件之后，通过文件返回值就可以直接对文件操作：\n1 2 3 file = io.open(\"test.txt\", \"r+\") print(file:read()) --通过 file:read()来读取，或者file:write()可以写入 file:close() --通过file:close()来关闭 没错，通过file:operator()就可以直接对文件读取了，不需要放入io中。\n错误处理 由于Lua是纯C写的，而C没有错误处理功能，所以Lua也没有，要想使用错误处理只能通过下面的办法：\n使用assert(statement)函数抛出运行时错误，这一点和C一样 使用error(msg[, level])函数终止当前函数运行，并且打印错误信息。他会打印msg参数，并且level参数有三个等级： Level=1[默认]：为调用error位置(文件+行号) Level=2：指出哪个调用error的函数的函数 Level=0:不添加错误位置信息 使用xpcall, pcall函数提前检测函数是否会发生错误 这里需要对最后两个函数说明一下。xpcall和pcall需要 传入一个函数，以及这个函数需要的参数。他会先自己运行这个函数。如果函数有错误会返回false和erroinfo，没有错误返回true（但是出了错不会产生异常）。xpcall的话多一个参数，用于在有错误的时候自动处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #!/usr/local/bin/lua local function test(n) print(n) assert(false) end if(pcall(test, 6)) then print(\"no error\") else print(\"error\") end --[输出 6 error --] #!/usr/local/bin/lua local function test(n) print(n) assert(false) end if(xpcall(test, function() print(\"this is error handle function\") end,6)) then print(\"no error\") else print(\"error\") end --[输出 6 this is error handle function error --] 需要注意的是，这里你不能使用除零错误，因为Lua里面有针对无限大的关键字inf，如果除零的话会返回inf而不是报错。\n元表也是一个表，他可以作为一个表附着在另一个表上，并且提供一些功能和值。\n设置/获取元表 设置和获取元表的函数为\n1 2 setmetatable(dsttable, metatable) getmetatable(table) 通过setmetatable可以将metatable放座位dsttable的元表，然后这个函数返回新生成的表（你可以不接受这个返回值，因为这个操作本身就已经改变了dsttable了） 通过getmetatable可以获得table的元表\n元表的用途 元表只有一个作用：\n在发生某些操作时出发mt中的元方法。 其实就是给本来的表添加元方法。\n所谓元方法，就是针对表的操作而自动触发的方法。\n元方法的编写 __index元方法 当你通过键来访问 table 的时候，如果这个键没有值，那么Lua就会寻找该table的metatable（假定有metatable）中的__index 键。如果__index包含一个表格，Lua会在表格中查找相应的键。比如说这样：\n1 2 3 4 5 6 7 #!/usr/local/bin/lua mt = {__index = {name=\"VisualGMQ\", age=19}} t = {height = 17, width = 1} setmetatable(t, mt) print(t.name) --结果 VisualGMQ 可以看到t中是没有name这个键的，所以在元表mt中查找了。\n如果__index是一个函数的话，Lua会调用那个函数，并且会把表和查询的键作为参数传过去：\n1 2 3 4 5 6 7 8 9 10 11 12 #!/usr/local/bin/lua mt = {__index = function(tb, key) print(key, \" is not exists in\", tb) end} t = {height = 17, width = 1} setmetatable(t, mt) print(t.name) --[结果 name\tis not exists in\ttable: 0x7fcbc44071f0 ni --] __newindex 这个元方法在插入不存在的键的时候会调用。会将表，键和值当作参数传入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/usr/local/bin/lua mt = {__newindex = function(tb, key, value) print(key, \" is not exists in\", tb) print(\"insert\", value) rawset(tb, key, value) end} t = {height = 17, width = 1} setmetatable(t, mt) t.name = \"VisualGMQ\" --[结果 name\tis not exists in\ttable: 0x7fb420c06da0 insert\tVisualGMQ --] 通过调用rawset()函数可以给原来的表插入键值对。\n运算式元方法 有__add(+), __sub(-), __mul(*), __div(/), __mod(%), __unm(取反), __concat(..连接), __eq(==),__lt(\u003c),__le(\u003c=)，__pow(^),__gc(变量销毁时调用) 这些元方法都会将运算符左右的两个表传入函数中（如果是单目运算符就传入一个表）。\n__tostring 使用print函数打印表的时候会调用这个元方法。这个方法传入调用表到函数里。\n__call 这个元方法是当表作为函数形式的时候会调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/usr/local/bin/lua mt = {__call= function(tb, param) print(param) end} t = {height = 17, width = 1} setmetatable(t, mt) t(32) t({1,2,3}) t(false) --[ 32 table: 0x7fb1cec06fc0 false --] 面向对象 面向对象语言必然有面向对象的三大特性：封装，继承，多态。 Lua中的面向对象是靠表完成的。\n封装 这个很显然了，在包一节就已经说过了：\n1 2 3 4 5 6 Shape = {} Shape.style = \"circle\" --封装变量 --封装函数 function Shape.area() end 当然你也可以通过function Shape:are()来声明。对于函数来说，使用:会额外传入一个self参数代表自身，这个和python一样。但是.是不会传入的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 shape = {} function shape:area() print(self) end function shape.fn() print(self) end shape.area() shape:area() shape.fn() shape:fn() --[结果 nil table: 0x7fbf0f500200 nil nil --] 可见。只有通过:定义并且通过:调用的函数才会传入self，其他的均不会传入self。\n你可能会疑惑如何定义构造函数。其实使用元表就可以了：\n1 2 3 4 5 6 7 8 9 10 11 #!/usr/local/bin/lua person = {} function person:new(name, age, height) self.__index = self o = setmetatable({}, self) o.name = name o.age = age o.height = height return o end 这里我们来详细说明一下，首先定义一个空表。然后我们暂时将构造函数的名称成为new，在new函数里面首先self.__index = self，然后将self设置为元表。这样的话我们后面如果调用了不存在的函数，就会在self里面找，就可以找到结果了。这一步其实就是强制如果没有函数就在自己的self中找。如果找不到那么就结束查找。 然后就是使用self.xxx来设置变量了。\n接下来我们来设置一些成员函数：\n1 2 3 4 5 6 7 8 9 10 11 function person:getName() return self.name end function person:getAget() return self.age end function person:print() print(self.name, self.age, self.height) end 这些函数都必须是:声明的，因为我们要用到self。 因为要用到self，所以我们也必须通过:调用：\n1 2 p = person:new(\"VisualGMQ\",17,170) p:print() 这样就完成了一个类。\n如果你还想加入析构函数，就指定self.\\_\\_gc吧。\n继承 继承也很简单：\n1 2 3 4 5 6 7 child = person:new() o = person:new(\"Visual\", 170, 28) --调用父类的构造函数并且得到一个父类的对象 setmetatable(self, person) --将父类作为子类的元表。这样我们就可以调用父类继承的函数了。 o = setmetatable(o, self) --再将本类作为o的元表，这样我们就可以使用子类的方法了。 self.__index = self --如果没有函数，就在自己的类里面查找 return o --返回实例 end 上面的代码造成了这样一个情况：\n这样有一个什么情况呢，当我们调用了child的方法， 比如print()，这个时候会在self中查找这个方法。我们当然有这个方法，所以会调用child:print()方法。这样子类就重写了父类的方法了。 如果我们在child对象中调用getName()方法的时候，首先会在self中找，但是self中没有这个方法，那么就会在self 的元表中找。self 的元表我们已经动议为person了，所以就会在person中找，这样就会找到父类的getName()方法，这样就可以找到父类的方法了。这就是方法的继承。成员变量也是同样的道理。\n","description":"","tags":null,"title":"从Python到Lua快速入门","uri":"/posts/%E4%BB%8Epython%E5%88%B0lua-/"},{"categories":null,"content":"这里说一下使用栈来保存参数和调用过程的方法，和其中踩的一些坑。\n代码目标 我们的目标是自己编写一个过程，在DosBox中显示数据段中的字符。（虽然有外中断可以完成，但是我还是自己写一个）\n这个函数的描述如下：\n;@fn 这个函数将数据段里面的文字输出一行（末尾换行） ;这个函数的参数放在栈里面 ;@param ; 字符串开始的位置 ; 字符串的长度 ; 这一行字符串的属性信息（放在低字节中） 除了这些外栈的最底端还有一个word用于存放当前要写到的行数。\n关于DosBox的屏幕输出，见这里\n编写代码 预备工作 首先将assume和数据段，栈段写出来：\nassume cs:codeseg, ds:dataseg, ss:stackseg dataseg segment db 'welcome to masm' db 'created by VisualGMQ 2019.8.10' dataseg ends stackseg segment dw 10 dup (0) stackseg ends 过程的编写 从栈里面读取参数 pop ax ;先把call指令传入的原IP的值拿出来 pop bx ;取出这一行字符串的属性信息 pop cx ;取出字符串长度 pop di ;取出字符串开始位置 pop dx ;取出目前的行数 这里按照参数传递的反顺序将参数pop出来（因为在栈里面所以需要相反的顺序）\n这里还要注意第一行：由于我们是通过call指令调用函数的，call指令会首先将IP寄存器里面的值push到栈里面，所以我们也必须先拿出来。\n对参数进行计算 然后就是通过这些参数对数据进行计算和传输：\ninc dx ;将行数变为下一行 push dx push ax dec dx ;将行数变回来进行计算 mov al, 160 mul dl mov si, ax ;将运算结果放在si中 这里首先将dx自增1，然后放入栈里面表示。这样表示下一次绘制字符就是从下一行开始了。然后将ax的值push进去（最后ret指令会用到这个值来返回到原来call指令执行的地方）。然后将dx变为原来的值参与计算。通过mul指令计算出现在应该写到哪个地址去，并且将结果存储在si中。\n将数据传输到屏幕上 然后就是传输数据到屏幕上了：\ns: mov bh, ds:[di] mov byte ptr es:[si], bh mov byte ptr es:[si+1], bl inc di add si, 2 loop s 这里di在数据段中移动，将数据段中的数据取出来。si在显示区域(BF000H~BFFFFH)中移动，将数据放入显示内存中。bh存储着字符的属性，bl存储着字符。\n传输完成之后就要返回了:\nret 最后代码 ;这个程序在屏幕上显示数据段内的字符 assume cs:codeseg, ds:dataseg, ss:stackseg dataseg segment db 'welcome to masm' db 'created by VisualGMQ 2019.8.10' dataseg ends stackseg segment dw 10 dup (0) stackseg ends codeseg segment start: mov ax, stackseg mov ss, ax mov sp, 20 mov ax, 0 push ax ;将行数写入 ;配置ds和es mov ax , 0b800H\t;这里如果开头是a~f的话必须再加上0，不然会被认为是字符而不是十六进制数字 mov es, ax mov ax, dataseg mov ds, ax ;开始写文字 mov ax, 0 push ax mov ax, 15 push ax mov ax, 0000000000001010B push ax call write mov ax,15 push ax mov ax, 30 push ax mov ax, 0000000000000001B push ax call write mov ax, 4c00H int 21H ;@fn 这个函数将数据段里面的文字输出一行（末尾换行） ;这个函数的参数放在栈里面 ;@param ; 字符串开始的位置 ; 字符串的长度 ; 这一行字符串的属性信息（放在低字节中） write: pop ax ;先把call指令传入的原IP的值拿出来 pop bx ;取出这一行字符串的属性信息 pop cx ;取出字符串长度 pop di ;取出字符串开始位置 pop dx ;取出目前的行数 inc dx ;将行数变为下一行 push dx push ax dec dx ;将行数变回来进行计算 mov al, 160 mul dl mov si, ax ;将运算结果放在si中 s: mov bh, ds:[di] mov byte ptr es:[si], bh mov byte ptr es:[si+1], bl inc di add si, 2 loop s ret codeseg ends end start 结果是:\n总结 不要忘记call指令会将IP的值放入栈中，要在所有参数之前读取出来 不要忘记参数是反过来读取的 ","description":"","tags":["asm"],"title":"8086汇编语言-如何使用栈传递参数","uri":"/posts/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%A0%88%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/"},{"categories":null,"content":"在学习OpenGL的时候，或者在使用其他的3D引擎的时候总会遇到投影矩阵。这里就对投影矩阵进行推导 这里只推导透视投影，如果会了透视投影矩阵的推导平行投影矩阵其实也是一样的。\n坐标系 首先是坐标系。坐标系分为左手坐标系，右手坐标系： 记忆的话很简单： 首先要记住每个手指👋对应的坐标轴：拇指——x，食指——y，中指——z。 然后将三个手指互相垂直形成三个坐标轴互相垂直的情况。 然后拇指指向右边。如果是左手坐标系就用左手，右手坐标系就用右手。这样就可以得到左右手坐标系了。\n投影矩阵概念 之所以需要投影矩阵，是因为屏幕本身是2D的，我们需要将3D中的点投影到屏幕中，也就是将3D投影到2D中。\n透视投影是根据人的视觉成像来设计的： 而平行投影（或者称为正投影）的投影线是直的： 在游戏编程中为了模拟人眼看到的，需要用到透视投影。\n透视投影推导 首先来看一下透视投影的概念图： 这里后面的那个锥体就是视锥体，紫色的被称为近平面，蓝色的被称为远平面。在视锥体中的所有点都会被投影到近平面中，也就是会产生这样的映射: 这里保留了z轴的映射，为了OpenGL或者我们自己进行深度测试。\n那么要如何做到呢？推导如下： 首先定义一些值：\n近平面到原点的距离是n 远平面到原点的距离是f 然后要定义近平面的各个点的坐标： 那么这样就OK了，需要注意的是这里的$l,r,t,b$都是距离，也就是说都是正的（所以坐标上面有负数）\n然后就是公式推导了：\n首先我们需要计算在视锥体内的$p$点在近平面上的投影$p^{'}$的坐标。这很简单： 首先已经确定了$p^{'}$的$z$坐标是$n$，然后使用相似三角形可以得到： $$ \\frac{n}{z}=\\frac{x^{'}}{x}=\\frac{y^{'}}{y} $$ $$ \\begin{cases} x^{'}=\\frac{n}{z}x \\\\ y^{'}=\\frac{n}{z}y \\end{cases} $$ 然后我们需要将$x^{'},y^{'}$的值映射到[-1,1]上，由于$p^{'}$在近平面上，所以有这样的不等式： $$ \\begin{cases} l\\leq x^{'}\\leq t \\\\ b\\leq y^{'}\\leq t \\end{cases} $$\n然后变换一下： $$ \\begin{cases} l\\leq x^{'} \\leq r \\\\ b\\leq y^{'} \\leq t \\end{cases} \\Rightarrow \\begin{cases} 0\\leq x^{'}-l \\leq r-l \\\\ 0\\leq y^{'}-b \\leq t-b \\end{cases} \\Rightarrow \\begin{cases} 0\\leq \\frac{1}{r-l}x^{'} \\leq 1 \\\\ 0\\leq \\frac{1}{t-b}y^{'} \\leq 1 \\end{cases} \\Rightarrow \\begin{cases} 0\\leq 2\\frac{1}{r-l}x^{'} \\leq 2 \\\\ 0\\leq 2\\frac{1}{t-b}y^{1} \\leq 2 \\end{cases} \\Rightarrow \\begin{cases} -1\\leq 2\\frac{1}{r-l}-1x^{'} \\leq 1 \\\\ -1\\leq 2\\frac{1}{t-b}-1y^{'} \\leq 1 \\end{cases} \\Rightarrow $$ $$ \\begin{cases} -1\\leq \\frac{2nx}{z(r-l)}-\\frac{l+r}{r-l} \\leq 1 \\\\ -1\\leq \\frac{2ny}{z(t-b)}-\\frac{t+b}{t-b} \\leq 1 \\end{cases} \\Rightarrow \\begin{cases} -1\\leq [\\frac{2n}{r-l}x - \\frac{l+r}{r-l}z]/z \\leq 1 \\\\ -1\\leq [\\frac{2n}{t-b}y - \\frac{t+b}{t-b}z]/z \\leq 1 \\end{cases} $$ 这里最后两步的变换是将上面使用相似三角形得到的等式放入得到的。 最后上面的公式可以得到： $$ \\begin{cases} x^{''}=(\\frac{2n}{r-l}x - \\frac{l+r}{r-l}z)/z \\\\ y^{''}=(\\frac{2n}{t-b}y - \\frac{t+b}{t-b}z)/z \\end{cases} (result1) \\Rightarrow \\begin{cases} zx^{''}=\\frac{2n}{r-l}x - \\frac{l+r}{r-l}z \\\\ zy^{''}=\\frac{2n}{t-b}y - \\frac{t+b}{t-b}z \\end{cases} (result2) $$ 这里$x^{''},y^{''}$是最后映射到立方体上的点的坐标。\n现在我们得到了最后映射点的$x^{''},y^{''}$坐标，还差$z^{''}$坐标。因为原本的$z$坐标和$x,y$是无关的（废话，$z$的值本身等于$n$啊），所以我们认为最后映射点的$z^{''}$坐标也和$x^{''},y^{''}$无关，那么通过$x^{''},y^{''}$的式子，我们推测出应该有如下等式： $$ z^{''}z=pz+q ^* $$ 如何解这个式子中的$z^{''}$呢？我们可以将近平面的距离$n$和远平面距离$f$代入求的，因为我们知道最后是将视锥体映射到单位正方体上，所以很显然$n$最后会映射到$1$处，$f$会映射到$-1$处，那么我们就有条件： $$ \\begin{cases} z = n \\\\ z^{''} = 1 \\end{cases} , \\begin{cases} z = f \\\\ z^{''} = -1 \\end{cases} $$ 那么代入上述式子$(*)$可以解得方程的结果为： $$ \\begin{cases} p = \\frac{n+f}{n-f} \\\\ q = -2\\frac{2nf}{n-f} \\end{cases} $$ 那么我们的$z^{''}$也就知道了： $$ \\begin{cases} z^{''} = \\frac{n+f}{n-f}z - \\frac{2nf}{n-f} \\end{cases} $$ 需要注意的是：这里的n,f也是距离，所以这里n,f前面要加负号（他俩在z轴负方向上）： $$ zz^{''} = -\\frac{f+n}{f-n}+\\frac{2nf}{n-f} $$\n那么综上： $$ \\begin{cases} zx^{''}=\\frac{2n}{r-l}x - \\frac{l+r}{r-l}z \\\\ zy^{''}=\\frac{2n}{t-b}y - \\frac{t+b}{t-b}z \\\\ zz^{''} = -\\frac{f+n}{f-n}+\\frac{2nf}{n-f} \\end{cases} $$ 这是一个线性方程组，完全可以放入矩阵中： $$ \\begin{bmatrix} \\frac{2n}{r-l} \u0026 0 \u0026 \\frac{l+r}{l-r} \u0026 0 \\\\ \\frac{2n}{t-b} \u0026 0 \u0026 \\frac{t+b}{t-b} \u0026 0 \\\\ 0 \u0026 0 \u0026 \\frac{f+n}{n-f} \u0026 \\frac{2nf}{n-f} \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\end{bmatrix} $$ 这里可能有人会问为什么最后一行第三个元素是1，因为你前面的线性方程组中左边的未知数不是$x^{''},y^{''},z^{''}$而是$zx^{''},zy^{''},zz^{''}$，所以要多乘上一个$z$来保持原式，这个1就是这个作用。\n这里还有一个问题：不是说要将三个坐标映射到[-1,1]上吗？你上面那个结果等式左边可是$zx^{''},zy^{''},zz^{''}$，这怎么映射到[-1,1]上？。其实这一步是为了OpenGL准备的。OpenGL在将点左乘完透视投影矩阵之后，会自己再将生成点的坐标除以$z$，这一步叫做透视除法。当然如果你是自己写游戏引擎，不想要透视除法的话完全可以使用result1公式，将里面的$z$变为$n$，然后继续推导。\n这里还需要注意一次**$b,l$是距离，前面要加上负号**，所以最后的矩阵为： $$ \\begin{bmatrix} \\frac{n}{r} \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\frac{n}{t} \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 \\frac{f+n}{n-f} \u0026 \\frac{2nf}{n-f} \\\\ 0 \u0026 0 \u0026 -1 \u0026 0 \\end{bmatrix} $$ （这里最后一行变为-1是因为整个视锥体在z轴的负半轴上，除的z值是负数(也即是除以-n))\n透视矩阵的其他表示形式 除了使用$l,r,b,t,n,f$参数表示透视矩阵以外，一般的游戏引擎还会使用俯仰角fov，近平面距离n，远平面距离f，宽高比pro四个参数来计算投影矩阵。这也很简单： $$ \\frac{h}{2} = n\\tan{\\frac{fov}{2}} , w=pro*h=2npro\\tan{\\frac{fov}{2}} \\Rightarrow t = \\frac{h}{2}=n\\tan{\\frac{fov}{2}} , r = \\frac{w}{2}=n*pro*\\tan{\\frac{fov}{2}} $$ 代入式子中就可以得到矩阵为： $$ \\begin{bmatrix} \\frac{\\cot{\\frac{fov}{2}}}{pro} \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\cot{\\frac{fov}{2}} \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 \\frac{f+n}{n-f} \u0026 \\frac{2nf}{n-f} \\\\ 0 \u0026 0 \u0026 -1 \u0026 0 \\end{bmatrix} $$\n其实投影矩阵的表示形式很多，主要还是要学会推导\n参考 变换先森的博客\n","description":"","tags":["OpenGL"],"title":"透视投影矩阵的推导","uri":"/posts/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8E%A8%E5%AF%BC/"},{"categories":null,"content":"碰撞检测的包围盒一般分为三种：\nAABB包围盒：就是所谓的无矩形包围盒 OBB包围盒：就是可旋转矩形包围盒 多边形包围盒 对于AABB类型的包围盒的碰撞检测很简单，但是对于OBB和多边形的碰撞检测则比较困难。这里主要说明SAT算法，并且将SAT算法应用到OBB包围盒中（多边形同理）。\nSAT算法 SAT算法全名为分离轴定律（Separate Axis Theory），它的思想是：\n将一束平行光照射到物体上，如果在任何角度的照射下，两个物体的影子都会重合，那么这两个物体一定相交\n或者你也可以简单理解为“只要存在一个角度，导致影子不重合的话，就不会相交”或者“只要存在一条直线将两个物体分割开来，那么两个物体必然不相交”。\n那么我们在代码中要怎么实现呢？其实我们不需要“在任意方向上投影”，我们只需要在两个多边形所在的每个边上投影即可：\n如果其中存在任何一个边上的两个物体的投影不重合，那么这两个物体一定是分离的。相反，如果所有投影轴上的投影都是重合的，那么这两个物体一定是重合的。\nSAT算法比起其他的碰撞检测算法更加优秀的一点在于：可以在计算的过程中直接得到最小分离向量。所谓最小分离向量就是讲这两个物体分开的长度最小的向量。有了最小分离向量，我们就可以将两个物体分离了。\n最小分离向量的大小就是两个物体影子重合长度最小的那个长度（所有影子重合长度的最小值），方向就是重合长度最小的影子所在的投影轴的方向\nSAT是一个很通用的算法，普通的AABB或圆的碰撞检测算法也是可以从SAT推导出来的。\n实现 我们这里只实现OBB和OBB的碰撞检测，多边形的道理是一样的。\n思路 遵循大问题分解成小问题原则，首先考虑：如果对两个OBB使用SAT，由于OBB的对边是平行的，所以实际上不需要四条投影轴，而是两条就行了，这两条分别是：Vec2(obb1.rotation.GetAxisX(), obb1.rotation.GetAxisY()),Vec2(obb2.rotation.GetAxisX(), obb2.rotation.GetAxisY()) 。\n接下来要考虑在这两条投影轴上如何进行投影。这里我的方法是：将其中一个OBB的中点变为原点，并且将其xy轴视为新的xy轴，然后将两一个OBB在这个新坐标系下进行投影：\n这样的话，我们就连第一个OBB的投影都不需要算了：其在x轴上的投影区间就是[obb1.-half_w, obb1.half_w]，在y轴上的投影区间就是[obb1.-half_h, obb1.half_h]。这样我们只需要将注意力放到另一个OBB的投影上即可。\n这样的话，剩下的问题就变为：给定一个坐标系，计算OBB中一个边在这个坐标系下的投影。我们只需要分别对这个OBB的四个边进行计算，就可以得到其所有边的投影区间了。\n一些数据结构 首先，为了表示几何体和投影长度，我们要准备一些数据结构：\nOBB OBB的表示如下：\n1 2 3 4 5 6 7 struct OBB{ Vec2 center; Rot rotation; real half_w;\t//宽度的一半 real half_h;\t//高度的一半 OBB(Vec2 cent, real degree, real w_2, real h_2)； }; 其中Vec2是2D向量的类，由于向量计算的表示基本都差不多，在此不列举Vec2类的声明。\nRot是使用正弦值和余弦值表示旋转的类（借鉴自Box2D），之所以使用正弦值和余弦值表示，是为了方便得到局部坐标轴：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u003ccfloat\u003e #define FLT_EQ(x, y) (abs(x-y)\u003c=FLT_EPSILON) class Rot{ public: Rot():s(0),c(0){} Rot(real degree){ Set(degree); } void Set(real degree){ s = sin(DEG2RAD(degree)); c = cos(DEG2RAD(degree)); } real GetDegree() const{ return asin(s); } //通过这个函数得到OBB旋转后的X轴 Vec2 GetAxisX() const{ return Vec2(c, s); } //通过这个函数得到OBB旋转后的Y轴 Vec2 GetAxisY() const{ return Vec2(-s, c); } bool operator==(const Rot\u0026 rot) const{ return FLT_EQ(rot.s, s)\u0026\u0026FLT_EQ(rot.c, c); } bool operator!=(const Rot\u0026 rot) const{ return !(*this==rot); } private: real s;\t//sin value real c;\t//cos value }; FLT_EQ宏是使用减法来判断两个浮点数是否相等的宏，FLT_EPSILON则是C++头文件\u003ccfloat\u003e中的常量。\n区间 由于我们要计算投影的重合长度，所以这里先定义区间：\n1 2 3 4 5 6 7 8 9 10 class Range{ public: Range(real a, real b); //自动判断谁大谁小，并赋值给min和max real Min() const;\t//返回min real Max() const;\t//返回max real Len() const; //返回max-min private: real min; real max; }; 函数 首先来看一下如何将一个OBB的所有点转换到另一个坐标系，如果你学过线性变换会很简单，但是我们这里仍然使用向量数学来推导一下，看图即可明白:\n这里v1显然是obb1.center，v2则可以通过obb2.center-obb1.center得到。\n然后是v3和v4，有了v3和v4我们才能得到OBB的四个点。由于我们可以通过obb2.rotation.GetAxisX(), obb2.rotation.GetAxisY()来得到其x，y轴的单位向量，所以: $$ axis_x = obb2.rotation.GetAxisX();axis_y=obb2.rotation.GetAxisY() $$\n$$ v3 = (obb2.center+axis_xobb2.half_w,obb2.center+axis_yobb2.half_h) $$\n$$ v4 = (obb2.center+axis_xobb2.half_w,obb2.center-axis_yobb2.half_h) $$\n那么显然，其四个点相对于O'的坐标就是： $$ dir = obb2.center-obb1.center;p1=dir+v3-v4;p2=dir+v3+v4;p3=dir-v3-v4;p4=dir-v3+v4 $$ 接下来就需要将其四个点的坐标转化为在x'O'y'下的坐标了。很简单，将p1,p2,p3,p4投影到x'和y'上，计算出新的坐标即可。\n那么最后转换的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 Vec2 axis_x = obb2.rotation.GetAxisX()*obb2.half_w;\tVec2 axis_y = obb2.rotation.GetAxisY()*obb2.half_h; Vec2 points[4] = { axis_x+axis_y + obb2.center, axis_x-axis_y + obb2.center, -axis_x-axis_y + obb2.center, -axis_x+axis_y + obb2.center }; Coord coord(obb1.center, obb1.rotation); for(int i=0;i\u003c4;i++) points[i] = CoordConvert(points[i], coord); 这里Coord是用于表示坐标系的结构体，CoordConvert是将点转化到坐标系的函数:\n1 2 3 4 5 6 7 8 9 10 11 12 struct Coord{ Rot rotation; Vec2 center; Coord(Vec2 cent, real degree); Coord(Vec2 cent, Rot rot); }; Vec2 CoordConvert(Vec2 point, Coord coord){ Vec2 dir = point-coord.center; //Dot是两个向量的点积 return Vec2(Dot(dir, coord.rotation.GetAxisX()), Dot(dir, coord.rotation.GetAxisY())); } 然后就要考虑，如果将已经转化过的坐标投影到新坐标系下了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //assume points[4] are relate coord bool __linevsobb(Vec2 axis, real half_len, Vec2 points[4]){ bool result = false; for(int i=0;i\u003c3;i++)//这里分别对OBB2的四条边进行投影和判断 result = result||__lineprojline(axis, half_len, points[i], points[i+1]); result = result||__lineprojline(axis, half_len, points[3], points[0]); //使用逻辑或表示如果存在两条边的投影重合，则相交 return result; } //assume p1, p2 is local coord //这个函数会将边投影，并且计算出投影的重合度 bool __lineprojline(Vec2 axis, real half_len, Vec2 p1, Vec2 p2){ Range r1(ProjectEffect(p1, axis), ProjectEffect(p2, axis)),\t//将p1,p2投影到坐标系 r2(-half_len, half_len);\t//由于OBB1原本就是以自己为坐标系，所以我们就直接给出其投影区间，不用计算 //计算重合度 if(__get_range_cover_len(r1, r2)==0)\t//如果重合长度为0，那么返回false，表示这两条边没有重合 return false; return true; } //计算两个区间重合长度的函数 real __get_range_cover_len(Range range1, Range range2){ if(range1.Min()\u003crange2.Min()){ if(range1.Max()\u003erange2.Min() \u0026\u0026 range1.Max()\u003crange2.Max()) return range1.Max()-range2.Min(); else if(range1.Max()\u003e=range2.Max()) return range2.Len(); }else{ if(range1.Min()\u003crange2.Max()) if(range1.Max()\u003c=range2.Max()) return range1.Len(); else if(range1.Max()\u003erange2.Max()) return range2.Max()-range1.Min();\t} return 0; } 这样最后我们将上面的函数整合起来：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 bool __onewayobbtest(const OBB\u0026 obb1, const OBB\u0026 obb2){ //先进行坐标变换 Vec2 axis_x = obb2.rotation.GetAxisX()*obb2.half_w;\tVec2 axis_y = obb2.rotation.GetAxisY()*obb2.half_h; Vec2 points[4] = { axis_x+axis_y + obb2.center, axis_x-axis_y + obb2.center, -axis_x-axis_y + obb2.center, -axis_x+axis_y + obb2.center }; Coord coord(obb1.center, obb1.rotation); for(int i=0;i\u003c4;i++) points[i] = CoordConvert(points[i], coord); //然后判断在(0,1)轴上投影是否重合 if(!__linevsobb(Vec2(0, 1), obb1.half_h, points)) return false; //判断在(1,0)轴上投影是否重合 if(!__linevsobb(Vec2(1, 0), obb1.half_w, points)) return false; return true; } 注意这个函数只是将一个OBB的四个边作为投影轴。SAT要求另个多边形的所有边都得作为投影轴，所以最后：\n1 2 3 4 bool OBBvsOBB(const OBB\u0026 obb1, const OBB\u0026 obb2){ //如果所有投影轴中存在重合，返回true表示碰撞了 return __onewayobbtest(obb1, obb2) \u0026\u0026 __onewayobbtest(obb2, obb1); } 结果：\nSAT的优缺点 优点：\n可以对于任意的多边形进行碰撞检测，甚至是圆和多边形的碰撞检测（见参考中的网页） 可以得知最小分离向量 缺点：\n计算量很大 对OBB的SAT优化 有一个优化方式是，如果两个OBB的旋转角度一样的话，可以直接通过坐标变换将这个问题转化为两个AABB的碰撞检测问题：\n1 2 3 4 5 6 7 bool OBBvsOBBSame(const OBB\u0026 obb1, const OBB\u0026 obb2){ Coord coord(obb1.center, obb1.rotation); Vec2 relate_center = CoordConvert(obb2.center, coord); AABB aabb1(-obb1.half_w, -obb1.half_h, obb1.half_w, obb1.half_h), aabb2(relate_center.x-obb2.half_w, relate_center.y-obb2.half_h, relate_center.x+obb2.half_w, relate_center.y+obb2.half_h); return AABBvsAABB(aabb1, aabb2); } 这样可以避免投影，节省很多的速度。\n参考 CSDN博客\nN网站的教程\ngamedevelopment网站的教程，很全\n","description":"","tags":null,"title":"OBB包围盒的碰撞检测(SAT算法)","uri":"/posts/obb%E5%8C%85%E5%9B%B4%E7%9B%92%E7%9A%84%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"categories":null,"content":"无论是在Mac下还是Windows下，在DosBox里（或者cmd）将汇编程序变为exe文件总是要先masm和link，而这两个工具总是要用户自己输入文件名称。什么？你说windows下可以用Makefile？我知道，但是如果是像我这样的Mac用户在DosBox里面生成的话会很麻烦（最重要的是DosBox里面不支持make命令。。。）。所以这里提出一个方法来自动化生成。\n自动化生成 虽然DosBox下没有make工具，但是有批处理程序啊。我们可以使用批处理程序来自动化构建，比如我现在想要构建./codes/new/hello.asm，那么我们可以这样做：\n1 2 3 4 5 6 ::写在make.bat文件下 masm codes\\new\\hello.asm codes\\new\\build\\hello.obj; link codes\\new\\build\\hello.obj; copy hello.exe codes\\new\\build\\hello.exe delete hello.exe cls 第一行通过使用masm来得到hello.obj文件。\n第二行通过link命令链接hello.obj文件，需要注意的是，这个时候生成的hello.exe在当前目录下。你问我为什么不像masm一样直接给出输出文件？我也想，但是link这个程序既不像masm一样的格式指定输出文件，也没有-o这样的指令，最蛋疼的是连帮助文档都没有（如果你输入masm -h可以看到其帮助文档）。所以只有先生成在当前目录下了。\n第三行通过copy函数将当前目录的hello.exe文件拷贝到你指定的目的地下，第四行再删除当前目录的hello.exe文件。你问我为什么不直接使用move指令？我不知道你们的DosBox有没有，反正我的DosBox里面没有这个指令。。。\n最后一行清屏，你要是不想也可以去掉这一行\n因为批处理文件会首先将要执行的命令输出出来，然后再执行，这样显得文本很乱。你可以在开头使用@echo off命令关闭命令输出：\n1 2 3 4 5 6 7 @echo off echo \"start compil\" masm codes\\new\\hello.asm codes\\new\\build\\hello.obj; echo \"start link\" link codes\\new\\build\\hello.obj; copy hello.exe codes\\new\\build\\hello.exe delete hello.exe 这里不要用中文，会出现乱码。\n自动化删除 有了make程序怎么能没有clean程序呢！假设我们所有的代码都放在./codes/build/目录下，那么我们可以这样写：\n1 2 ::放在clean.bat中 delete codes\\new\\build\\*.* 注意这里最后必须是*.*，和Unix系统不一样。\n更进一步的make.bat 我们还可以使用变量到make.bat中：\n1 2 3 4 5 6 7 8 9 10 ::这是注释 @echo off set SRC_PATH=codes\\new\t::set来设置变量的值 set BUILD_PATH=codes\\new\\build echo \"start compile\" masm %SRC_PATH%\\hello.asm %BUILD_PATH%\\hello.obj;\t::通过%varname%来使用变量 echo \"start link\" link %BUILD_PATH%\\hello.obj; copy hello.exe %BUILD_PATH%\\hello.exe delete hello.exe 这样就可以防止重复修改编译和生成路径了\n","description":"","tags":null,"title":"DosBox内自动化编译链接汇编程序","uri":"/posts/dosbox%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"我们写了一个Linux汇编程序，要怎么去编译呢。\n普通文件编译 as,ld编译链接 首先我们可以使用as汇编器和ld链接器，比如对于下面的代码:\n#cpuid.asm中 .section .data output: .ascii \"The processor Vendor is xxxxxxxxxxxx\\n\" .section .text .globl _start _start: #首先调用cpuid指令获得cpu信息 movl $0, %eax cpuid #将信息放入字符串output中 movl $output, %edi movl %ebx, 24(%edi) movl %edx, 28(%edi) movl %ecx, 32(%edi) #调用终端服务输出字符串 movl $4, %eax movl $1, %ebx movl $output, %ecx #字符串开头放在exc中 movl $37, %edx #字符串长度放在edx中 int $0x80 #程序返回 movl $1, %eax movl $0, %ebx int $0x80 我们可以先用as编译成中间文件：\n1 as -o cpuid.o cpuid.asm 然后链接：\nld -o cpuid cpuid.o 然后就可以运行了。\ngcc编译连接的问题 书上还说可以直接使用gcc编译，但是程序入口要是main而不是_start。但是经过测试发现按照书上的方法是不行的。因为当时书上的代码是在32位系统下运行的，我们这里是64位的，不能够编译。在网上查找了很多方法也都无济于事(比如加上-m32，安装库啊什么的都不行)。所以这里就不介绍使用gcc编译的过程了。老老实实使用as和ld吧\n带有C库的文件编译 如果你想要使用C库函数的话，那么你得这样编译：\nas --32 -o file.o file.asm ld -m elf_i386 -dynamic-linker /lib/ld-linux.so.2 -o file -lc file.o 这里由于我们使用的是32位汇编，所以在编译的时候需要加上--32指定是32位的。然后在链接的时候由于用到了c库所以需要用-lc来链接c库，然后还要-dynamic-linker /lib/ld-linux.so.2链接ld-linux.so.2库，然后由于这两个库都是64位的，所以还要-m elf_i386指定以32位形式链接。\n参考链接 汇编 bash: ./cpuid: Accessing a corrupted shared library\n","description":"","tags":["asm"],"title":"Unix编译汇编程序","uri":"/posts/unix%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91/"},{"categories":null,"content":"介绍 在学习完Dos系统的16位8086汇编语言之后，继续学习在Linux系统上的32位汇编语言。\n32位汇编和16位汇编的一些区别 寄存器名称的区别 所有通用寄存器名称前面都需要有e，也就是说寄存器名称现在变为：\neax,ebx,ecx,edx,edi,esi,esp,ebp\n特用寄存器名称没有变，也就是:ss,cs,ds\n需要注意的是，32位寄存器没办法像16位寄存器那样分成两个：\n但是16位的规则仍然适用。\n指令种类 汇编语言中的指令有两种：\nAT\u0026T指令：由AT\u0026T下的Bell实验室开发，我们用的就是这种指令\nintel指令：由intel公司开发，在8086汇编语言中用的就是这种指令\nAT\u0026T指令和intel的区别 首先是移动指令：\n#AT\u0026T Intel movl mov lword ptr\t#移动32位数据/寄存器 movw\tmov word ptr\t#移动16位数据/寄存器 movb\tmov byte ptr\t#移动8位数据/寄存器 movq\tmov qword ptr\t#在64位系统中移动64位数据/寄存器 可以看出AT\u0026T的指令比较精简。\n然后是移动的方向，在Intel中，我们是将后面的参数移动到前面去，但是在AT\u0026T中是将前面的参数移动到后面去，而且如果是立即数的话必须加上$，如果是寄存器的话必须加上%:\nmovl $0x32, %eax\t#将0x32放入eax寄存器中 movl %eax, %ebx\t#将eax寄存器的值放入ebx中 还有很多的指令都是在后面加l,b,w来指定传输数据的字节数，比如：\npushl movx指令详细解释 对于movx指令（x可以使l,w,b,q），先看看下面几个例子：\nmovl $12, %eax\t#将12送入eax movl %eax, %ebx\t#将eax值送入ebx movl $output, %eax\t#将标号处地址送给eax movl %eax, (%ebx)\t#将eax的值送到ebx存储的地址所指的内存上 movl (%eax), %ebx\t#将eax所指内存的值送给ebx 这里标号后面会说道，最主要的是最后两个指令。其实用一个图就可以解释了：\n也就是说，在你不加上括号的时候，其使用的是寄存器内的值。加上括号的话，会将寄存器视为指针，从而使用寄存器指向的地址的值。\nLinux汇编的Hello World Linux汇编的Hello World和Dos的Hello World也不一样，先来看看代码:\n.section .data text: .ascii \"hello world!\\n\" .section .text .globl _start _start: #调用中断服务直接输出 movl $4, %eax\t#中断子程序号eax需要存放4 movl $1, %ebx\t#中断子程序号ebx需要存放1 movl $text, %ecx\t#将字符串的开头地址放入ecx movl $13, %edx\t#将字符串长度放入edx int $0x80\t#执行0x80号中断来输出字符串到控制台 movl $1, %eax movl $0, %ebx int $0x80 首先，在Linux下写汇编的框架如下：\n.section .data\t#数据存放的地方，这里的数据会放到程序里面 #... .section .bss\t#数据存放的地方，这里的数据是程序在运行的时候动态分配的，所以不会放到程序里面，因而也就不能有初始值 #... .section .text\t#代码存储的地方 .globl _start\t#指定汇编程序的入口，相当于C语言的main _start:\t#开始编写代码 #...代码 movl $1, %eax movl $0, %ebx int $0x80 最后的三句话相当于8086里面的\nmov ah, 4cH int 21H 也就是程序返回。只不过在Linux下程序返回的中断服务编号不是21H，子程序的编号也不是4C而已。\n可以看出来，Linux汇编是使用.section来定义段的，而且不需要使用assume来将寄存器和段绑定（因为段的名称固定就是.data .bss .text，所以会默认绑定）。\n而且这里还有一个入口标签_start，一般默认的就是_start，如果在编译的时候不是_start会报错（也有办法在编译指令中指定入口标签，见编译）\n.data段 在.data中我们的代码如下:\ntext: .ascii \"hello world!\\n\" 这里使用了伪指令.ascii来定义一个字符串。在Linux汇编中有很多这样方便的伪指令，比如.asciz会在定义字符串的最后加上\\0，.int定义多个整数，.float定义多个小数等，主要用法和.ascii差不多：\nvalue: .int 9 pi: .float 3.14159 这里的text，value，pi都是标号，用于指向定义的数据的开头地址：\n同理，对于movl指令也有不同的作用:\nmovl $value, %eax\t#将9的内存地址放入eax中 movl value, %eax\t#将9放入eax中 .bss段 bss段里面可以使用.comm .lcomm来定义内存空间（会在程序运行的时候加载）：\n.section .bss .lcomm buffer 100 这里定义了标号为buffer的内存空间，有100字节。\n.lcomm声明的内存空间只属于这个程序，在全局范围内不能使用。\n.comm声明的空间在全局范围内可以使用。\n.text段 也就是代码段，一般会先使用.globl来定义此程序入口点，然后编写代码，最后返回。\n","description":"","tags":["asm"],"title":"Unix汇编介绍","uri":"/posts/unix%E6%B1%87%E7%BC%96%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"《汇编语言》书上使用的方法是在windows下的命令行执行masm和link等工具，但是Mac上并没有这些工具。所以这里我们只能自己想办法了。\n下载工具 首先我们需要下载工具，首先需要下载DosBox，这个各个平台都有版本，网址在这里。\n然后需要下载哪些要用到的工具（包括masm，link，debug等）。有人说，Mac下不是有nasm工具可以直接使用吗？没错，但是nasm的使用方式和需要的语法和masm有些地方不一样，对于像我这种初次学习汇编的人来说还是老老实实选择masm吧。网上这些工具比较难找，我这里所有工具都放在百度网盘了。链接失效了请发邮件(2142587070@qq.com)给我，我会及时补在这个链接里的。\n使用工具 下载完DosBox并安装之后，你应该有了这样一个图标：\n然后将汇编工具解压到一个目录下，比如~/Documents/program/asmtools/下\n然后打开DosBox，输入下面这个命令来将你的路径挂载到c盘：\n1 MOUNT c ~/Documents/program/asmtools/ 然后将路径切到c盘（后面就和windows下的命令提示符一样操作了）：\n1 c: 输入dir命令，回车之后就可以看到那些工具了。\n编译和链接一个汇编代码 注意：DosBox只能识别名称长度小于等于8的文件（后缀不算），如果大于其文件名称会有所改动。\n接下来编译和链接一个汇编代码吧，首先输入masm来打开masm程序，然后根据提示输入你的.asm文件，要输出的.obj文件等：\n注意在DosBox下路径分隔符是\\而不是/\n然后再使用link命令链接成exe文件：\n这样你就可以在./codes/new/文件夹下看见hello.exe文件了。\n参考文献 百度经验\n","description":"","tags":null,"title":"如何在Mac上配置汇编语言编译环境","uri":"/posts/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E9%85%8D%E7%BD%AE%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"},{"categories":null,"content":"最近发现了一个十分好用的日志库spdlog。这个库就连安装都很简单，你只需要brew install spdlog或者sudo apt-get install spdlog即可。\nspdlog是一个十分十分轻量级的，但是速度很快很快的库。缺点是有一些函数不支持线程安全。但是我们目前并不关心这些。\nspdlog的简单使用 spdlog是一个“要什么包含什么”的库，你想要什么功能就包含什么头文件。我们先包含spdlog.h文件来使用最最基础的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u003cspdlog/spdlog.h\u003e int main(int argc, char** argv){ spdlog::set_level(spdlog::level::err); spdlog::error(\"this is an error\"); spdlog::info(\"this is an info\"); spdlog::debug(\"this is debug\"); spdlog::warn(\"this is a warn\"); spdlog::critical(\"this is a critical\"); spdlog::info(\"{} a info {}\", 3.14159, false); return 0; } 这里我们没有使用命名控件spdlog，这样看上去更清楚。 首先你可以使用set_level函数来设置当前的日志等级，所有的等级如下（从大到小）： critical(致命错误) err(错误) warn(警告) info(信息) debug(调试) trace(跟踪) 最后显示出来的信息只会是你指定等级及其左边的等级日志，比如将等级设置为warn:\n这样info, debug, trace信息都不会被显示出来。 你也可以传入off来让所有信息都显示出来。\n格式化输出 spdlog设计的可以像python一样，使用{}作为占位符来输出：\n1 2 3 4 spdlog::warn(\"this is {} file warn {}\", \"VisualGMQ\", false); //output [2019-07-11 17:03:29.927] [warning] this is VisualGMQ file warn false 只要类重载了operator\u003c\u003c，那么就可以被日志输出。\n通过日志器（日志池？）来记日志 spdlog的最大优点在于他有很多很多的日志器来记录日志。你想要使用这些日志器的话需要包含相应的头文件。\n使用控制台日志器stdout_color_mt 首先你要包含头文件spdlog/sinks/stdout_color_sinks.h。所有的日志器的头文件都在sink目录下。 然后你需要声明日志器对象并且使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u003cspdlog/spdlog.h\u003e #include \u003cspdlog/sinks/stdout_color_sinks.h\u003e using namespace std; int main(int argc, char** argv){ auto console_log = spdlog::stdout_color_mt(\"console1\"); console_log-\u003eset_level(spdlog::level::info); console_log-\u003einfo(\"this is console info\"); console_log-\u003ewarn(\"this is console warn\"); console_log-\u003ecritical(\"this is console critical\"); spdlog::drop_all(); return 0; } 使用的方法和最基本的spdlog一样。你可以设置日志等级啊，或者输出不同等级的日志。 每次获得一个日志器，spdlog内部都会进行管理（其实stdout_color_mt是一个工厂方法，其参数是你的日志器的名称），可以通过spdlog::get()函数传入日志器的名称来获得日志器。 11行的drop_all()会释放所有的日志器。\n使用日志器的好处有：\n本日志器的日志等级设置不会影响到其他日志器 最后的输出信息会显示是哪个日志器输出的： 红色圈圈出来的那些就是日志器名称。\n使用文件日志器basic_file_sink 同样的，需要包含spdlog/sinks/basic_file_sink.h 然后像一般日志器使用即可，但是由于是文件日志器，其工厂函数还需要文件的名称才行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u003cspdlog/spdlog.h\u003e #include \u003cspdlog/sinks/basic_file_sink.h\u003e int main(int argc, char** argv){ auto file_log = spdlog::basic_logger_mt(\"filelog1\", \"./file1.txt\"); file_log-\u003einfo(\"this is file info\"); file_log-\u003ewarn(\"this is file warn\"); spdlog::drop_all(); return 0; } //output file1.txt中： [2019-07-11 16:52:47.932] [filelog1] [info] this is file info [2019-07-11 16:52:47.932] [filelog1] [warning] this is file warn 不过文件日志器每次记录不会将元数据覆盖掉。\n还有很多其他的logger，但是我现在还不怎么用，先把他们官网的教程放在这里吧，要用到的时候可以去查一查\"Sinks\"一章，wiki\n","description":"","tags":null,"title":"十分好用的spdlog日志库","uri":"/posts/%E5%8D%81%E5%88%86%E5%A5%BD%E7%94%A8%E7%9A%84spdlog%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":null,"content":"转http://ju.outofmemory.cn/entry/366396\n","description":"","tags":null,"title":"Mac如何将文件打包为dmg","uri":"/posts/mac%E5%A6%82%E4%BD%95%E5%B0%86%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%BAdmg/"},{"categories":null,"content":"Mac下找到第三方库有很多的办法，让我们一起来看一看吧。\n使用cmake找库 如果你使用的是cmake来构建工程的话，那么你可以在cmake中使用find_package函数来找到对应的库。这一点请看我的“CMake基础语法汇总”一文。\n使用pkg-config 第二种方法和Linux系统一样，你可以使用pkg-config来找到库。比如说我使用homebrew安装了SDL_image库，那么我就得写\n1 pkg-config --libs --cflags SDL_image 其中，如果你加上了—libs选项，这个命令会帮助你找到链接库，如果你加上了—cflags命令会帮助你找到头文件。\n你也可以同时指定多个：\n1 pkg-config --libs --cflags SDL_image SDL_ttf armadillo 如果发现pkg-config没有找到库，但是自己确实安装了库的话，你需要根据pkg-config的提示将.pc文件的路径放到环境变量里面:\n1 2 3 4 5 \u003e _posts pkg-config --libs --cflags opencv4 Package opencl was not found in the pkg-config search path. Perhaps you should add the directory containing `opencv4.pc' to the PKG_CONFIG_PATH environment variable No package 'opencv4' found 这里提示我们放入PKG_CONFIG_PATH变量中，首先我们需要找到库的.pc文件\n如何寻找.pc文件 源码编译 如果你是下载源代码手动编译的话，那么一般.pc文件都会在build文件夹下的pkgconfig文件夹里面，或者在build/lib里面。将这个文件夹路径放到PKG_CONFIG_PATH中就可以了：\n1 export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/Cellar/opencv/4.1.0_2/lib/pkgconfig 如果没有就在其他文件夹里面找一找，一般都在build文件夹下面\nhomebrew下载 如果你是用homebrew下载的话，一般homebrew下载的文件都会在/usr/local/Cellar文件夹下，去文件夹下先找到你的库所在文件夹，然后一般会有pkg-config文件夹，将这个文件夹的路径放到PKG_CONFIG_PATH中就OK了。\n使用pkg-config对XCode工程的好处 如果你擅长使用pkg-config的话，就算不是命令行编译，对使用XCode工程也有好处。你可以先用pkg-config命令找到要找的库的库目录和头文件目录，然后将这两者粘贴到XCode的header search path和library search path中即可让XCode找到库。\n直接使用framework Mac有一个好处就是，如果你的库可以编译成framework（后缀.framework），那么你可以直接使用这个framework而不需要一步一步查找libs和header file。 注意，后缀是.framework而不是.dylib，两者的图标一模一样\n终端编译 如果你是用的是编译器，你可以在后面加上-framwork命令来指定framework：\n1 g++ hello_triangle.cpp -o build/triangle `sdl2-config --libs --cflags` `pkg-config --libs --cflags glew` -framework OpenGL -std=c++11 这里就直接使用OpenGL framework来编译，无需寻找OpenGL的库和头文件了。\nXCode XCode也可以做到，在general一栏下面，就有添加framework，如果它列表里面没有给出framework，你可以点击add other framework，然后按住command+shift+g来打开路径栏输入路径找到库。\nMac系统自带OpenGL,OpenCL等库，可以直接使用。\n特殊查找方式 有些库你安装之后，它有自己的工具帮助你查找。比如wxWidgets和SDL2分别使用如下命令查找:\n1 2 sdl2-config --libs --cflags wx-config --libs --cflags 这种一般官方的说明文档里面会有\n","description":"","tags":null,"title":"Mac下如何找到第三方库","uri":"/posts/mac%E4%B8%8B%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"},{"categories":null,"content":"OpenAL的学习笔记\nOpenAL很好的入门文章：https://blog.csdn.net/zouxy09/article/details/7893162\nOpenAL官方的API文档：http://www.openal.org/documentation/OpenAL_Programmers_Guide.pdf\nOpenAL的API很少，也很容易懂，学起来也很简单\n","description":"","tags":null,"title":"OpenAL笔记","uri":"/posts/openal%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"OpenCL的学习笔记\nOpenCL的入门教程：https://blog.csdn.net/CharleeChan/article/details/79946932\n官方的OpenCL编程API指南：https://www.khronos.org/files/opencl22-reference-guide.pdf\n","description":"","tags":null,"title":"OpenCL学习","uri":"/posts/opencl%E5%AD%A6%E4%B9%A0/"},{"categories":null,"content":"这里我们来说一下C/C++如何对结构体进行读写。\n我尝试了一下，发现C++自带的FIO好像没有办法做到（也可能是我自己没有找到办法），但是C语言的函数是可以做到的。那么也就意味着C++可以做到了。\n我们首先定义一个结构体：\n1 2 3 4 5 6 7 8 9 10 struct member{ int a; int b; }; struct data{ member m1; member m2; string name; }; 如你所见，其中的data结构体就是我们要读写的结构体。接下来我们通过C语言的文件读写来将其写入到data.mem文件中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003cstring\u003e #include \"header.hpp\" using namespace std; int main(int argc,char** argv){ FILE* file = fopen(\"data.mem\", \"wb+\"); if(file == nullptr){ cout\u003c\u003c\"file can't open\"\u003c\u003cendl; return -1; } data d; d.m1.a=10; d.m1.b=20; d.m2.a=30; d.m2.b=40; d.name=\"VisualGMQ\"; fwrite(\u0026d, sizeof(d), 1, file); rewind(file); fclose(file); return 0; } 其中第8行打开了data.mem文件，然后第19行使用fwrite函数进行写入。fwrite函数可以直接将任何数据(void*)类型写入文件中。很好很强大。 第9行使用rewind()来保证写入操作执行了。最后关闭文件。\n当然，由于我们写入的是二进制数据，所以你打开data.mem也只能看到一些乱码。接下来我们就使用fread函数来直接读取：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \"header.hpp\" using namespace std; int main(int argc,char** argv){ FILE* file = fopen(\"data.mem\", \"rb+\"); if(file == nullptr){ cout\u003c\u003c\"file not open\"\u003c\u003cendl; return -2; } data d; fread(\u0026d, sizeof(d), 1, file); cout\u003c\u003c\"read suuccessful\"\u003c\u003cendl \u003c\u003c\"data.m1:\"\u003c\u003cendl \u003c\u003c\"a:\"\u003c\u003cd.m1.a\u003c\u003cendl \u003c\u003c\"b:\"\u003c\u003cd.m1.b\u003c\u003cendl \u003c\u003c\"data.m2\"\u003c\u003cendl \u003c\u003c\"a:\"\u003c\u003cd.m2.a\u003c\u003cendl \u003c\u003c\"b:\"\u003c\u003cd.m2.b\u003c\u003cendl \u003c\u003c\"name:\"\u003c\u003cd.name\u003c\u003cendl; fclose(file); return 0; } 这里和上面不一样的地方就是使用了fread函数读取，这个函数也是可以读取任意类型（void*）的。\n最后我们来看一下如何对内存进行操作。很简单，我们尝试通过内存拷贝直接将d变量的第一个成员m1拷贝到m中，你可以通过memcpy函数实现拷贝：\n1 2 3 4 5 member m; memcpy(\u0026m, \u0026d, sizeof(member)); cout\u003c\u003c\"strong cast successful\"\u003c\u003cendl \u003c\u003c\"m.a:\"\u003c\u003cm.a\u003c\u003cendl \u003c\u003c\"m.b:\"\u003c\u003cm.b\u003c\u003cendl; 这样就是直接对内存进行操作了。你可以将内存中的任意数据通过memset,memcpy等内存操作函数直接操纵。这就是C/C++厉害的地方。\n","description":"","tags":["cpp"],"title":"C/C++对结构体的读写以及操纵内存","uri":"/posts/c++%E5%AF%B9%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E8%AF%BB%E5%86%99%E4%BB%A5%E5%8F%8A%E7%9B%B4%E6%8E%A5%E6%93%8D%E7%BA%B5%E5%86%85%E5%AD%98/"},{"categories":null,"content":"C/C++宏的用法有很多，让我们来全面的了解#define语句\n#define语句的真正用法是文本的简单替换。可以用来定义有参宏，无参宏和各种乱七八糟宏。\n有参宏和无参宏的定义 1 2 #define print(str) std:cout\u003c\u003cstr\u003c\u003cendl; #define split() cout\u003c\u003c\"******************\"\u003c\u003cendl; 很简单对吧，你可以传入任意的文本进去，宏会帮你替换，比如\n1 print(a); 会被替换成\n1 std::cout\u003c\u003ca\u003c\u003cendl; 当然呢如果要想可以运行的话需要有变量a\n定义常量 宏也可以定义常量，其实我个人认为他是定义“常数”，因为它定义的常量在内存中并不占据空间。而是const定义的才占有空间。因为宏是简答替换嘛，所以也没什么可说的\n1 #define PI 3.1415926 宏里面的特殊符号 宏里面是可以使用特殊符号的，比如#,##,#@,\\四个符号。\n#符号 #符号是用来将有参宏里的参数变成字符串的。比如#define macro(varname) #varname这个宏，如果你调用macro(hello)会返回字符串\"hello\"。\n##符号 ##符号是将有参宏里面的变量和其他变量或者字符绑在一起的。比如宏#define macro(str1,str2) str1##str2调用macro(a,b)会产生ab。但是不会加上双引号，因为只是绑在一起，不是变成字符串。也可以和字符绑在一起： #define macro(a) x##a调用macro(2)产生x2。\n#@符号 这个符号将后面的变量加上单引号，其实和#符号差不多，只不过加上的是单引号\n\\符号 换行符号，如果宏太多一行写不下可以在行末使用这个换行。但是\\后面除了换行符之外不可以有别的字符，连空格都不可以。\n有了这些特殊符号，我们可以写出很多很方便的宏，比如:\n1 #define logvar(varname) std::cout\u003c\u003c#varname\u003c\u003c\":\"\u003c\u003cvarname\u003c\u003cendl; 这个用来调试变量，输出变量名和变量的值\n1 2 3 #define CREATE_PUB_VAR(type,name,initvalue) \\ public:\\ type name = initvalue; 这个用于在类里面声明一个public变量并给出初值。\n连接字符串的方式 你只需要将两个字符串放在一起（或者代表字符串的宏），就可以连接这两个字符串:\n1 2 #define STR \"this is \" \"MACRO\" //STR=\"this is MACRO\" #define MSG \"[info]\" STR //MSG=\"[info] this is MACRO\" 需要注意的是两个字符串之间必须有空格\n编译器预定义的宏 编译器自己也定义过一些宏：\n通用宏 __FUNC__:当前行存在哪一个函数里面 __DATE__:最后一次编译的日趋 __TIME__:最后一次编译的时间 __FILE__:这个文件的文件名称 __LINE__:这个宏所在的行号 _TIMESTAMP_：最后一次修改当前文件的时间戳\n这些一般都是通用的，但是如果是不同的编译器的话，还会给出一些有关操作系统和语言的宏：\n关于操作系统 __APPLE__:苹果系统会给出这个宏表示编译代码的编译器在苹果公司的系统上，但是没有说明是在MacOS还是IOS上，所以你还需要包含苹果系统的头文件\"TargetConditionals.h\"，这个头文件里面有一些宏供你使用： TARGET_OS_X:MacOS系统 TARGET_OS_IPHONE:IOS系统 还有很多的其他的宏就不一一列举了，具体见这里\n__linux,linux,__linux__:表示是linux系统，不同的编译器给出的宏不一样，基本上在这三个之内 WIN32,__WIN32,__WIN32__:表示windos系统 __ANDROID__:安卓系统 __MINGW32__:MINGW编译器 __ORBITS__:PS4平台 __CYGWIN__:cygwin编译器 _MSC_VER:vc++ __BORLANDC__:BorlandC编译器 __JETBRAINS_IDE__:jetbrains公司的IDE（一般都是CLION啦），这个宏本身的值表示是哪一版的IDE。\n接下来就是关于语言的宏\n关于语言的宏 __cplusplus:表示使用C++编译，其中__cplusplus这个宏本身的值就代表了使用的C++标准： c++98: 199711 c++03: 199711 c++11: 201103 c++14: 201402 c++17: 201703 对于微软，你需要判断这个宏 _MSVC_LANG\n其他有意思的宏 __COUNTER__:这个宏会随着它的每次出现而自增1，初始值为0. 比如你这么写：\n1 2 3 4 cout\u003c\u003c__COUNTER__\u003c\u003cendl; cout\u003c\u003c__COUNTER__\u003c\u003cendl; cout\u003c\u003c__COUNTER__\u003c\u003cendl; cout\u003c\u003c__COUNTER__\u003c\u003cendl; 那么会输出\n1 2 3 4 0 1 2 3 __has_include()这个宏里面放入头文件，他会检查你的头文件搜索路径中有没有这个文件。系统路径使用\u003c\u003e，自定义路径使用””，比如：\n1 2 3 #if __has_include(\u003ciostream\u003e) cout\u003c\u003c\"iostream is in include path\"\u003c\u003cendl; #endif ","description":"","tags":["cpp"],"title":"C/C++宏","uri":"/posts/c++%E5%AE%8F/"},{"categories":null,"content":"这里汇总了一些C/C++的知识点和注意点\nC++初始化规则 C++中除了全局变量和static变量可以被自动初始化，其他的所有变量都不能够被初始化（包括成员变量和局部变量），但是如果成员是类对象的话会调用其默认构造函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u003ciostream\u003e using namespace std; int global_i; class number{ public: number(int m_i){ m_i = m_i; } void info(){ int m_local_i; cout\u003c\u003c\"m_local_i:\"\u003c\u003cm_local_i\u003c\u003cendl; } int m_i; }; int main(){ static int static_i; int local_i; cout\u003c\u003c\"global_i:\"\u003c\u003cglobal_i\u003c\u003cendl \u003c\u003c\"static_i:\"\u003c\u003cstatic_i\u003c\u003cendl \u003c\u003c\"local_i:\"\u003c\u003clocal_i\u003c\u003cendl; number n(10); n.info(); cout\u003c\u003c\"m_i:\"\u003c\u003cn.m_i\u003c\u003cendl; return 0; } 但是如果类中存在其他类的实例，那么会初始化那个类的实例。\nC++数组越界问题 C/C++数组越界时编译器不会报错，你可以获得越界的数据。STL容器中的vector和array等在使用at()函数时才抛出异常。\n同名变量赋值问题 C++和Java一样，在类的成员函数赋值的时候不能够自己赋值自己，也就是说下面的代码中，两个x,y都是成员变量x,y，产生了自我赋值:\n1 2 3 4 5 6 7 8 9 10 class Point{ public: Point(int x, int y){ x = x; y = y; } private: int x; int y; }; 所以最后成员中的x和y的值其实都是未赋值的随机值。\nswitch的判断有类型限制 switch只能对宽泛整型来判断，也就是说只能判断字符型，整型和枚举。其他的判断不会报错，但是会有问题。\nenum和int的相互转换 enum可以隐式转换为int（甚至可以直接给enum中的item赋予整型值），但是int想要转换为enum需要强制转换。\nenum class 原本兼容C的enum有如下特点：\n枚举项是公开的，在全局下是全局的，在类中是属于类的 可以隐式转换为整型 第一点导致在同一作用域下不同的枚举类型不能够声明相同的枚举项：\n1 2 3 4 5 6 7 8 9 enum A{ E_A, E_B }; enum B{ E_B, //E_B重复了 E_C }; 第二种情况可能会引起隐患。所以C++11推出了enum class，有如下特点：\n具有封装性，即枚举量不再是全局的，访问也必须加上枚举类型的名字 不能和整型互相隐式转换 可以指定枚举类型中枚举值的变量类型 比如:\n1 2 3 4 5 6 7 8 9 10 11 12 13 enum class A{ E_A, E_B }; enum class B:unsigned int{ //这里使用:来指定枚举值的数据类型 E_B = 0, E_C }; //访问 A::E_A; //不能直接E_A int x = static_cast\u003cint\u003e(A::E_A); //需要强制转换 C++ cout的输出控制符 std::boolalpha内的才是控制符，ios::boolalpha内的是常量：\n1 2 3 4 cout\u003c\u003cboolalpha\u003c\u003cfalse\u003c\u003cendl; 等价于 cout.setf(ios::boolalpha); cout\u003c\u003cfalse\u003c\u003cendl; 不要用混了，其他的控制符同理。 而且setf是会一直改变ostream的格式的，所以你用完记得改回来（包括控制符也是）\nC++的引用和指针 引用就是给变量取别名，甚至连引用的变量的地址和原变量都一样。所以以下三种情况都是可以改变b的值的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u003ciostream\u003e using namespace std; void changed(int\u0026 a){ a = 10; } int main(){ int b = 20; int\u0026 rb = b; int* pb = \u0026b; changed(*pb); cout\u003c\u003cb\u003c\u003cendl; return 0; } 内存分配的注意事项 需要注意的是，我们可能会产生这样的错误:\n1 2 ClassA* obj = nullptr; obj = (ClassA*)malloc(sizeof(obj)); 虽然在C++中使用的是new运算符，但是我们不敢保证在C中使用memcpy, memset等函数不出错。\n出错的原因是sizeof(obj)的大小并不等于sizeof(ClassA)而是sizeof(ClassA*)这两种是完全不同的。指针的大小和其类型的大小在很多情况下并不相等。所以你必须得这样写:\n1 obj = (ClassA*)malloc(sizeof(ClassA)); 才能分配一个ClassA的内存\nC++ new赋予初值的问题 C++中如果你是对基本数据类型进行new的话是不会初始化的。但是如果你在最后加上()会初始化为0:\n1 2 int* p = new int; //no initialize int* p = new int(); //initialize 如果是类的话，如果类有默认构造函数，那么会调用默认构造函数（无论有没有加括号），如果没有你需要显式传入参数来调用构造函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u003ciostream\u003e using namespace std; class Person{ public: int age; int height; Person(int age, int height){ this-\u003eage = age; this-\u003eheight = height; } private: }; int main(int agrc, char** arhv){ Person* p = new Person(10, 170); cout\u003c\u003cp-\u003eage\u003c\u003cendl\u003c\u003cp-\u003eheight\u003c\u003cendl; return 0; } 如果是数组的话，基本数据类型仍然要加上()才能初始化。但是类的话必须要有默认构造函数，因为这个时候C++不允许你传入参数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u003ciostream\u003e using namespace std; class Person{ public: int age; int height; Person(){ age = 17; height = 170; } Person(int age, int height){ this-\u003eage = age; this-\u003eheight = height; } private: }; int main(int agrc, char** arhv){ Person* p = new Person[10]; //new Person[10](17,170)或者new Person(17,170)[10]都不可以 cout\u003c\u003cp[2].age\u003c\u003cendl\u003c\u003cp[2].height\u003c\u003cendl; delete[] p; return 0; } 关于内存释放的问题 假如有以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cassert.h\u003e typedef struct { int* array; }struct_a; typedef struct{ struct_a* a; }struct_b; typedef struct{ struct_b* b; }struct_c; int main(int argc, char** argv){ struct_c* c = NULL; while(1){ //malloc memory c = (struct_c*)malloc(sizeof(struct_c)); c-\u003eb = (struct_b*)malloc(sizeof(struct_b)); c-\u003eb-\u003ea = (struct_a*)malloc(sizeof(struct_a)); c-\u003eb-\u003ea-\u003earray = (int*)malloc(sizeof(int)*10); //free memory free(c); c = NULL; } return 0; } 这里的free(c)可以将c变量中的b变量，b变量中的a变量，a变量中的array一同释放掉吗？答案是不行的。对于使用多次malloc的内存，要相应地使用free()依次释放才可以：\n1 2 3 4 5 6 7 8 free(c-\u003eb-\u003ea-\u003earray); c-\u003eb-\u003ea-\u003earray = NULL; free(c-\u003eb-\u003ea); c-\u003eb-\u003ea = NULL; free(c-\u003eb); c-\u003eb = NULL; free(c); c = NULL; 对于C++的new和delete是一个道理。\n顺便说一下在Unix系统上判断内存泄漏的方法：将你认为会内存泄漏的代码放在死循环里面循环，然后用top -pid命令打印出这个程序的信息，查看MEM字段，如果其字段恒定不变的话，就没有泄漏，如果一直在增长就是泄漏了。\nswitch中的变量声明 在C/C++语言中，switch中是不能有变量声明的：\n1 2 3 4 5 6 7 8 switch(var){ case 1: int i=2; break; case 2: double j=3; break; } 这里编译器会给i和j报错:\n1 2 3 4 5 6 7 test.cpp:10:9: error: cannot jump from switch statement to this case label case 2: ^ test.cpp:8:17: note: jump bypasses variable initialization int i=2; ^ 1 error generated. 错误提示说跳过了变量声明。其实switch内部的每一个case跳转都是使用标号跳转（也就是goto语句），语法规定标号跳转是不能越过变量声明的，所以这里出错了。 当然下面的代码也是不行的：\n1 2 3 4 5 6 7 8 9 switch (a){ case 20: int b = 30; cout\u003c\u003cb\u003c\u003cendl; break; case 30: cout\u003c\u003c\"30\"\u003c\u003cendl; break; } 解决办法就是把声明放在花括号里变成局部的：\n1 2 3 4 5 6 7 8 9 10 switch (a){ case 20:{ int b = 30; cout\u003c\u003cb\u003c\u003cendl; break; } case 30: cout\u003c\u003c\"30\"\u003c\u003cendl; break; } 这样跳过局部变量声明是可以的，所以不会发生\nC++的文件IO C++的文件IO，关于ofstream的话，需要注意使用ios::app标志之后是不能改变文件指针的位置的，指针一直指向文件末尾。其余的都会将文件内容清除。 如果不想要清除文件内容的话，只能使用fstream并给入ios::in|ios::out标志才行。而且就算给出了in和out标志，其他标志在in和out状态下的作用是一样的。唯独清除整个文件的作用会失效（也就是说传入ate标志不会清除文件）。你不能传入app，因为同样会导致文件指针不能移动。 在ifstream中使用ios::trunc的话会导致打不开文件。\n函数返回引用的问题 函数返回引用的时候，如果你承接的变量不是引用的话，返回值仍然会拷贝一份给你。如果使用引用就没有问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u003ciostream\u003e using namespace std; class A{ public: A(){ a = 10; } int\u0026 GetA(){ cout\u003c\u003c\"origin a's address:\"\u003c\u003c\u0026a\u003c\u003cendl; return a; } private: int a; }; int main(int argc, char** argv){ A a; int na = a.GetA(); cout\u003c\u003c\"without \u0026:\"\u003c\u003c\u0026na\u003c\u003cendl; int\u0026 ra = a.GetA(); cout\u003c\u003c\"with \u0026:\"\u003c\u003c\u0026ra\u003c\u003cendl; na = 20; cout\u003c\u003c\"changed na:\"\u003c\u003ca.GetA()\u003c\u003cendl; ra = 30; cout\u003c\u003c\"changed ra:\"\u003c\u003ca.GetA()\u003c\u003cendl; return 0; } /** 输出： origin a's address:0x7ffee4adccd8 without \u0026:0x7ffee4adccd4 origin a's address:0x7ffee4adccd8 with \u0026:0x7ffee4adccd8 changed na:origin a's address:0x7ffee4adccd8 10 changed ra:origin a's address:0x7ffee4adccd8 30 */ 函数返回时拷贝构造函数，移动构造函数和operator=调用的次数 注：这个例子可能有瑕疵，因为可能没有关闭相应的编译器优化。\n通过下面代码来得到验证：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 #include \u003ciostream\u003e using namespace std; class A{ public: A(){ cout\u003c\u003c\"normal constructor called in \"\u003c\u003cthis\u003c\u003cendl; a = 10; } A(const A\u0026 oth){ cout\u003c\u003c\"copy constructor called in \"\u003c\u003cthis\u003c\u003cendl; a = oth.a; } A(A\u0026\u0026 oth){ cout\u003c\u003c\"move constructor called in \"\u003c\u003cthis\u003c\u003cendl; a = oth.a; } A\u0026 operator=(const A\u0026 oth){ cout\u003c\u003c\"operator= called in \"\u003c\u003cthis\u003c\u003cendl; a = oth.a; return *this; } int\u0026 GetA(){ return a; } static A GetInstance(){ A tmpa; cout\u003c\u003c\"tmpa in GetInstance:\"\u003c\u003c\u0026tmpa\u003c\u003cendl; return tmpa; } static A\u0026\u0026 GetMoveInstance(){ A tmpa; cout\u003c\u003c\"tmpa in GetMoveInstance:\"\u003c\u003c\u0026tmpa\u003c\u003cendl; return std::move(tmpa); } static A\u0026 GetRefInstance(){ cout\u003c\u003c\"tmpa in GetRefInstance:\"\u003c\u003c\u0026static_a\u003c\u003cendl; return static_a; } private: int a; static A static_a; }; A A::static_a; int main(int argc, char** argv){ A a; cout\u003c\u003c\"a's addr:\"\u003c\u003c\u0026a\u003c\u003cendl\u003c\u003cendl; A b = a; cout\u003c\u003c\"b's addr:\"\u003c\u003c\u0026b\u003c\u003cendl\u003c\u003cendl; A\u0026 ra = a; cout\u003c\u003c\"ra's addr:\"\u003c\u003c\u0026ra\u003c\u003cendl\u003c\u003cendl; A ma = std::move(a); cout\u003c\u003c\"ma's addr:\"\u003c\u003c\u0026ma\u003c\u003cendl\u003c\u003cendl; A fa = A::GetInstance(); cout\u003c\u003c\"fa's addr:\"\u003c\u003c\u0026fa\u003c\u003cendl\u003c\u003cendl; A fb = A::GetRefInstance(); cout\u003c\u003c\"fb's addr:\"\u003c\u003c\u0026fb\u003c\u003cendl\u003c\u003cendl; A\u0026 fra = A::GetRefInstance(); cout\u003c\u003c\"fra's addr:\"\u003c\u003c\u0026fra\u003c\u003cendl\u003c\u003cendl; A\u0026\u0026 fma = A::GetMoveInstance(); cout\u003c\u003c\"fma's addr:\"\u003c\u003c\u0026fma\u003c\u003cendl\u003c\u003cendl; return 0; } //编译： g++ main.cpp -o main -std=c++11 -fno-elide-constructors\t//最后的编译选项表示不使用构造函数优化 /**结果 normal constructor called in 0x100f4a100\t//这个是static_a的构造函数导致 normal constructor called in 0x7ffeeecb6c98 a's addr:0x7ffeeecb6c98 copy constructor called in 0x7ffeeecb6c90 b's addr:0x7ffeeecb6c90 ra's addr:0x7ffeeecb6c98 move constructor called in 0x7ffeeecb6c80 ma's addr:0x7ffeeecb6c80 normal constructor called in 0x7ffeeecb6bf8 tmpa in GetInstance:0x7ffeeecb6bf8 move constructor called in 0x7ffeeecb6c70 move constructor called in 0x7ffeeecb6c78 fa's addr:0x7ffeeecb6c78 tmpa in GetRefInstance:0x100f4a100 copy constructor called in 0x7ffeeecb6c68 fb's addr:0x7ffeeecb6c68 tmpa in GetRefInstance:0x100f4a100 fra's addr:0x100f4a100 normal constructor called in 0x7ffeeecb6bf8 tmpa in GetMoveInstance:0x7ffeeecb6bf8 fma's addr:0x7ffeeecb6bf8 normal constructor called in 0x7ffee3e1cbe8 tmpa in GetMoveInstance:0x7ffee3e1cbe8 move constructor called in 0x7ffee3e1cc50 fma2's addr:0x7ffee3e1cc50 */ 显然在A a = A::GetInstance()的时候，调用了两次移动构造函数。\n在A b = A::GetRefInstance()的情况下仍然会拷贝一次，说明使用非引用得到引用返回值并不能直接饮用（当然改变fb也没办法影响tmpa）。\n在A\u0026 ra = A::GetRefInstance()时可以视为直接引用。\n在A fma2 = A::GetMoveInstance()时会移动构造一次，拷贝构造一次，显然移动构造将原值移动给中间变量，然后再使用中间变量的拷贝构造。\n在A\u0026\u0026 fma = A::GetMoveInstance()时直接移动，没有多余的动作。\n在优化情况下的变化 这里比较有意思的是，如果你允许编译器优化（将编译的最后一个选项去掉），fa的构造过程会发生改变：\n1 2 3 4 5 /** normal constructor called in 0x7ffeee135c78 tmpa in GetInstance:0x7ffeee135c78 fa's addr:0x7ffeee135c78 */ 这是因为编译器优化的原因，导致中间两次移动构造失败。\n在没有移动构造函数下的变化 如果不定义移动构造函数，fa的构造过程将会变成这样：\n1 2 3 4 5 6 7 /** normal constructor called in 0x7ffee1398c08 tmpa in GetInstance:0x7ffee1398c08 copy constructor called in 0x7ffee1398c70 copy constructor called in 0x7ffee1398c78 fa's addr:0x7ffee1398c78 */ 也就是说调用了拷贝构造函数。所以存在移动构造函数时会有点调用移动构造函数，其次调用拷贝构造函数。\n各种情况的对比 这里是最后各种情况的对比(使用vimdiff比对)，分别是Cpp98下无优化无移动构造函数，Cpp11下优化有移动构造函数，Cpp11下无优化有移动构造函数，Cpp11下无优化无移动构造函数。\n返回右值临时变量是否有用 答案是没用。具体的你可以将上面的例子中加入析构函数来看fma的析构过程：\n1 2 3 4 5 6 /** normal constructor called in 0x7ffeeca22af8 tmpa in GetMoveInstance:0x7ffeeca22af8 deconstructor called in 0x7ffeeca22af8 fma's addr:0x7ffeeca22af8 */ 会发现fma得到之后直接析构了。所以返回临时变量的左值和右值都没有用，因为原变量会提前析构。\n如何编写log(const char* string, ...)类函数 这种函数的一个麻烦问题就是怎么在内部调用printf函数。\n其实很简单，使用vprintf,vfprintf, vsprintf,vsnprintf 即可。\n这四个函数都会接受一个字符串和va_list作为参数。其各自的用途分别是：\n将字符串当作format,并且输出va_list，其实就相当于printf 和vprintf一样，只不过是输出到文件中的 和vprintf一样，只不过是输出到另一个char[]中的 和vsprintf一样，但是可以制定前多少个字符串输出到char[]中 所以答案就很明显了：\n1 2 3 4 5 6 void Log(const char* string, ...){ va_list args; va_start(string, args); vprintf(string, args); va_end(args); } 重载取负函数 对于数学类，总是可以用到前置负号表示取相反数。这种重载函数的原型应当是：\n1 T operator -(); 注意符号前的空格。\n其实不需要每次都用全局的T operator-(const T\u0026 t)。\nstruct{char elem[0]}写法的意义 可能你会看到一些结构体中写:\n1 2 3 4 struct s{ //other elements char elem[0]; }; 为什么这里不直接使用指针呢?因为这样写的话整个结构体只需要malloc一次就可以了。\n比如按照指针的写法，你需要:\n1 2 s* ps = malloc(sizeof(s)); ps-\u003eelem = malloc(SIZE); 但是如果按照这种写法，你只需要:\n1 s* ps = malloc(sizeof(s)+SIZE); 即可。\n原因是你malloc一堆内存之后，内存是连续的，而C/C++是不对数组下标越界报错的。数组下标越界报错的真正原因是达到了不可访问的内存。而你现在多分配了SIZE个内存，这样elem元素就可以超出数组边界访问了。\n一句话将文件全部内容读入string 1 2 3 ifstream file(\"test.txt\"); string contex((istreambuf_iterator\u003cchar\u003e(file)), istreambuf_iterator\u003cchar\u003e()); 注意这里第一个参数外面的括号不能少。\n这里的原理是利用string的一个构造函数：以迭代器作为参数的那个构造函数。这里构造了istreambuf的迭代器，所以可以直接使用构造函数传入。\n","description":"","tags":["cpp","c"],"title":"C/C++小知识点，注意点汇总（持续更新）","uri":"/posts/c++%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B3%A8%E6%84%8F%E7%82%B9%E6%B1%87%E6%80%BB/"},{"categories":null,"content":"使用的库 我们使用的库是Jsoncpp库，是一个面向对象的C++库。\nJsoncpp的使用方法 ##使用准备 首先要包含头文件json.h，然后要使用命名空间Json。（下面为了清晰我们并没有使用Json命名空间）:\n1 2 #include \u003cjson.h\u003e //using namespace Json; Jsoncpp对文件的结构 Jsoncpp对文件的结构很简单：所有的花括号扩起来的都代表一个Json::Value，然后里面是键-值对。值可以是任意的基本数据，也可以是Json数组或者另一个Json::Value：\nJson文件的写入 Json文件的写入很简单，只要构造Json::Value就可以了。 由于Json首先就是以一个大括号（Json对象）开始的，所以我们先声明一个Json::Value:\n1 Json::Value root; 然后就可以通过类似map的方法添加键值对了：\n1 2 root[\"name\"] = Json::Value(\"VisualGMQ\"); root[\"age\"] = Json::Value(20); 这个时候的Json文件如下：\n1 2 3 4 { \"name\": \"VisualGMQ\", \"age\": 20 } 如果你想要添加另一个json对象也可以：\n1 2 3 4 5 6 7 Json::Value info; //给info添加元素 info[\"school\"] = \"AnHuiLiGongDaXue\"; info[\"credit\"] = \"2017303119\"; info[\"male\"] = true; //将info加到root里面 root[\"info\"] = info; 这个时候就变为：\n1 2 3 4 5 6 7 8 9 { \"name\": \"VisualGMQ\", \"age\": 20, \"info\": { \"school\": \"AnHuiLiGongDaXue\", \"credit\": \"2017303119\", \"male\": true } } 如果想要添加数组的话，只需要使用append()方法：\n1 2 3 root[\"friend\"].append(\"XianFen\"); root[\"friend\"].append(\"CaiChuanXun\"); root[\"friend\"].append(\"WuTao\"); 最后结果为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"name\" : \"VisualGMQ\" \"age\" : 20, \"info\" : { \"school\" : \"AnHuiLiGongDaXue\" \"credit\" : \"2017303119\", \"male\" : true, }, \"friend\" : [ \"XianFen\", \"CaiChuanXun\", \"WuTao\" ], } 如果想要删除，就使用removeMember()方法。\n接下来应该将Json数据写到文件中。这里有两种方法：\n使用FastWriter和StyledWriter将数据变为字符串，然后通过C++IO来写入文件（这个方法已经废弃，使用的话会给出警告，但是却很方便，所以也列了出来） 使用StreamWriterBuilder和StreamWriter来将数据变为字符串，然后通过IO写入文件。 也就是说，Jsoncpp本身是不能直接写入文件的，而必须先变为字符串，再通过C++原生IO写入文件。\n使用FastWriter和StyledWriter 这两个类的用法其实是一样的：\n1 2 Json::FastWriter wb; string str = wb.write(root); 首先声明对象，然后调用write方法传入要变为字符串的Json对象（这里传入root表示整个Json对象）就可以得到字符串了。然后通过C++IO就可以写到文件里面去了：\n1 2 3 ofstream ofile(\"ret1.json\"); ofile\u003c\u003cstr; ofile.close(); 结果如下：\n1 {\"age\":20,\"friend\":[\"XianFen\",\"CaiChuanXun\",\"WuTao\"],\"info\":{\"credit\":\"2017303119\",\"male\":true,\"school\":\"AnHuiLiGongDaXue\"},\"name\":\"VisualGMQ\"} FastWriter和StyledWriter的区别在于，FastWriter是不管格式的，会写的很快（像上面那样）。但是StyledWriter会通过缩进来控制格式。\n使用StreamWriterBuilder来写入 首先我们需要一个StreamWriterBuilder对象：\n1 Json::StreamWriterBuilder wb; 可以从名称看出，wb是一个“Builder”，也就是说他可以产生写入器。 StreamWriterBuilder的作用是在写文件之前给出一些配置。配置的话直接通过[配置名称]=配置就可以了，比如wb[\"useSpecialFloats\"] = true;这样。有如下配置：\n\"commentStyle\": \"None\" or \"All\"代表注释风格 \"indentation\": \"\"代表前缀，就是标有'$'的这里: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { $$\"name\" : \"VisualGMQ\" \"age\" : 20, \"info\" : $${ $$$$\"school\" : \"AnHuiLiGongDaXue\" $$$$\"credit\" : \"2017303119\", $$$$\"male\" : true, $$}, \"friend\" : $$[ $$$$\"XianFen\", $$$$\"CaiChuanXun\", $$$$\"WuTao\" $$], } 一般我们也不会去改动这个属性，当然这个属性默认为四个空格。 \"enableYAMLCompatibility\": false or true代表是否兼容Yaml，如果为true会在格式上有一些改变 \"dropNullPlaceholders\": false or true丢弃null值。 \"useSpecialFloats\": false or true如果为true，那么Nan就会记为\"NaN\"，float类型的INFINITY也会被记为\"Infinity\" “precision\":小数的精度，默认为17. 你可以用setDefaults()函数来将设置变为默认的。或者通过validate()来判断此StreamWriterBuilder的配置是否正确。\n配置好之后，你有两种选择来将Json数据变为字符串：\n直接变为字符串 通过调用Json::writeString方法来变为字符串： 1 string str = Json::writeString(wb, root); 产生写入器，然后通过写入器变成字符串: 1 2 3 4 5 Json::StreamWriterBuilder swb; Json::StreamWriter* sw = swb.newStreamWriter(); ofstream ofile(\"ret1.json\"); sw-\u003ewrite(root, \u0026ofile); ofile.close(); 这里通过swb的newStreamWriter()创建一个写入器sw，然后通过其（也是仅有的）write方法写入ofile流中。 写入器的第二个参数是ostream*，也就是说你可以写到文件流中，也可以直接写到输出流中。这里就比第一种方法要 更具有灵活性了。 Json文件的读取 Json文件的读取也有两个方法：使用CharReaderBuilder，CharReader或者Reader来读取。 需要说明的是，Json也不支持直接从文件中解析Json文件。你应该使用C++IO先将文件读到字符串中，然后再给Jsoncpp解析：\n1 2 3 4 5 6 7 ifstream ifile(\"test.json\"); ifile.seekg(0, ios::end); int len = ifile.tellg(); ifile.seekg(0, ios::beg); char buffer[1024] = {'\\0'}; ifile.read(buffer, len); //数据存储在buffer里 使用Reader来读取 和Writer一样，Reader也已经被抛弃了。但是用起来还是很顺手。用法其实和Writer差不多：\n1 2 3 Reader rd; Json::Value root; rd.parse(buffer, root, false); 首先声明Reader对象，然后调用parse函数，第一个参数是要解析的文本字符串，第二个参数是解析完成之后返回的Json::Value，第三个参数表示是否也解析注释。如果为false则会丢弃注释。\n然后你就可以使用Json::Value来获得元素了。\n使用CharReaderBuilder，CharReader读取 其实和写入一样，首先通过CharReaderBuilder来设置一些读取设置，然后通过newCharReader()函数构造一个CharReader，然后解析获得一个Json::Value：\n1 2 3 4 5 Json::CharReaderBuilder crb; Json::CharReader* cr = crb.newCharReader(); Json::Value root; JSONCPP_STRING err; cr-\u003eparse(\u0026buffer[0], \u0026buffer[len], \u0026root, \u0026err); //返回true解析完成，false解析失败 但是CharReader解析Json有一个很麻烦的事情，就是它的parse函数需要传入要解析文本的第一个字符和最后一个字符，来确定要解析哪一段。这样你就必须在读取json文件的时候顺便将文本长度读取出来（或者你直接用strlen(buffer)也可以）。 parse函数第一个参数是开始解析的文本，最后一个参数是结束的文本，第三个参数是要返回的Json::Value，最后一个参数是错误信息。\n至于CharReaderBuilder的设置，有如下值：\n\"collectComments\": false or true 是否解析注释，如果allowComments参数为false就无视这个设定 \"allowComments\": false or true 是否允许注释 \"strictRoot\": false or true 严格要求根元素为数组或者Json对象（严格遵循json格式） \"allowDroppedNullPlaceholders\": false or true 是否丢弃null值 \"allowNumericKeys\": false or true 是否允许解析数学类型的键 \"allowSingleQuotes\": false or true 是否连同键值对左右的\"符号一并保留。 \"stackLimit\": integer 超出integer大小的话会抛出异常 \"rejectDupKeys\": false or true如果为true，当json对象中有重复的键时parse函数会返回false \"allowSpecialFloats\": false or true是否允许Nan和Infinity 通过Json::Value来获得键值 我们得到了Json::Value，就需要通过Json::Value来获得信息。 先是如下的函数来帮我们判断这个Json::Value对象包含的值类型： isNull, isBool, isInt, isInt64, isUInt, isUint64, isIntegral, isDouble, isNumeric, isString, isArray, isObject。 然后你可以通过这些判断来调用一下函数获得对应的值： asInt, asInt64, asUInt, asUInt64, asLargestInt, asLargestUInt, asFloat, asDouble, asBool, asString, asCString。 或者通过isMember()来判断某个键在不在此Value中。 如果你事先已经知道了是什么类型的值，你也可以直接通过下标运算来获得。 或者你也可以通过get()函数来获得，第一个参数是要获得值的键名，第二个参数为Json::Value，指出如果键不存在的默认返回值。\n你也可以通过size()函数得到数组的大小或则会json对象的值个数。 通过empty()来判断数组和对象是否为空。 通过isValidIndex()来判断下标是否越界。\n你也可以通过toStyledString()来返回整个字符串。\n","description":"","tags":["cpp"],"title":"C++处理Json文件(Jsoncpp)","uri":"/posts/c++%E5%A4%84%E7%90%86json%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"使用的库 我们使用TinyXML2库来处理XML文件。TinyXML2库是一个完全面向C++的库。是一个易学，轻量级的库。\nTinyXML2的使用方法 使用准备 想要使用TinyXML2，你需要包含头文件tinyxml2.h，然后使用命名空间tinyxml2:\n1 2 #include \"tinyxml2.h\" using namespace tinyxml2; TinyXML2对XML文件的结构 读取和获得XML文件及元素 首先来看一下要读取的XML文本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u003c?xml version=\"1.0\"?\u003e \u003cstory\u003e \u003cstoryinfo\u003e \u003cauthor\u003eJohn Fleck\u003c/author\u003e \u003cdatewritten\u003eJune 2, 2002\u003c/datewritten\u003e \u003ckeyword\u003eexample keyword\u003c/keyword\u003e \u003c/storyinfo\u003e \u003cbody\u003e \u003cheadline id=\"id1\"\u003eThis is the headline\u003c/headline\u003e \u003cpara\u003eThis is the body text.\u003c/para\u003e \u003c!--this is a comment--\u003e \u003c/body\u003e \u003c/story\u003e 首先，TinyXML2通过XMLDocument来定义一个XML文件，我们可以这样打开一个XML文件：\n1 2 XMLDocument doc; doc.LoadFile(\"testXML.xml\"); 注意XMLDocument本身的构造函数是不允许直接打开XML文件的。\n然后可以使用RootElement()的方法来获得根元素（要注意声明不是根元素，根元素是声明下面的第一个元素）。或者使用FirstChildElement()来获得第一个子元素（因为现在在文档的开头，所以仍然是根元素）。获得的元素类型是XMLElement，可以有Value()方法来获得元素的内容（如果没有内容返回名称），Name()方法获得元素名称:\n1 2 3 4 5 cout\u003c\u003cdoc.RootElement()-\u003eValue()\u003c\u003cendl; cout\u003c\u003cdoc.FirstChildElement()-\u003eValue()\u003c\u003cendl; //story //story 当我们获得XML中的一个元素的时候，我们可以调用其方法来获得和其有关的元素，具体方法如下：\nNoChildren()判断是否有子节点。另外还有GetLineNum()来获得当前行号。需要注意的是，我们还有如下函数来获得信息:\nFirstChild() LastChild() NextSibling() PreviewsSibling() 这些函数和图中的函数就差一个Element单词。正如函数名所言，带有Element的函数都是会返回XMLElement的。但是不带Element的函数返回XMLNode，XMLNode是所有XML元素（包括XMLElement,XMLComment,XMLAttribute等）的父类。也就是说如果你使用doc.FirstChildElement()函数，指明了获得元素，那么会获得\u003cstory\u003e标签。但是如果你使用doc.FirstChild()，那么会返回声明（XMLDeclaration），因为声明才是第一个子节点。\n如果不存在某个元素，那么会返回空指针。\n有了以上函数，你就可以自由在XML中游走了。\n##写XML文件 写XML文件的操作也是封装在XMLNode类中，你可以对任意一个XMLNode的子类进行节点的插入操作。但是要想产生节点，只有通过XMLDocument的工厂函数来创造（不支持直接new）。\n也就是说XMLDocument不支持加入属性等，但是可以创建元素。一般我们会首先获得创建的元素，然后对元素的一些属性进行设置，然后再将元素链接到父元素中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 XMLDocument doc; XMLDeclaration* declaration = doc.NewDeclaration(\"version=3.2 encoding=UTF-8\"); doc.InsertFirstChild(declaration); XMLElement* root = doc.NewElement(\"root\"); root-\u003eSetAttribute(\"author\", \"VisualGMQ\"); root-\u003eSetAttribute(\"age\", 20); XMLElement* ele1 = doc.NewElement(\"data\"); ele1-\u003eSetText(\"2019.06.25\"); root-\u003eInsertFirstChild(ele1); XMLComment* comment = doc.NewComment(\"this is a comment\"); root-\u003eInsertEndChild(comment); doc.InsertEndChild(root); doc.SaveFile(\"ret.xml\"); return 0; /* \u003c?version=3.2 encoding=UTF-8?\u003e \u003croot author=\"VisualGMQ\" age=\"20\"\u003e \u003cdata\u003e2019.06.25\u003c/data\u003e \u003c!--this is a comment--\u003e \u003c/root\u003e */ 通过SaveFile()函数来保存文件。\n通过以上函数，你可以随意创建XML文件了。\n获得属性元素 TinyXML对元素的获得有一些解析方法，可以将属性解析成各种类型的数据：\nAttribute():直接返回String IntAttribute():返回整型 BoolAttribute():返回布尔类型 DoubleAttribute():返回double FloatAttribute():返回float Int64Attribute():64位整型 以方便用户获得不同的数据类型。\n错误处理 你也可以用下面的函数进行错误处理：\nError() ErrorID() ErrorIDToName() ErrorLinenum() ErrorName() ErrorStr() ClearError() PrintError() 上面的函数只能针对XMLDocument来使用。用于在XMLDocument加载xml文件时解析错误而调用的。\n","description":"","tags":["cpp"],"title":"C++处理XML文件(TinyXML2)","uri":"/posts/c++%E5%A4%84%E7%90%86xml%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"跨平台的库一直被视为减轻程序员工作负担的一大利器。那么这些程序是怎么样做到跨平台的呢。这里我分析了SDL2和Catch2的源码，发现了编写的方法。\n首先需要注意的是：以下说的方法都只在GUNC编译器下编译，其他编译器不知道能不能通过。\n识别当前的操作系统 首先需要知道如何识别当前的操作系统。GNUC编译器会在编译程序的时候定义平台相关的宏。你可以在SDL2和Catch2中看到如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 #if (defined(linux) || defined(__linux) || defined(__linux__)) #undef __LINUX__ #define __LINUX__ 1 #endif #if defined(ANDROID) || defined(__ANDROID__) #undef __ANDROID__ #define __ANDROID__ 1 #endif #if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__) #undef __FREEBSD__ #define __FREEBSD__ 1 #endif 如果你是Linux系统，那么GNUC会给你宏linux,__linux,__linux__三个宏中的一个。如果你是安卓系统，那么就会给ANDROID,__ANDROID__宏中的一个。 所以跨平台就是根据这些GNUC给出的宏来判断的。根据源码，我们可以知道GUNC会给出如下的宏：\nlinux系统:linux, __linux, __linux__ 苹果系统:__APPLE__ 苹果电脑:__MACOSX__ 苹果手机:__IPHONEOS__ 苹果电视:__TVOS__ 安卓系统:__ANDROID__ windows系统:WIN32, _WIN32, __CYGWIN__, __MINGW32__,__WINDOWS__ PSP系统:__PSP__ 需要注意的是，苹果系统GNUC只会提供__APPLE__宏。你在判断这个宏之后你还需要包含苹果的头文件AvailabilityMacros.h,TargetConditionals.h，然后继续通过__MACOSX__等宏来判断。 还有很多很多的平台识别宏。这里就不列举了。\n声明自己的宏用于方便识别当前系统 当你能够识别当前的操作系统时，你需要定义自己的宏来便于以后自己识别操作系统，和根据系统来进行不同的操作。比如SDL2就是这样做的。在判断是linux系统后，他会定义__LINUX__宏；判断为FreeBSD操作系统之后，会定义__FREEBSD__宏。\n通过系统宏来定义系统特定操作 SDL2在这一点上做的很好。它定义了平台宏之后，为每一个平台写了一个config文件(SDL_config_os2.h,SDL_config_android.h等)。然后将这些头文件按照平台包含到一个总的config文件中(SDL_config.h)，之后想要利用平台相关特性就可以只包含这个总的config文件了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #if defined(__WIN32__) #include \"SDL_config_windows.h\" #elif defined(__WINRT__) #include \"SDL_config_winrt.h\" #elif defined(__MACOSX__) #include \"SDL_config_macosx.h\" #elif defined(__IPHONEOS__) #include \"SDL_config_iphoneos.h\" #elif defined(__ANDROID__) #include \"SDL_config_android.h\" #elif defined(__PSP__) #include \"SDL_config_psp.h\" #elif defined(__OS2__) #include \"SDL_config_os2.h\" #else /* This is a minimal configuration just to get SDL running on new platforms. */ #include \"SDL_config_minimal.h\" #endif /* platform config */ #ifdef USING_GENERATED_CONFIG_H #error Wrong SDL_config.h, check your include path? #endif 在每个系统独立config文件中，通过宏来表示“这个系统能做到什么”：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //SDL_config_osx.h #define HAVE_STDINT_H 1 #define HAVE_LIMITS_H 1 #define HAVE_CTYPE_H 1 #define HAVE_MATH_H 1 #define HAVE_FLOAT_H 1 #define HAVE_SIGNAL_H 1 //SDL_config_windows.h #define HAVE_CTYPE_H 1 #define HAVE_FLOAT_H 1 #define HAVE_LIMITS_H 1 #define HAVE_MATH_H 1 #define HAVE_SIGNAL_H 1 #define HAVE_STDIO_H 1 #define HAVE_STRING_H 1 #define HAVE_ATOI 1 这里在Macosx中就没有ATOI函数，所以就没有定义HAVE_ATOI宏。而windows里面有了，就可以定义这个宏。 一般都会定义如下的宏：\n是否有某个头文件的，比如HAVE_MATH_H 是否有需要用到的函数，比如HAVE_MALLOC 为平台特定函数声明宏，比如HAVE_ATOI 然后你就可以通过这些宏来控制平台头文件和函数了。\n同一模块不同系统编写不同的文件 有了以上的准备，当我们编写平台之间差别较大的函数的时候（比如GUI界面需要用到不同系统的API），就可以为不同的平台编写不同的文件。比如SDL的文件组织如下： 这里为线程方面编写了不同系统的文件。为计时器方面编写了不同系统的文件。\n总结 跨平台库需要设计者知道各个系统的API，并且有很大的代码量。开发跨平台库实属不易。\n","description":"","tags":null,"title":"第三方库是如何做到跨平台的","uri":"/posts/%E5%90%84%E7%A7%8D%E5%BA%93%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84/"},{"categories":null,"content":"全局的static 我们都知道static变量的用法：函数里面代表在函数结束的时候不销毁变量，类里面代表这个变量或者方法属于整个类。那么对于全局的static变量来说这意味着什么呢？\n我们先看一看下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //header.hpp #ifndef __HEADER__ #define __HEADER__ int headervar = 10; #endif //classA.hpp #ifndef __CLASSA__ #define __CLASSA__ #include \"header.hpp\" class classA{ public: classA():data(headervar){}; private: int data; }; #endif //classB.hpp #ifndef __CLASSB__ #define __CLASSB__ #include \"header.hpp\" class classB{ public: classB():data(headervar){}; private: int data; }; #endif 这里我们首先有一个头文件header.hpp，这个头文件里面只有一个变量headervar。接下来classA.hpp和classB.hpp都要使用这个头文件里面的变量。然后我们在写一个main函数：\n1 2 3 4 5 6 7 8 9 10 #include \"classA.hpp\" #include \"classB.hpp\" #include \u003ciostream\u003e using namespace std; int main(){ classA a; classB b; return 0; } 这里看上去好像没有什么问题，但是如果你编译main函数的话会发生错误。她会说headervar变量在classA和classB里面重复了。 但是我们都知道，我们已经使用了#ifndef宏来保证头文件不被重复包含了。那么错误在哪里呢？其实就是在headervar不是static的。 当多个文件包含一个头文件的时候，这个头文件里面的全局变量需要是static的。这样才可以保证整个源代码里面只有一份变量。 所以全局static的作用是保证整个源代码里面只有这一个变量\nextern关键字 extern关键字的意思是“被这个关键字修饰的变量或者函数可以在其他文件中寻找定义”。 比如说，下面代码一定是不能通过的，编译器会说出现了重复的变量:\n1 2 3 4 5 6 //file1.hpp int i = 20; //file1.cpp #include \"file1.hpp\" int i = 30; 但是如果你在i的前面加上extern，那么就可以这样写：\n1 2 3 4 5 6 //file1.hpp extern int i; //file1.cpp #include \"file1.hpp\" int i = 20; 这里extern表示i的定义可以在其他文件中找到。所以我们可以在file1.cpp中给他一个定义。 使用extern关键字之后，后面必须是变量或者函数的声明，不能给出定义（所以这里的extern int i也不能赋值）。定义需要在其他的文件中给出。\n可能你会有疑问：我以前写的时候也是头文件里面声明，实现文件里面定义的函数啊，不用加上extern关键字的:\n1 2 3 4 5 6 7 //file1.hpp void print(string msg); //file1.cpp void print(string msg){ cout\u003c\u003cmsg\u003c\u003cendl; } 的确是这样。但是如果你加上了extern关键字，你就可以在任意的实现文件里实现：\n1 2 3 4 //file2.cpp void print(string msg){ cout\u003c\u003cmsg\u003c\u003cendl; } 而不是局限于同名的实现文件。这是static不能够做到的。虽然static的范围也是所有包含他的文件，但是它的定义必须在和声明文件配套的实现文件中实现。\n我们可以在各种库的源代码中看到这些写法，将函数的声明冠以extern关键字，然后在其他文件名称毫不相干的地方完善函数体。\nextern的第二种用法 你也可以通过extern \"C\"来说明下面的函数使用C语言的编译规则来编译。比如这样：\n1 2 3 4 extern \"C\"{ void print(); void Log(); } ","description":"","tags":["cpp"],"title":"全局变量static的意义，以及extern关键字","uri":"/posts/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8Fstatic%E7%9A%84%E6%84%8F%E4%B9%89%E4%BB%A5%E5%8F%8Aextern%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":null,"content":"cmake基础语法汇总\n指定最低cmake版本号： cmake_minimum_required指令，一般这样使用：\n1 cmake_minimum_required(VERSION 3.13) 编译cpp文件 编译cpp文件为可执行文件 通过使用add_executable()指令，第一个参数是要生成的文件名称，其后的第二个参数是带有main函数的cpp文件，其后是附加的其他需要的cpp文件（会自动连带编译hpp文件）：\n1 2 3 4 add_executable(exe main.cpp [header1.cpp, header2.cpp ...]) #和下面的指令是一样的： g++ main.cpp [header1.cpp header2.cpp ...] -o exe 也就是说，Cmake会自动通过cpp文件找到对应的hpp文件（不论hpp文件放在哪里）。\n你也可以通过EXECUTABLE_OUTPUT_PATH命令指定产生的文件的路径。\n编译cpp文件为动态库和静态库 通过使用add_library(\u003cname\u003e [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] [source1] [source2] [...])来产生一个动态或者静态链接库，或者一个插件。 第一个参数是生成的链接库名称，会是lib{name}.xxx，其中xxx是由第二个参数（STATIC,SHARED,MODULE）决定的，STATIC代表生成静态链接库（Mac上是.a），SHARED代表生成动态链接库（Mac上是.dylib），MODULE是生成一种不会被链接到其它目标中的插件（Mac上是.so） 然后后面的参数就是所有需要链接成库的cpp文件。 EXCLUDE_FROM_ALL后面的参数是不会被链接到链接库里面的文件。\n你也可以通过LIBRARY_OUTPUT_PATH指定产生的链接库的路径。\n链接到链接库 链接到第三方库 首先需要通过find_package指令找到这个库:\n1 find_package(SDL2 REQUIRED) 第一个参数是库的名称。 第二个参数表示如果没有找到库会发生什么，QUIET表示不产生错误继续执行，REQUIRED会停止执行。 如果找到了这个库，那么SDL2_FOUND这个变量会有值，那么你可以使用:if(SDL2_FOUND)...endif(SDL2_FOUND)选择语句来判断有没有找到库。而且会将库的头文件路径放在\u003cpackage\u003e_INCLUDE_DIRS变量中，将库的路径放在\u003cpackage\u003e_LIBRARIES变量中。 得到了库的include文件路径和lib文件路径，你需要接下来的两个指令：\ninclude_directories这个指令用于添加头文件搜索路径（也就是g++中添加-I命令），你需要通过添加这个指令来让你的cpp文件找到库的头文件 target_link_libraries这个指令用于指定链接库，cmake会自动链接你指定的链接库，你需要通过这个指令链接链接库，不过你可以不写库的全称，cmake会帮你补齐(main-\u003elibmain.a等) 1 2 3 4 5 add_executable(exe main.cpp) if(SDL2_FOUND) include_directories(${SDL2_INCLUDE_DIRS}) target_link_libraries(exe ${SDL2_LIBRARIES}) endif(SDL2_FOUND) 像上面这样，include_directories只有一个参数，但是target_link_libraries需要两个参数，第一个是要链接到的可执行文件。所以我们需要在使用这个指令之前使用add_executable指令指定生成的可执行文件。\n链接到自己的库 自己的库是没有办法被cmake识别的，所以我们必须手动添加头文件搜索路径（-I）和库搜索路径（-L），靠这两个指令： INCLUDE_DIRECTORIES和LINK_DIRECTORIES（你也可以使用target_link_libraries指令代替这个指令）。\nLINK_DIRECTORIES指定链接库的搜索路径 然后通过LINK_LIBRARIES来指定链接什么库，同样可以不指定全名。 LINK_LIBRARIES和target_link_libraries的区别在于，前者只是指定库，而没有指定什么文件要链接库，所以所有出现在工程中的可执行文件都会无条件链接库。但是target_link_libraries就会指定哪个可执行文件链接到库。\n先生成链接库后链接 在一些情况下，我们希望先生成链接库，然后再使用我们生成的链接库链接到我们的程序，也就是如下:\n1 2 3 add_library(liba STATIC ${SRC}) #some operators add_execute(exe) 这个时候只能使用target_link_library指令。因为如果你使用link_library，在exe生成之前不能确保链接库也生成，因为这个时候并没有建立起exe和链接库的联系。只有使用target_link_library的时候才能建立起联系，让exe生成之前生成链接库。\nFILE指令 FILE指令用于对文件和文件夹进行操作：\n1 FILE([WRITE|READ|APPEND|GLOB|RENAME|REMOVE|MAKE_DIRECTORY|DOWNLOAD|UPLOAD|GENERATE|...] param1 ...) 正如你看到的，FILE命令有很多的参数，让我们来看一看：\nWRITE 用于向文件写入文本，会覆盖原来的文本 READ 用于从文件读出文本放在变量中 APPEND 用于向文件中以附加的形式写入文本 MAKE_DIRECTORY 用于生成一些列的文件夹，包括不存在的父文件夹 RENAME 用于重命名文件或者文件夹 REMOVE 用于删除文件和文件夹 DOWNLOAD 用于从网上下载资源到本地，第二个参数是url，第三个参数是文件的名称 COPY 用于拷贝文件 UPLOAD 用于上传文件 find_xxx系列指令 find_xxx指令有五个：\nfind_file 用于寻找文件 find_path 用于寻找包含一个文件的文件夹 find_library 用于寻找库 find_program 用于寻找程序 find_package 用于寻找包 前几个指令的用法很相似。比如说find_file用来找到指定的文件：\n1 2 3 4 find_file(FOUND_FILE test.txt PATHS /usr/local/lib /usr/local/include\t) 找到的文件的路径会存放在FOUND_FILE变量中，第二个参数是找到的文件（只能有一个文件），第三个PATHS参数表示在哪个目录（和其子目录）中寻找。 如果没有找到会定义FOUND_FILE-NOTFOUND变量。\nfind_package的方法有点特殊，在链接到第三方库一章说过了。\n增加C++11链接选项 SET(CMAKE_C_COMPILER g++) add_compile_options(-std=c++11) 首先设置编译器为g++，然后通过add_compile_options来设定增加C++11的编译选项。\n向g++添加-D指令 ADD_DEFINITIONS指令即可，如ADD_DEFINITIONS(-DENABLE_DEBUG-DABC)\n获得文件夹下的所有cpp文件 通过aux_source_directory(filepath filevar)，其中filepath是要找的路径，所有找到的文件偷会存储在filevar变量中。\n设置变量 通过set和list命令来设置变量：\n1 2 3 4 5 6 7 8 9 set(SRC_LIST main.cpp) #在原有的变量上添加新值 set(SRC_LIST ${SRC_LIST} test.cpp) #或者 list(APPEND SRC_LIST test.cpp) #在原有变量上去掉已有值 list(REMOVE_ITEM SRC_LIST main.cpp) 安装文件 安装文件通过INSTALL指令，它可以安装\n可执行文件 库文件 普通文件 文件夹 安装可执行和库文件 安装可执行和库文件都是使用参数TARGETS:\n1 2 3 4 INSTALL(TARGETS runexe dylib slib RUNTIME DESTINATION bin LIBRARY DESTINATION dynamiclib ARCHIVE DESTINATION staticlib) 这里指定将可执行文件runexe安装到\u003cprefix\u003e/bin文件夹中，将动态链接库dylib安装到\u003cprefix\u003e/dynamiclib中，将静态链接库slib安装到\u003cprefix\u003e/staticlib中。其中\u003cprefix\u003e/是前缀，由CMAKE_INSTALL_PREFIX变量指定，默认为/usr/local。\n安装其他文件 使用FILES或者PROGRAMS参数：\n1 2 INSTALL(FILES file1.txt DESTINATION file) 这里的路径如果是相对路径是相对于当前路径的。\n安装文件夹 使用DIRECTORY参数:\n1 2 INSTALL(DIRECTORY dir DESTINATION build) ","description":"","tags":["cmake\u0026make"],"title":"CMake基础语法汇总","uri":"/posts/cmake%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":null,"content":"这个库比较牛逼，他可以将python里面的对象或者内置类型保存为文件以便下一次使用。 具体可以保存什么对象呢，官方文档是这么写的：\nNone, True, and False integers, floating point numbers, complex numbers strings, bytes, bytearrays tuples, lists, sets, and dictionaries containing only picklable objects functions defined at the top level of a module (using def, not lambda) built-in functions defined at the top level of a module classes that are defined at the top level of a module instances of such classes whose dict or the result of calling getstate() is picklable (see section Pickling Class Instances for details). 也就是None，True,False，所有的内置数据类型和list,tuple,dict，用户自己声明的类对象，内置函数声明都可以被保存。\npickle库的用法 这个库的用法非常简单，只有四个函数需要掌握：\npickle.dump(data,file,protocal=0) 首先是dump函数，用于将data写入到file当中，且使用protocal协议。其中protocol协议可为0代表人类可以看得懂的编码方式，1位二进制。 pickle.dumps(data,protocal=0) 这个函数不会将data写入文件，而是返回其编码 pickle.load(file) load函数可以从file中读入你保存的python对象并返回 pickle.loads(databyte) 同样，loads可以将databyte转换为python对象，是和dumps对应使用的。 其实以上四个函数可以划分为两个类别：将对象序列化的dump和dumps，以及将对象反序列化的load和loads。\n接下来看一下实例：\n1 2 3 4 5 6 7 \u003e\u003e\u003e import pickle \u003e\u003e\u003e dic={\"A\":100,\"B\":200,\"C\":300} \u003e\u003e\u003e dic {'A': 100, 'B': 200, 'C': 300} \u003e\u003e\u003e f = open('test.txt','wb+') \u003e\u003e\u003e pickle.dump(dic,f) \u003e\u003e\u003e f.close() 这个时候test.txt文件内容如下： 是一串乱码。\n然后我们再读区这个文件，获得我们保存的对象：\n1 2 3 4 \u003e\u003e\u003e f = open('test.txt','rb+') \u003e\u003e\u003e s = pickle.load(f) \u003e\u003e\u003e s {'A': 100, 'B': 200, 'C': 300} 这样我们的对象就又回来了。\n你也可以使用dumps和loads：\n1 2 3 4 5 6 7 8 \u003e\u003e\u003e dic {'A': 100, 'B': 200, 'C': 300} \u003e\u003e\u003e d = pickle.dumps(dic) \u003e\u003e\u003e d b'\\x80\\x03}q\\x00(X\\x01\\x00\\x00\\x00Aq\\x01KdX\\x01\\x00\\x00\\x00Bq\\x02K\\xc8X\\x01\\x00\\x00\\x00Cq\\x03M,\\x01u.' \u003e\u003e\u003e s = pickle.loads(d) \u003e\u003e\u003e s {'A': 100, 'B': 200, 'C': 300} 也就是不写入文件对对象进行序列化和反序列化。\n","description":"","tags":null,"title":"Python3-Pickle库","uri":"/posts/python3-pickle%E5%BA%93/"},{"categories":null,"content":"tarfile库 tarfile库用于控制tar命令压缩的压缩文件，这里来看一下有哪些值得学习的函数：\n首先是tarfile.open(path)，用于打开一个压缩文件： 1 2 3 4 \u003e\u003e\u003e import tarfile \u003e\u003e\u003e tar = tarfile.open('test.gz') \u003e\u003e\u003e tar \u003ctarfile.TarFile object at 0x102db5da0\u003e 你可以用is_tarfile(filename)来确定一个文件是不是tar类型： 1 2 \u003e\u003e\u003e tarfile.is_tarfile('test.gz') True 获得压缩文件里的信息 可以使用getnames(),getmembers(),list等函数获得信息，具体的效果看下面： 1 2 3 4 5 6 7 8 9 10 11 \u003e\u003e\u003e tar.getnames() ['./._数码管.png', '数码管.png', './._四角按键.png', '四角按键.png', './._六脚自锁开关.jpg', '六脚自锁开关.jpg'] \u003e\u003e\u003e tar.getmembers() [\u003cTarInfo './._数码管.png' at 0x102895f20\u003e, \u003cTarInfo '数码管.png' at 0x102e18048\u003e, \u003cTarInfo './._四角按键.png' at 0x102e18110\u003e, \u003cTarInfo '四角按键.png' at 0x102e181d8\u003e, \u003cTarInfo './._六脚自锁开关.jpg' at 0x102e182a0\u003e, \u003cTarInfo '六脚自锁开关.jpg' at 0x102e18368\u003e] \u003e\u003e\u003e tar.list() ?rw-r--r-- visualgmq/staff 531 2018-10-31 19:52:00 ./._数码管.png ?rw-r--r-- visualgmq/staff 180999 2018-10-31 19:52:00 数码管.png ?rw-r--r-- visualgmq/staff 423 2018-10-30 17:27:12 ./._四角按键.png ?rw-r--r-- visualgmq/staff 14592 2018-10-30 17:27:12 四角按键.png ?rw-r--r-- visualgmq/staff 266 2018-10-30 17:35:38 ./._六脚自锁开关.jpg ?rw-r--r-- visualgmq/staff 3436 2018-10-30 17:35:38 六脚自锁开关.jpg 这里显示我的压缩文件里面有三个图片，分别是“数码管.png”，\"六角自锁开关.jpg\"和\"四角按键.png\"。\n解压缩文件 可以通过tarfile.extract()和tarfile.extarctall()来实现解压缩。前者是解压缩制定文件，后者会全部解压缩。你也可以给出解压缩的目的地。 1 \u003e\u003e\u003e tar.extractall() 这样的话文件会全部解药到当前路径下。\n1 \u003e\u003e\u003e tar.extractall('图片') 这样会在当前路径下创建“图片”文件夹，然后解压到里面去。\n1 \u003e\u003e\u003e tar.extract('四角按键.png') 这里制定了解压哪一个文件\n1 \u003e\u003e\u003e tar.extract('四角按键.png','test') 这里制定了解压到哪一个文件夹中。\n你也可以通过遍历tar来获得tarinfo:\nfor tarinfo in tar: 或者使用next方法来返回当前位置的下一个元素的tarinfo:\n1 \u003e\u003e\u003e tarinfo = tar.next() 这里tarinfo是压缩包里面元素的信息，有下面的属性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 \u003e\u003e\u003e for tarinfo in tar: ... print(tarinfo.name) #name属性 ... ./._数码管.png 数码管.png ./._四角按键.png 四角按键.png ./._六脚自锁开关.jpg 六脚自锁开关.jpg \u003e\u003e\u003e for tarinfo in tar: ... print(tarinfo.size) #size属性 ... 531 180999 423 14592 266 3436 \u003e\u003e\u003e for tarinfo in tar: ... print(tarinfo.mtime) #最近一次的修改时间 ... 1540986720.5672143 1540986720.5672143 1540891632.1421418 1540891632.1421418 1540892138.9489677 1540892138.9489677 \u003e\u003e\u003efor tarinfo in tar: ... print(tarinfo.mode) #文件权限 ... \u003e\u003e\u003e for tarinfo in tar: ... print(tarinfo.gid,tarinfo.uid) #Group ID \u0026 User ID ... 20 501 20 501 20 501 20 501 20 501 20 501 \u003e\u003e\u003e for tarinfo in tar: ... print(tarinfo.uname,tarinfo.gname) #User name \u0026 Group name ... visualgmq staff visualgmq staff visualgmq staff visualgmq staff visualgmq staff visualgmq staff 还有一些方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u003e\u003e\u003e for tarinfo in tar: ... print(tarinfo.isfile(),tarinfo.isdir()) #是否是文件，是否是目录（其中isfile()可以被isreg()替换） ... True False True False True False True False True False True False \u003e\u003e\u003e for tarinfo in tar: ... print(tarinfo.issym(),tarinfo.islnk()) #是否是字符链接，是否是硬链接 ... False False False False False False False False False False False False \u003e\u003e\u003e for tarinfo in tar: ... print(tarinfo.ischr(),tarinfo.isblk()) #是否是字符设备，是否是块设备 ... False False False False False False False False False False False False 最后用完了tar需要关闭：\n1 tar.close() 你也可以创建自己的压缩包，在taropen的时候指定压缩方式即可： ```python \u003e\u003e\u003e tar = tarfile.open(\"test.gz\",'w:gz') #可写的gz压缩格式 ``` 除了'gz'表示gzip格式外，还有bz2（bzip2格式），xz(lzma格式)。 然后可以使用add方法来添加文件啦:\n1 2 3 4 5 6 \u003e\u003e\u003e tar.add('./test/数码管.png') \u003e\u003e\u003e tar.getnames() ['./test/数码管.png'] \u003e\u003e\u003e tar.add('./test/四角按键.png') \u003e\u003e\u003e tar.getnames() ['./test/数码管.png', './test/四角按键.png'] 你也可以使用addfile()来添加文件，不过这个函数的参数是tarinfo对象.\nzipfile库 zipfile库是用来对zip文件进行操作的库。 zipfile本身是没有open函数的，你必须声明zipfile对象才可以对zip文件进行操作：\n1 2 3 \u003e\u003e\u003e zf = zipfile.ZipFile('test.zip','r') \u003e\u003e\u003e zf \u003czipfile.ZipFile filename='test.zip' mode='r'\u003e 这里如果省略第二个参数默认为r（只读）\n接下来看看有哪些可以获得信息的方法： ```python \u003e\u003e\u003e zf.namelist() ['单片机/数码管.png', '单片机/六脚自锁开关.jpg', '单片机/四角按键.png'] \u003e\u003e\u003e zf.infolist() [, , ] \u003e\u003e\u003e zf.filename 'test.zip' ``` 抽取的方法和tarfile一样： ```python \u003e\u003e\u003e zf.extract('单片机/数码管.png') '/Users/visualgmq/Desktop/单片机/数码管.png' \u003e\u003e\u003e zf.extractall() ``` zip文件还有一个特别的地方是可以设置解压密码，没有这个密码的话是无法操作和解压里面的内容的： ```python \u003e\u003e\u003e zf.setpassword(bytes(\"this is a zip\",'ascii')) ``` 这里setpassword只能够给入bytes作为密码，我们这里使用bytes的构造函数将string编程bytes。语法是bytes(data,encode_type)，其中encode_type表示以什么方式转码，这里转换成ascii码。 那么我们在抽取的时候就需要指定pwd参数来给出密码：\nzf.extractall(pwd='this is a zip') 你还可以使用read函数来读取一个元素，返回其字节信息： ```python \u003e\u003e\u003e zf.read('单片机/六脚自锁开关.jpg') b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x01*\\x00\\x00\\x00\\x98\\x08\\x02\\x00\\x00\\x00\\xdc-3\\xb2\\x00\\x00\\x00\\x01sRGB\\x00\\xae\\xce\\x1c\\xe9\\x00\\x00\\x00\\x04gAMA\\x00\\x00\\xb1\\x8f\\x0b\\xfca\\x05\\x00\\x00\\x00\\tpHYs\\x00\\x00\\x0e\\...... ``` 或者使用write函数增加一个文件：\n1 \u003e\u003e\u003e zf.write('test.png') 使用完之后要关闭：\n1 zf.close() 和tarinfo一样，我们也有zipinfo。你可以通过两种方式来获得zipinfo： ```python \u003e\u003e\u003e zf.infolist() #返回所有元素的zipinfo [, , ] \u003e\u003e\u003e zf.getinfo('单片机/数码管.png') #返回单个元素的zipinfo ``` 那么我们来看看zipinfo有什么有用的属性； ```python \u003e\u003e\u003e info.filename #元素名称 '单片机/数码管.png' \u003e\u003e\u003e info.date_time #最后修改的时间 (2018, 10, 31, 19, 52, 0) \u003e\u003e\u003e info.compress_type #压缩的方式 0 \u003e\u003e\u003e info.comment #这个元素的注释 b'' \u003e\u003e\u003e info.create_system #是从那个系统创建的 3 \u003e\u003e\u003e info.create_version #创建时zip的版本 20 \u003e\u003e\u003e info.extract_version #抽取出来需要的最低zip版本 20 \u003e\u003e\u003e info.CRC #CRC编码 2392735222 \u003e\u003e\u003e info.compress_size #压缩之后的大小 180999 \u003e\u003e\u003e info.file_size #压缩之前（原文件）大小 180999 ``` 还有一个is_dir()方法： ```python \u003e\u003e\u003e info.is_dir() #是不是目录 False ``` *** *** 除了这两个库还有gzip,bz2,lzma三个库，但是有了这两个库基本上可以搞定所有问题了，就不再学习那三个库了。","description":"","tags":null,"title":"Python3操纵压缩文件","uri":"/posts/python3%E6%93%8D%E7%BA%B5%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"pymysql是专门为了操控mysql而产生的库，属于外部库，需要安装:\n1 pip3 install pymysql 假设我们现在有这样一个数据库： 这里我们就用test数据库为例，上面我们分别对test数据库使用了两条命令：\nSHOW TABLES; SELECT * FROM student; 接下来我们看看如何使用mysqldb来实现相同的事情。 mysqldb的使用方法\n连接到自己的数据库 连接到数据库的函数是connect，他会返回一个pymysql.connections.Connection对象： 1 2 3 import mysqldb db = pymysql.connnect(host=\"127.0.0.1\",user=\"root\",password=\"这里是我的密码，不给你看\",database=\"test\") connect函数需要的参数想必都很明确了。其中database表示你要连接到的数据库，这里就是test了。 这是一个通用连接函数，如果你只想连接到本机的数据库，可以简化成这样：\n1 db = pymysql.connect(\"localhost\",\"root\",\"密码\",\"test\") 或者你也可以先连到mysql，然后再选择数据库。使用成员函数select_db()函数：\n1 db.select_db(\"test\") 获得游标 只有获得游标，我们才能操控数据库： 1 cursor = db.cursor() 通过游标执行各种sql命令 接下来就可以通过游标执行各种sql命令了。执行命令的函数为execute()： 1 cursor.execute(\"SHOW TABLES\") 注意在这里执行命令的时候不需要在字符串里面加;了。\n获得命令的返回值 你可以通过成员函数fetchall(),fetchone(),fetchmany(num)来获得返回的结果。比如我们想要获得student里面的所有字段： 1 2 cursor.execute(\"SELECT * FROM student\") cursor.fetchall() 就得到： 也即是说返回的字段会以元祖的形式返回。 你也可以使用fetchone()来获得第一条字段，或者使用fetchmany(num)获得前num条字段。 值得注意的是：如果没有一次性拿出所有的字段，那么慢剩下的字段还会保留在cursor中。比如现在有4个字段，我使用了fetchmany(2)，那么后两条字段会留在cursor中，你可以再次使用fetch系列 函数来获取 改变数据库内容 有时候需要改变数据库的内容，首先想到的是使用cursor.execute函数： 1 cursor.execute(\"INSERT INTO student(name,credit,info) VALUES('王骏龙','2017303138',NULL)\") 但是数据库并不一定会立刻将数据插入进去，这个时候你需要使用db.commit()函数提交修改：\n1 db.commit() 这样就可以了。\n关闭数据库连接 当你不需要使用到数据库的时候，可以关闭连接： 1 db.close() ","description":"","tags":null,"title":"pymysql库的使用","uri":"/posts/pymysql%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"OpenGL中有很多的库，我们今天来说一下这些库的区别。\ngl是OpenGL在很早的版本的时候维护的库，里面有很多的opengl函数给用户使用。是opengl最早最原始的库，于窗口无关。 glu是在gl上封装的库，通过这个库可以减轻你的opengl编程，不用自己计算变换或者更加容易绘制集合体。但是仍然是窗口无关的。 glut和gl，glu完全没有任何关系。其内部包含了opengl函数，并且提供了创建窗体的函数。也就是说glut还自带窗体功能OpenGL glfw和glut一样，在拥有opengl函数的基础上带有窗体功能。 glew包含了opengl函数，以及额外的拓展函数。也是于窗口无关的，也就是说他也得有一个GUI引擎来支持。\n以上库和其他额外库的各个关系如下： 所以OpenGL其实只需要gl库和任意一个支持OpenGL的GUI库就可以制作了。但是还是有很多人选择gl+glut, glut, glew+GUI, glfw的组合\n","description":"","tags":["OpenGL"],"title":"OpenGL-glu,glut,glew等库的区别","uri":"/posts/opengl-glu-glut-glew%E7%AD%89%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":null,"content":"我们首先需要明白，OpenGL这个玩意只管一件事，就是画图，除了画图之外这玩意什么都不管。包括创建窗口，事件响应，甚至包括图像的旋转和平移什么的都不会去管，他只会画图。 那么问题就来了，我们Hello world里面的窗口是哪里来的呢？\n先来看看Hello world里面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u003ciostream\u003e #include \u003cglad/glad.h\u003e #include \u003cGLFW/glfw3.h\u003e using namespace std; int main(int argc, const char * argv[]) { glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); GLFWwindow* window = glfwCreateWindow(400, 400, \"Hello World\", nullptr, nullptr); if(window == nullptr){ glfwTerminate(); cout\u003c\u003c\"window create failed\"\u003c\u003cendl; } glfwMakeContextCurrent(window); if(!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)){ cout\u003c\u003c\"glad load failed\"\u003c\u003cendl; } glViewport(0, 0, 400, 400); while(!glfwWindowShouldClose(window)){ glClearColor(0.2f, 0.3f, 0.3f, 0.1f); glClear(GL_COLOR_BUFFER_BIT); glfwSwapBuffers(window); glfwPollEvents(); } glfwTerminate(); return 0; } 这些代码只是创建了一个空白的窗口（我没有把自适应窗体大小的代码贴上去，那个在这里不重要）。其实这里面的OpenGL函数只有如下几个：\nglViewport() glClearColor() glClear() 没错只有三个，那么你看到的这么多代码是做什么的呢？这些其他的代码，除了\n1 2 3 if(!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)){ cout\u003c\u003c\"glad load failed\"\u003c\u003cendl; } 这几行是glad库用于找到OpenGL函数的函数入口之外，其他的所有代码都是glfw库用来配置OpenGL环境和产生一个供OpenGL绘图的窗口的。所以我说OpenGL这个玩意只会画图，窗口什么的是glfw来做的。也就是说glfw其实不是OpenGL函数库里面的东西。他其实是一个GUI库。\n但是一到绘图部分，就完全是OpenGL的函数了，包括清除屏幕的glClearColor(),glClear()函数都是OpenGL函数。\n所以这一部分还是很迷惑人的。如果你使用SDL为OpenGL产生一个窗口的话，一样需要先配置OpenGL（指定版本号），然后创建一个兼容OpenGL的窗口，然后所有的绘图都交给OpenGL来处理。\n所以说，OpenGL这个玩意其实不能单独使用，它必须有一个GUI库或者游戏引擎的支持才可以发挥它的实力（不然哪有地方给他绘图呢？）\n注意：在使用gladLoadGLLoader之前你必须通过glfwMakeContextCurrent函数指定窗口。不然galdLoadGLLoader函数会返回错误。\n","description":"","tags":["OpenGL"],"title":"OpenGL-关于创建窗口的解释","uri":"/posts/opengl-%E5%85%B3%E4%BA%8E%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3%E7%9A%84%E8%A7%A3%E9%87%8A/"},{"categories":null,"content":"我在看教程的时候很迷，不知道VBO和VAO有什么用，为什么搞得那么复杂，我这里就来详细的说一下他们两个的工作。\nVBO 也就是vertices buffer object，顶点缓冲对象。这个东西的作用，就是将一系列的点放到显存GPU中去。但是注意，他只是把点放到显存里面去，放进去的点OpenGL并不知道以何种方式绘制出来。 通过glGenBuffer()函数来生成一个VBO。然后需要制定VBO的种类，所以你得将其和一个种类进行绑定，使用glBindBuffer()函数可以做到。然后OpenGL知道了这个VBO的类型之后，你就可以通过glBufferData()函数将点（或者后面学到的其他数据）放到GPU里面去了。\n那么到这里，我们都只是将数据（这里是顶点数据）放到GPU中，我们并没有说明这些点怎么绘制对吧。这就是VBO的用途：只是将点放到GPU中，他就是将数据放到GPU中的一个桥梁。\nVAO VAO是vertice attribute object，也就是顶点属性对象。这个东西的作用，就是告诉OpenGL我应该以什么样的方式绘制出VBO放到GPU里面的点。所以说绘制这一部分是在VAO指定的。 通过glGenVertexArrays()函数产生一个VAO，然后你也得绑定（为什么需要绑定后面会说到），使用glBindVertexArray()来绑定。然后你就得告诉OpenGL我得怎么绘制那些在显存里面的数据，通过glVertexAttribPointer()函数来实现。最后由于着色器的问题你得使用glEnableVertexAttribArray()函数来指定点的传输变量（在着色器里面的out变量）。\n为什么要绑定 这里我要先说一下，在源代码的注释中，也就是循环里面的glBindVertexArray(VAO);这句话后面说\nseeing as we only have a single VAO there's no need to bind it every time, but we'll do so to keep things a bit more organized\n也就是说这里的VAO只有一个，我们其实不需要再循环里面重复绑定。那么我们就先忽略掉循环里面的glBindVertexArray(VAO);语句来分析。\n作者在开头就告诉我们，OpenGL是一个大的状态机，我们只要按照这个思路去想就可以了。\n为什么要绑定VBO？因为OpenGL里面就需要一个VBO来将数据放入GPU中，你绑定了VBO只是在内部产生了类似这样的语句：\n1 innerVBO = VBO; 也就是OpenGL状态机里面将你的VBO视为他要运作的VBO。\n那么绑定VAO一个道理，OpenGL里面每次 glDrawElements();的时候都会以这个VAO指定的绘制方式来绘制点。所以如果后面我们有其他的绘制方式的话你就必须在循环里动态绑定了。\nEBO EBO的道理和VBO一样，只不过我们传入很多的点，其中有一些点是重复的，让OpenGL注意到不去重复绘制，其实他就是另一个类型的VBO:GL_ELEMENT_ARRAY_BUFFER。 但是这里有一点需要注意：EBO的绑定要在VAO绑定之后。不知道为什么如果反过来的话图像会不显示。\n","description":"","tags":["OpenGL"],"title":"OpenGL-关于VAO,VBO的解释","uri":"/posts/opengl-%E5%85%B3%E4%BA%8Evao-vbo%E7%9A%84%E8%A7%A3%E9%87%8A/"},{"categories":null,"content":"鼠标和光标操作 SDL2里面专门有SDL_mouse.h头文件给出了鼠标和光标的操作。\n关于光标的操作 SDL2里面提供了很多关于光标的操作，包括创建光标，显示光标等。\n创建光标\n1 2 3 SDL_Cursor* SDL_CreateColorCursor(SDL_Surface* surface, int hot_x, int hot_y) 这个函数通过SDL_Surface指定一个图片，hot_x,hot_y来指定光标的操纵点来创建一个光标。\n1 2 3 4 5 6 SDL_Cursor* SDL_CreateCursor(const Uint8* data, const Uint8* mask, int w, int h, int hot_x, int hot_y) 这个函数创建一个黑白的光标，通过data,mask数组给出光标的像素信息，w,h给出光标大小,hot_x,hot_y给出光标操纵点来创建光标，这里有一个例子\n1 SDL_Cursor* SDL_CreateSystemCursor(SDL_SystemCursor id) 这个函数创建一个系统自带的光标，其中id有如下取值: 设置光标 创建了光标当然要使用了\n1 void SDL_SetCursor(SDL_Cursor* cursor) 释放光标 创建了光标当然要释放了\n1 void SDL_FreeCursor(SDL_Cursor* cursor) 获得当前光标\n1 SDL_Cursor* SDL_GetCursor(void) 获得SDL2默认光标\n1 SDL_Cursor* SDL_GetDefaultCursor(void) 显示光标\n1 int SDL_ShowCursor(int toggle) 给入SDL_ENABLE显示光标，SDL_DISABLE隐藏光标，SDL_QUERY 返回当前光标显示状态。\n关于鼠标的操作\n鼠标事件 鼠标事件有如下几个：\nSDL_MOUSEMOTION 鼠标移动 SDL_MOUSEBUTTONDOWN 鼠标按下 SDL_MOUSEBUTTONUP 鼠标按下 SDL_MOUSEWHEEL 鼠标滚轮 鼠标的事件处理中，event.button会存储所有的信息（滚轮事件中成员变量意义可能不一样，请看wiki），包括：\nbutton:按下的按键，可以是 SDL_BUTTON_RIGHT SDL_BUTTON_LEFT SDL_BUTTON_MIDDLE x:鼠标的x位置 y:鼠标的y坐标 xrel, yrel:鼠标的移动距离（仅MOUSEMOTION事件） clicks:鼠标点击次数。1是单击，2是双击（仅MOUSEDOWN,MOUSEUP事件） direction：鼠标滚轮的方向（仅MOUSEWHEEL事件） 是否全局追踪鼠标\n1 int SDL_CaptureMouse(SDL_bool enabled) 这个函数可以让你定义是否全局追踪鼠标。如果你给入了SDL_TRUE，表示全局追踪鼠标。这样即使鼠标事件发生在程序窗体外面也可以监测到。 如果为SDL_FALSE，那么就只能检测到这个程序的鼠标事件。\n获得鼠标状态（按键，位置等）\n1 2 Uint32 SDL_GetMouseState(int* x, int* y) 这个函数获得鼠标的局部坐标位置\n1 2 Uint32 SDL_GetGlobalMouseState(int* x, int* y) 这个函数获得全局鼠标位置（相对于整个屏幕的）\n1 2 Uint32 SDL_GetRelativeMouseState(int* x, int* y) 这个函数用来获得上次调用这个函数到这次调用函数鼠标的x,y坐标的偏移量。\n如果想要使用这个函数，你需要通过这个函数来指定是否开启Relative模式：\n1 int SDL_SetRelativeMouseMode(SDL_bool enabled) 传入SDL_TRUE表示开启 或者通过这个函数得到Relative模式的状态:\n1 SDL_bool SDL_GetRelativeMouseMode(void) 这三个函数的返回值都是鼠标的按键状态。你可以使用 SDL_BUTTON(X) 宏来获得状态： SDL_BUTTON(X返回：\n1：左键按下 2：中键按下 3: 右键按下 鼠标的坐标转换\n1 2 int SDL_WarpMouseGlobal(int x, int y) 从局部坐标到全局坐标\n1 2 3 void SDL_WarpMouseInWindow(SDL_Window* window, int x, int y) 从全局坐标到局部坐标\n","description":"","tags":["SDL2"],"title":"SDL2-鼠标操作和光标生成","uri":"/posts/sdl2-%E9%BC%A0%E6%A0%87%E6%93%8D%E4%BD%9C%E5%92%8C%E5%85%89%E6%A0%87%E7%94%9F%E6%88%90/"},{"categories":null,"content":"窗体是通过事件驱动的。掌握了事件就可以掌握窗体等的行动。SDL2的事件结构体为SDL_Event.\nSDL2的事件处理过程是这样的:\n首先定义SDL_Event结构体，所有关于事件的信息都存储在这个结构体里面 在循环中使用PollEvent或者PeekEvent()函数来获得事件 判断结构体的type成员，看他是什么事件，并作出相应判断 大体的代码如下: 1 2 3 4 5 6 7 8 SDL_Event event while(true){ //game loop while(Poll_Event(\u0026event)){ //event loop if(event.type==/*event type*/) //TODO } //TODO game processing } 事件结构体SDL_Event 事件结构体里面首先要掌握的是type成员。这个成员会给出接收到的事件的类型。所有的事件类型看这里 其次他有很多的其他成员，具体的成员有什么用处，是根据事件的不同而不同的。比如按下鼠标的话就需要用到button属性，按下按键的话就需要key属性。每个属性又是结构体，含有关于那个事件的信息。 除了type之外，每一个成员都有如下的属性：\ntype 标志着这个成员所对应的事件 timestamp 事件的时间戳 如果不是系统事件的话还会有 windowID 发生事件的window的ID 事件获取函数 事件获取函数有两个SDL_PollEvent(),SDL_WaitEvent()。 SDL_PollEvent()函数最常用，他会在有事件的时候给事件结构体填充事件信息。而SDL_WaitEvent()会一直等待事件到来，到来之后会填充结构体。所以一般不会用到SDL_WaitEvent(). 事件获取函数的用法都是传入事件结构体就可以了，比如下面这样：\n1 2 3 4 SDL_Event event; while(PollEvent(\u0026event)){ //TODO about event } 判断事件类型 获得事件之后，需要通过事件结构体的type属性来判断是什么事件，比如用户按下了退出按钮（窗口左上角的❌）会触发退出事件，可以这样写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 bool isquit=false; int main(int argc,char** argv){ //Init SDL and Create Window and Renderer SDL_Event event; while(!isquit){ while(PollEvent(\u0026event)){ if(event.type==SDL_QUIT) isquit=true; } } SDL_Quit(); } 接下来列举一些典型的事件\n窗体事件 有关于窗体的事件，比如窗体的缩放，是否有焦点什么的都是这个事件:\nSDL_WINDOWEVENT\n你监测到这个事件之后，可以通过SDL_Event的window成员获得更近一步的信息，比如:\ntype，这个固定的为SDL_WINDOWEVENT，因为你监测到的是这个啊。 windowID，哪个window触发的 event，SDL_WindowEventID类型，你需要通过这个成员知道到底窗体的什么地方发生事件了，比如是窗体大小改变了还是失去焦点了。 data1,data2附加的信息。 其中你需要通过event来更进一步知道发生了什么，比如这样: 1 2 3 4 5 while(SDL_PollEvent(\u0026event)){ if(event.type==SDL_WINDOWEVENT) if(event.window.event==SDL_WINDOWEVENT_SIZE_CHANGED) SDL_Log(\"new width:%d,new height:%d\",event.window.data1,event.window.data2); } 不是所有的event.window.event都需要用到data1,data2的。比如窗体的关闭事件SDL_WINDOWEVENT_CLOSE就不需要。\n关于窗体的事件，wiki上给出了所有的event.window.event取值，并且给出了一个综合实例说明了所有的窗体事件的用法。\n程序生命周期事件 这些事件说明了程序的生命周期，并且这些事件不和事件结构体里面的成员相对应：\nSDL_APP_TERMINATING SDL_APP_LOWMEMORY 内存过低的时候 SDL_APP_WILLENTERBACKGROUND 将要进入背景的时候（失去焦点） SDL_APP_DIDENTERBACKGROUND 已经进入背景的时候 SDL_APP_WILLENTERFOREGROUND 将要到前景的时候（获得焦点） SDL_APP_DIDENTERFOREGROUND 已经到前景的时候 SDL_QUIT 程序退出 比如你可以这么用： 1 2 if(event.type==SDL_APP_WILLENTERBACKGROUND) SDL_Log(\"Will Enter Background!); 键盘事件 键盘事件有两个:\nSDL_KEYDOWN SDL_KEYUP 如果你获得键盘事件，可以通过事件结构体的key成员来获得详细信息。key结构体如下:\ntype timestamp windowID state 取值SDL_PRESSED，SDL_RELEASED repeat 如果一个按键被重复按下，不为0.否则为0. keysym 按下或者弹起的键的编号，这是一个结构体。keysym结构体如下； scancode,SDL_Scancode 结构体，定义了按键码 sym，SDL_Keycode结构体，定义了按键码 mod，有没有其他的，比如Shift,Ctrl键和这个键一起按下/弹起的。SDL_Keymod结构体 你可以随便用scancode或者sym来确定按下了哪个键，比如这样：\n1 2 3 if(event.type==SDL_KEYDOWN) if(event.key.scancode==SDL_SCANCODE_A) //TODO when 'A' pressed SDL2给出了专门操作按键的头文件，请看“按键操作”笔记\n鼠标事件 鼠标事件有四个：\nSDL_MOUSEMOTION 鼠标移动 SDL_MOUSEBUTTONDOWN 鼠标按下按钮 SDL_MOUSEBUTTONUP 鼠标按钮弹起 SDL_MOUSEWHEEL 鼠标滚轮 这里每一个事件都对应不同的事件结构体成员，详细的可以点进去看看。 因为SDL2有专门针对鼠标的操控，所以我们在这里就不详细讲解了。详细请看“鼠标操作”笔记\n文本输入 文本输入的事件有两个：\nSDL_TEXTEDITING SDL_TEXTINPUT 其中SDL_TEXTEDITING对应事件结构体中的edit属性。这个属性有如下三个属性：\ntext用户输入的文本 start当前光标离开始输入处的距离 length当前光标到输入处的字符长度 SDL_TEXTINPUT事件对应text属性，这个属性只有一个重要的成员变量text，为用户输入的文本。\n需要注意的是，文本输入事件默认是不接收的。用户必须调用SDL_StartTextInput()函数来开启接收这个事件。SDL_StopTextInput()来关闭对这个事件的接收\n其他的事件还有游戏杆🕹️事件和游戏手柄🎮事件什么的，那些都不太重要。如果想要了解全部事件看这里\n","description":"","tags":["SDL2"],"title":"SDL2-事件","uri":"/posts/sdl2-%E4%BA%8B%E4%BB%B6/"},{"categories":null,"content":"SDL_Rect和SDL_Point都是SDL中用于表示几何图像的基本元素。让我们来深入了解一下这两个结构体吧。\nSDL_Rect\nRect的内容 SDL_Rect用于表示矩形，其结构很简单，只有四个属性：\nint x int y int w int h 这四个属性表示了左上角点的坐标和矩形的大小。\nRect相关的函数 关于Rect的函数很多，主要用于碰撞检测的有：\nSDL_HasIntersection用于判断两个矩形是否相交 SDL_IntersectRect这个函数不仅会判断是否相交，其第三个参数还可以获得相交之后的矩形 SDL_IntersectRectAndLine这个函数判断矩形和线段是否相交，由于SDL中没有线段的结构体，所以都是将端点坐标作为参数传入 SDL_PointInRect这个函数判断点是否在矩形内 还有一些计算几何的函数：\nSDL_EnclosePoints找到能够包含一系列点的最小矩形 SDL_RectEmpty判断矩形是否有面积 SDL_RectEquals判断两个矩形是否一样（判断四个属性是否相等） SDL_UnionRect获得两个矩形组合之后的大矩形 SDL_Point SDL_Point用于表示点。\nPoint的内容 很简单，两个属性：\nint x int y Point的函数\nSDL_EnclosePoints ","description":"","tags":["SDL2"],"title":"SDL2-Rect和Point","uri":"/posts/sdl2-rect%E5%92%8Cpoint/"},{"categories":null,"content":"SDL不仅是用来写游戏的，其实他的官方网站给他的定义是游戏和GUI界面，也就是说它其实就是一个实现图形用户界面的库。那么肯定可以有多窗口啦。 其实多窗口实现的方式很简单：你只要定义多个窗口，然后每个窗口再给一个Renderer就可以了。然后在循环的时候再调用各自的Renderer函数就可以了。\n这里有一个例子给你看一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u003cSDL2/SDL.h\u003e #include \u003cthread\u003e #include \u003ciostream\u003e using namespace std; void runWindow(int argc,char** argv){ SDL_Window* win = SDL_CreateWindow(\"MultiWindow\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 700, 700, SDL_WINDOW_SHOWN); SDL_Renderer* render = SDL_CreateRenderer(win, -1, 0); SDL_Event event; bool isQuit = false; SDL_SetRenderDrawColor(render ,255,255,255,255); while(!isQuit){ SDL_RenderClear(render); while(SDL_PollEvent(\u0026event)){ if(event.type == SDL_QUIT) isQuit = true; } SDL_RenderPresent(render); } } int main(int argc, char** args){ SDL_Init(SDL_INIT_EVERYTHING); SDL_Window* win1 = SDL_CreateWindow(\"MultiWindow1\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 700, 700, SDL_WINDOW_SHOWN); SDL_Window* win2 = SDL_CreateWindow(\"MultiWindow2\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 700, 700, SDL_WINDOW_SHOWN); SDL_Renderer* render1 = SDL_CreateRenderer(win1, -1, 0); SDL_Renderer* render2 = SDL_CreateRenderer(win2, -1, 0); SDL_Event event; bool isQuit = false; SDL_SetRenderDrawColor(render2 ,255,255,255,255); SDL_SetRenderDrawColor(render1 ,0,255,0,255); while(!isQuit){ SDL_RenderClear(render1); SDL_RenderClear(render2); while(SDL_PollEvent(\u0026event)){ if(event.window.event == SDL_WINDOWEVENT_CLOSE) isQuit = true; } SDL_RenderPresent(render1); SDL_RenderPresent(render2); SDL_Delay(30); } SDL_Quit(); return 0; } 最后的结果是这样： 需要注意的是这里的事件处理，我们使用的是event.window。\n","description":"","tags":["SDL2"],"title":"SDL2-多窗口","uri":"/posts/sdl2-%E5%A4%9A%E7%AA%97%E5%8F%A3/"},{"categories":null,"content":"时间控制函数在SDL_timer.h中\n延时\n1 void SDL_Delay(Uint32 ms) 延时ms个毫秒。这个函数广泛用在游戏编程中用于延时\n时钟控制 添加时钟\n1 2 3 SDL_TimerID SDL_AddTimer(Uint32 interval, SDL_TimerCallback callback, void* param) interval：每次触发回调函数的时间间隔 callback：回调函数，必须以Uint32 my_callbackfunc(Uint32 interval, void *param)的形式编写并且返回值为interval。 param：用户自定义数据。 这个函数返回添加的时钟ID\n移除时钟\n1 SDL_bool SDL_RemoveTimer(SDL_TimerID id) 和Windows编程一样，时钟不提供暂停机制。如果想要暂停必须通过删除来达到目标。\n精确时间\n1 Uint32 SDL_GetTicks(void) 这个函数获得SDL2库初始化以来的毫秒数。这个函数用于在游戏编程里面精确计算经过的时间长度。\n用于比较时间的宏\n1 SDL_TICKS_PASSED(A, B) 如果时间A已经经过时间B了，那么返回true。否则返回false\n","description":"","tags":["SDL2"],"title":"SDL2-时间控制","uri":"/posts/sdl2-%E6%97%B6%E9%97%B4%E6%8E%A7%E5%88%B6/"},{"categories":null,"content":"SDL2提供了平台系统检测和CPU信息检测\n平台检测 平台检测只有一个函数，包含在SDL_platform.h文件中:\n1 const char* SDL_GetPlatform(void) 返回值为C字符串，取值如下：\nWindows Mac OS X Linux iOS Android CPU信息检测 有关CPU信息检测详见这里\n","description":"","tags":["SDL2"],"title":"SDL2-平台检测和CPU信息","uri":"/posts/sdl2-%E5%B9%B3%E5%8F%B0%E6%A3%80%E6%B5%8B%E5%92%8Ccpu%E4%BF%A1%E6%81%AF/"},{"categories":null,"content":"获取电量的函数只有一个：\n1 2 SDL_PowerState SDL_GetPowerInfo(int* secs, int* pct) SDL_PowerState是一个枚举常量，取值如下：\nSDL_POWERSTATE_UNKNOWN，无法得知信息 SDL_POWERSTATE_ON_BATTERY，靠电池运作，没插电 SDL_POWERSTATE_NO_BATTERY，插电，没有电池 SDL_POWERSTATE_CHARGING，充电中 SDL_POWERSTATE_CHARGED，插电，且电池充满了。 其中参数secs表示电量还可以运作多长时间，pct表示还有百分之多少的电量。函数通过这两个参数返回信息。\n","description":"","tags":["SDL2"],"title":"SDL2-电量信息获取","uri":"/posts/sdl2-%E7%94%B5%E9%87%8F%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/"},{"categories":null,"content":"除了事件里面可以处理按键，SDL2还专门提供了SDL_keyboard.h, SDL_keycode.h, SDL_scancode.h三个文件来对按键进行操作。\n三个枚举类型 这三个枚举类型在事件处理里面已经见过了:\nSDL_Keycode：按键码 SDL_Keymod：附加按键（Shift,Alt,Ctrl之类的） SDL_Scancode：按键码 一个结构体 这个结构体也是记录按键键码的： SDL_Keysym 其实这个结构体里面只是封装了SDL_Keycode,SDL_Keymod,SDL_Scancode三个枚举类型。\nScancode,Keycode和按键名称之间的转化 其他两个到Scancode\n1 2 SDL_Scancode SDL_GetScancodeFromKey(SDL_Keycode key) SDL_Scancode SDL_GetScancodeFromName(const char* name) 其他两个到Keycode\n1 2 SDL_Keycode SDL_GetKeyFromName(const char* name) SDL_Keycode SDL_GetKeyFromScancode(SDL_Scancode scancode) 其他两个到按键名称\n1 2 const char* SDL_GetKeyName(SDL_Keycode key) const char* SDL_GetScancodeName(SDL_Scancode scancode) 也就是说存在下面的关系:\ngraph TD A(Scancode) --\u003e|SDL_GetKeyFromScancode| B(Keycode) B --\u003e|SDL_GetScancodeFromKey| A B --\u003e|SDL_GetKeyName| C(Key Name) A --\u003e |SDL_GetScancodeName| C C --\u003e |SDL_GetScancodeFromName| A C --\u003e |SDL_GetKeyFromName| B 获得/设置Keymod\n1 2 SDL_Keymod SDL_GetModState(void) void SDL_SetModState(SDL_Keymod modstate) 获取键盘状态 获得焦点窗口\n1 SDL_Window* SDL_GetKeyboardFocus(void) 获得键盘按键\n1 const Uint8* SDL_GetKeyboardState(int* numkeys) 这个函数返回一个Uint8的数组。这个数组里面装载着对应Scancode的按键。如果为1代表按下了，比如检测w是否按下：\n1 2 3 Uint8* keyarr = SDL_GetKeyboardState(nullptr); if(keyarr[SDL_SCANCODE_W]==1) SDL_Log(\"w is pressed!\"); 传入的参数numkeys代表要获得多少个按键的状态。如果为NULL的话就是全部按键。\n其他函数 屏幕的虚拟键盘开启了吗\n1 SDL_bool SDL_IsScreenKeyboardShown(SDL_Window* window) 系统支持虚拟键盘吗\n1 SDL_bool SDL_HasScreenKeyboardSupport(void) ","description":"","tags":["SDL2"],"title":"SDL2-按键操作","uri":"/posts/sdl2-%E6%8C%89%E9%94%AE%E6%93%8D%E4%BD%9C/"},{"categories":null,"content":"对于SDL的文本输入操作，其wiki还专门给了一个教程：见这里 我们按照这个教程来简单说明一下。\n打开输入功能 首先，如果你想要用户输入文本，你需要使用 SDL_StartTextInput()函数打开文本输入功能，不想要输入的话使用SDL_StopTextInput()来停止输入。 你也可以使用SDL_IsTextInputActive()来判断是否打开了文本输入功能。\n获得用户输入的字符 打开了输入功能之后，系统就可以接收到文本输入事件了，有如下：\nSDL_TEXTINPUT 用户输入文本的事件 SDL_TEXTEDITING 用户修改文本的事件 我们首先需要使用的是SDL_TEXTINPUT。这个事件的event有一个text成员，记录了用户输入的字符（UTF-8的）。 这里需要注意的是，如果你使用的是英文，那么就是一次一个字符。但是如果你使用的是中文或者日文这种“多个按键合成一个字符”的输入法，那么当你按下空格之后就会一次性输入很多字符。比如你用搜狗输入法打出huijia，那么搜狗输入法的输入条会显示回家，然后你按下空格确认输入回家，这个时候text就是\"回家\"而不是\"h\"或者\"huijia\"。 搜狗输入法条\n于是你就可以通过这个来获得字符（而且组合键它也可以自动监测到，比如输入大小写）。但是没有办法检测到退格键和回车键，你可以通过键盘事件来检测：\n1 2 3 4 5 6 if(event.type == SDL_KEYDOWN){ if(event.key.keysym.sym == SDLK_BACKSPACE) textinput.pop_back(); if(event.key.keysym.sym == SDLK_RETURN) textinput += '\\n'; } 这样你就可以得到用户的输入了。\n其他输入法的输入 需要注意的是如果你使用中文输入法，那么情况会不大一样，下面是将中文显示到屏幕上的一段程序的结果，你可以看到和一般文本编辑器不同的地方：\n没错，我们在输入的时候居然没有在屏幕上显示。只有我们按下空格键（或者选择你要输入的文本）之后才会显示在屏幕上。也就是说输入法对文本的转换过程是不会触发SDL_TEXTINPUT事件的，而是会触发SDL_TEXTEDITING。\n正常的文本编辑器\n我们将这种通过多个键生成一个字符的方式叫做组合(Composition)\n这个时候我就要介绍SDL_TEXTEDITING这个事件了。 这个事件的event有三个成员：\ntext:正在键入的文本，比如“回家的诱惑”对应的就是“hui jia de you huo”（空格也会被检测到哦） start:修改的开始处 length:修改的长度 通过以上的事件就可以制作一个文本输入框了（虽然说还是很有难度的）。\n设置输入法条的位置和大小 这里还有一个函数可以影响输入法条的位置和大小:SDL_SetTextInputRect(SDL_Rect* rect) 通过给出一个SDL_Rect来指定输入法条的位置和宽度。 比如我的rect的x,y为0的时候，就会这样：\n如果指定y=300，会这样：\n可以看到距离明显变长了。\n有时候w和h属性并不能影响输入法条，这个要看不同的输入法和不同系统而定了。\n","description":"","tags":["SDL2"],"title":"SDL2-文本输入操作","uri":"/posts/sdl2-%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/"},{"categories":null,"content":"SDL本身是不支持文本的绘制的，如果你想要绘制文本的话你需要包含其第三方库SDL_ttf，下载网址在这里 顺带一提，SDL官方的所有拓展库都可以在这里找到，这个网址同时还有很多很多的学习资源（包括第一版DOOM的源代码）\n使用SDL_ttf 和SDL_image一样，首先得初始化，然后结束的时候需要释放：\nTTF_Init() TTF_Quit() 这两个函数都没有参数。\n接下来我们需要加载字体文件，使用TTF_OpenFont函数来打开。第一个参数是字体文件，第二个参数是加载过后字体的大小：\n1 TTF_Font* font = TTF_OpenFont(\"font.ttc\", 24); 接下来你就可以通过SDL_Surface* surface = TTF_RenderUTF8_Blended();函数来得到一个有文字的SDL_Surface*了。这个函数第一个参数是TTF_Font*，第二个参数是文字，第三个参数是颜色。\n其实这里有很多的绘制文字的参数。但是由于我们使用的是中文，所以我们选择了RenderUTF8_Blended()。具体的函数名称有一下格式： TTF_Render_ 这里encoding为编码的方式，type为渲染的类型，分别可以是： encoding:\nGlyph Text 普通文字 UTF8 UNICODE type可以是\n没有， 代表用最普通的方式渲染 Blended，高级的渲染方式 Solid，实体的 Shaded，有阴影的，会有额外的参数来指定阴影 Blended_Wrapped:最高级的渲染方式，最清晰，最慢 其中各个选项的效率从大到小依次为： Blended_Wrapped Blended Shaded Solid 无 同样，效率越低，渲染出来的文字清晰度越高。\n然后你就可以通过SDL_BlitSurface或者转换成SDL_Texture来绘制到屏幕上了。\n最后你需要关闭已经打开的字体文件: TTF_CloseFont()。\n使用SDL_FontCache绘制文字 虽然SDL_ttf是SDL官方开发的库，但是效率不是很高，而且也不是很好用。主要有以下几个缺点：\n不能够解析字符串中的\\t和\\n \\b等字符，也就是说如果你想要换行的话还得重新给一个Surface 效率很低，如果你想要每一帧都渲染不同的文本的话，那么你需要下面这个循环： 1 2 3 4 5 6 7 8 9 10 11 12 13 //循环中 SDL_Surface* surface = TTF_RenderUTF8_Blended(font, textinput.c_str(), color); if(surface != nullptr){ SDL_Texture* texture = SDL_CreateTextureFromSurface(render, surface); SDL_Rect dstrect; dstrect.x = 0; dstrect.y = 0; dstrect.w = surface-\u003ew; dstrect.h = surface-\u003eh; SDL_RenderCopy(render, texture, nullptr, \u0026dstrect); SDL_DestroyTexture(texture); SDL_FreeSurface(surface); } 可以看到每一帧都要生成和释放surface和texture。效率很低。\n这里我们使用SDL_FontCache，这不是SDL官方开发的，但是可以解析特殊字符，以及可以直接使用SDL_Renderer*进行绘制，不需要生成繁琐的surface和texture，而且还支持一些特殊的字体样式（如粗体和斜体等），而且使用了缓存技术提升了效率。\nSDL_FontCache的github地址在这里 这个库的文件很少，只有一个SDL_FontCache.c和一个SDL_FontCache.h文件。你可以将.c文件编译成链接库，或者直接和源代码一起编译。 需要注意的是：\nSDL_FontCache使用的是纯C，其中有些代码不能直接和C++11代码在一起编译，你需要拆分开来编译，也就是说\ng++ textinput.cpp SDL_FontCache.c -o textinput `sdl2-config --libs --cflags` `pkg-config --libs --cflags SDL2_ttf` -std=c++11 是不行的，你必须将.c文件分开编译：\ngcc ./SDL_Cache/SDL_FontCache.c -c `sdl2-config --libs --cflags` `pkg-config --libs --cflags SDL2_ttf` g++ textinput.cpp SDL_FontCache.o -o textinput `sdl2-config --libs -std=c++11 SDL_FontCache.h文件需要SDL2和SDL_ttf文件，而且它是这样包含的:\n#include \"SDL.h\" #include \"SDL_ttf.h\" 所以如果你的SDL2和SDL_ttf的路径和他的不一致的话，你可以进.h文件改一下源码\n接下来就是使用SDL_FontCache库了。官方有一个例子，我们来看一下：\n1 2 3 4 5 6 FC_Font* font = FC_CreateFont(); FC_LoadFont(font, renderer, \"fonts/FreeSans.ttf\", 20, FC_MakeColor(0,0,0,255), TTF_STYLE_NORMAL); ... FC_Draw(font, renderer, 0, 0, \"This is %s.\\n It works.\", \"example text\"); ... FC_FreeFont(font); 首先通过FC_CreateFont()来创建一个文字句柄。 然后通过FC_LoadFont()函数来加载一个字符文件，其中第四个参数是SDL_Color用于指定颜色，但是它自己有FC_MakeColor()函数来直接生成一个颜色。第五个参数是字体的样式，可以是TTF_STYLE_ NORMAL,BOLD,ITALIC,OUTLINE,STRIKETHROUGH,UNDERLINE中的一个 然后直接通过FC_Draw()函数就可以绘制出来了，无需变为texture，而且FC_Draw()是类似printf的风格，可以用占位符的。 最后当你用完了可以使用FC_FreeFont()函数释放掉。\n这个库还有很多的函数，但是由于没有文档只有源代码，所以在这里我也就不分析了，有兴趣可以自己看看源码，.c文件也就两千多行。\n","description":"","tags":["SDL2"],"title":"SDL2-绘制文本","uri":"/posts/sdl2-%E7%BB%98%E5%88%B6%E6%96%87%E6%9C%AC/"},{"categories":null,"content":"官方给了很多的版本获取宏和函数，但是我觉得根本没有这个必要，我们这里只介绍一个函数和一个宏，其他的请到官方文档去看一看。\n我们的函数就是SDL_GetVersion(SDL_version* version)，宏是SDL_VERSION(version)。这两个都需要一个SDL_version*，而SDL_version是一个结构体，只有三个成员major,minor,patch。所以你只需要这一个函数或者宏就可以得到SDL的版本了。\n区别在于：SDL_VERSION是获得链接库的版本，而SDL_GetVersion()是获得编译的版本。也就是说一个是链接库的版本，一个是头文件的版本。\n","description":"","tags":["SDL2"],"title":"SDL2-版本获取","uri":"/posts/sdl2-%E7%89%88%E6%9C%AC%E8%8E%B7%E5%8F%96/"},{"categories":null,"content":"SDL的日志功能很简单. 首先要明确，SDL的每个日志都由两个条件决定：\ncategory：类型，可以是如下几个：\nSDL_LOG_CATEGORY_APPLICATION SDL_LOG_CATEGORY_ERROR SDL_LOG_CATEGORY_ASSERT SDL_LOG_CATEGORY_SYSTEM SDL_LOG_CATEGORY_AUDIO SDL_LOG_CATEGORY_VIDEO SDL_LOG_CATEGORY_RENDER SDL_LOG_CATEGORY_INPUT SDL_LOG_CATEGORY_TEST 测试用 SDL_LOG_CATEGORY_CUSTOM 用户自己定义的 SDL_LOG_CATEGORY_RESERVED 为了未来SDL版本的拓展使用，用户不应该占用。 可以看到这些都对应着SDL的模块，也就是按照模块信息分类的\npriority：日志级别，这个用过日志库的都很熟悉了，有如下几个：\nSDL_LOG_PRIORITY_VERBOSE SDL_LOG_PRIORITY_DEBUG SDL_LOG_PRIORITY_INFO SDL_LOG_PRIORITY_WARN SDL_LOG_PRIORITY_ERROR SDL_LOG_PRIORITY_CRITICAL 那么优先级就是CRITICAL\u003eERROR\u003eWARN\u003eINFO\u003eDEBUG\u003eVERBOSE\n接下来就是我们常见的日志库中的日志函数了。SDL的日志函数都是类printf格式的。有如下日志函数： SDL_Log SDL_Log Critical/Debug/Error/Info/Verbose/Warn/Message 其中SDL_Log会默认将日志记到SDL_LOG_CATEGORY_APPLICATION,SDL_LOG_PRIORITY_INFO类别中。其他的都需要指定。 SDL_LogMessage的第一个参数是category，第二个参数是priority，可以将日志记到任意类别和优先级中。其他的就是按照优先级命名的日志函数了，第一个参数都是category。\n接下来就是关于日志优先级的函数了：\nSDL_LogGetPriority(int category)获得优先级 SDL_LogResetPriorities()将所有category的优先级设为默认（INFO级） SDL_LogSetPriority(int category,SDL_LogPriority priority)改变优先级。 SDL_LogSetAllPriority(SDL_LogPriority priority)设置所有category的日志一个优先级。 最后SDL还允许你自定义日志的输出方式。你可以给一个函数给SDL，他会按照调用你的函数来输出：\nSDL_LogGetOutputFunction(SDL_LogOutputFunction* callback,void** userdata)：获得当前的日志格式函数和额外数据 SDL_LogSetOutputFunction(SDL_LogOutputFunction callback,void* userdata)：设置日志输出格式函数，函数需要有下面的格式 void SDL_LogOutputFunction(void* userdata,int category,SDL_LogPriority priority,const char* message) ","description":"","tags":["SDL2"],"title":"SDL2-日志","uri":"/posts/sdl2-%E6%97%A5%E5%BF%97/"},{"categories":null,"content":"SDL错误检测和处理一共就三个函数：\nSDL_ClearError()：清除所有错误 const char* SDL_GetError():获得前一个出错函数产生的错误信息（英文） SDL_SetError(const char* fmt,...):设置自己的错误，格式类似printf。（这个函数总是返回-1） SDL的错误处理是这样的：SDL的函数首先会有一个int返回值表示函数是否出错了（一般0为成功，负数表示发生了错误），然后会向错误变量中记录这个错误的文字信息，这个时候你就可以通过SDL_GetError()来获得错误了。你也可以通过SDL_SetError()来向错误变量中记录自己的错误。SDL_ClearError()来清除错误变量记录的内容。\n","description":"","tags":["SDL2"],"title":"SDL2-错误检测和处理","uri":"/posts/sdl2-%E9%94%99%E8%AF%AF%E6%A3%80%E6%B5%8B%E5%92%8C%E5%A4%84%E7%90%86/"},{"categories":null,"content":"SDL操作剪切版的函数很简单：\nchar* SDL_GetClipboardText(void)：获得剪切板内容 SDL_bool SDL_HasClipboardText(void)：判断剪切板内是否有内容 int SDL_SetClipboardText(const char* text)：将文字放入剪切板（返回0成功，返回负值失败） ","description":"","tags":["SDL2"],"title":"SDL2-剪切板","uri":"/posts/sdl2-%E5%89%AA%E5%88%87%E6%9D%BF/"},{"categories":null,"content":"由于SDL2是C语言库，所以提供了多线程的库。但是我们是用C++编写的，不如直接使用C++的线程库咯。这部分等我有时间会补上的\n","description":"","tags":["SDL2"],"title":"SDL2-多线程","uri":"/posts/sdl2-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":null,"content":"SDL2渲染器 有了窗口之后，我们还需要有一个渲染器。渲染器用于将图像渲染到窗口上。\n创建渲染器 通过SDL_CreateRenderer()函数来创建渲染器：\n1 2 3 SDL_Renderer* SDL_CreateRenderer(SDL_Window* window, int index, Uint32 flags) window:需要为哪个窗口创建渲染器 index:渲染器驱动需要初始化的渲染器索引。-1为默认渲染器 flags:渲染器flag，为SDL_RendererFlags枚举类型。有以下四个值 SDL_RENDERER_SOFTWARE：软件渲染 SDL_RENDERER_ACCELERATED：用硬件加速渲染 SDL_RENDERER_PRESENTVSYNC：画面与刷新速率同步 SDL_RENDERER_TARGETTEXTURE：渲染器支持纹理渲染 一般index都是-1。如果你明确知道自己有其他的渲染器的话，可以用其他值。但是我们一般都是使用-1来用默认渲染器。\n与窗口一起创建渲染器 你也可以使用SDL_CreateWindowAndRenderer()来连同渲染器一起创建窗口：\n1 2 3 4 5 int SDL_CreateWindowAndRenderer(int width, int height, Uint32 window_flags, SDL_Window** window, SDL_Renderer** renderer) 但是这里就不能指定窗口的初始坐标和标题了。\nRenderer是否有Target\n1 SDL_bool SDL_RenderTargetSupported(SDL_Renderer* renderer) 返回SDL_bool有两个值：SDL_TRUE,SDL_FALSE，分别对应true和false.\n获得RenderDriver个数 通过SDL_GetNumRenderDrivers()来获得驱动个数。小于0表示失败。\n1 int SDL_GetNumRenderDrivers(void) 获得RenderDriver信息 通过SDL_GetRenderDriverInfo()来获得。返回负值表示失败.\n1 2 int SDL_GetRenderDriverInfo(int index, SDL_RendererInfo* info) 获得Renderer信息 通过SDL_GetRendererInfo()获得Renderer信息：\n1 2 int SDL_GetRendererInfo(SDL_Renderer* renderer, SDL_RendererInfo* info) 该函数将信息返回到info中，SDL_RendererInfo结构体见这里\n获得/设置Renderer渲染目标 通过SDL_Get/SetRenderTarget()函数\n1 2 3 4 SDL_Texture* SDL_GetRenderTarget(SDL_Renderer* renderer) int SDL_SetRenderTarget(SDL_Renderer* renderer, SDL_Texture* texture) 其中texture必须为指定了SDL_TEXTUREACCESS_TARGET这个Flag所创建出来的texture。或者给入NULL表示默认texture.\n获得Renderer的输出大小\n1 2 3 int SDL_GetRendererOutputSize(SDL_Renderer* renderer, int* w, int* h) 这个函数可以获得Renderer的绘制图像的大小。默认为生成的窗体大小。\n设置Renderer混合模式\n1 2 3 4 5 int SDL_SetRenderDrawBlendMode(SDL_Renderer* renderer, SDL_BlendMode blendMode) int SDL_GetRenderDrawBlendMode(SDL_Renderer* renderer, SDL_BlendMode* blendMode) 这里的belnMode为枚举类型：\nSDL_BLENDMODE_NONE:dstRGB = srcRGB SDL_BLENDMODE_BLEND:dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA));dstA = srcA + (dstA * (1-srcA)) SDL_BLENDMODE_ADD:dstRGB = (srcRGB*srcA) + dstRGB;dstA = dstA SDL_BLENDMODE_MOD:dstRGB = srcRGB * dstRGB;dstA = dstA 将当前的渲染数据绘制到窗体上面 通过SDL_RenderPresent()来会自豪当前图像数据到窗体上面:\n1 void SDL_RenderPresent(SDL_Renderer* renderer) 销毁Renderer 使用SDL_DestroyRenderer()销毁：\n1 void SDL_DestroyRenderer(SDL_Renderer* renderer) ","description":"","tags":["SDL2"],"title":"SDL2-渲染器SDL_Renderer","uri":"/posts/sdl2-%E6%B8%B2%E6%9F%93%E5%99%A8sdl_renderer/"},{"categories":null,"content":"这里我们先来一个Hello World来看看什么是SDL。这一部分可能比较多。\nSDL2的配置 下载安装之后需要配置SDL。具体的配置方法在这里 SDL的教程比较好的是Lazy Foo的博客，地址在这里 或者你可以看SDL官方写的书《SDL Game Development》\nHello World 这里给出SDL2的Hello World。这个Hello World的功能是产生一个700x700的窗口，背景是绿色的，并且会绘制一幅图片在上面： 现在来看看这个Hello World：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #include \u003cSDL2/SDL.h\u003e #include \u003cSDL2/SDL_image.h\u003e #include \u003ciostream\u003e using namespace std; const int WIDTH=700; const int HEIGHT=700; const int DELAYTIME=30; SDL_Window* mainwindow = nullptr; SDL_Renderer* render = nullptr; SDL_Surface* surface = nullptr; SDL_Texture* texture = nullptr; SDL_Event event; SDL_Rect imgRect,destRect; bool isquit=false; bool init(); void renderScreen(); void handleEvent(); void update(); void clean(); int main(int argc,char** argv){ if(init()==false){ SDL_Log(\"Init faliled\"); return -1; } SDL_Log(\"Init success\"); while(isquit==false){ renderScreen(); update(); SDL_Delay(DELAYTIME); } SDL_Log(\"Window is quit\\n\"); clean(); SDL_Log(\"SDL quit\"); return 0; } bool init(){ if(SDL_Init(SDL_INIT_EVERYTHING)\u003c0){ cerr\u003c\u003c\"SDL2 can't be init!\"; return false; } mainwindow = SDL_CreateWindow(\"hello world\",SDL_WINDOWPOS_CENTERED,SDL_WINDOWPOS_CENTERED,WIDTH,HEIGHT,SDL_WINDOW_RESIZABLE); if(mainwindow==nullptr){ cerr\u003c\u003c\"can't create window!\"; return false; } render = SDL_CreateRenderer(mainwindow,-1,0); if(render == nullptr){ cerr\u003c\u003c\"can't create renderer!\"; return false; } surface = IMG_Load(\"1.jpeg\"); if(surface==nullptr){ cerr\u003c\u003c\"1.jpeg is not found\"; SDL_Log(\"img is not loaded\"); }else{ texture = SDL_CreateTextureFromSurface(render,surface); SDL_QueryTexture(texture,nullptr,nullptr,\u0026imgRect.w,\u0026imgRect.h); destRect=imgRect; imgRect.x=imgRect.y=0; SDL_Log(\"the image width and height is:%d,%d\",imgRect.w,imgRect.h); } return true; } void renderScreen(){ SDL_RenderClear(render); SDL_SetRenderDrawColor(render,0,200,0,255); } void handleEvent(){ while(SDL_PollEvent(\u0026event)){ if(event.type == SDL_QUIT) isquit=true; } } void update(){ handleEvent(); destRect.x=destRect.y=100; SDL_RenderCopy(render,texture,\u0026imgRect,\u0026destRect); SDL_RenderPresent(render); } void clean(){ SDL_FreeSurface(surface); SDL_DestroyTexture(texture); SDL_DestroyWindow(mainwindow); SDL_Quit(); } 这里将不同的功能放入了不同的函数，以便代码的阅读。这个代码的结构大体如下： 初始化SDL2，创建窗体，创建渲染器，窗体事件循环，程序结束清理\n包含头文件 首先是两行的包含头文件的代码：\n1 2 3 4 #include \u003cSDL2/SDL.h\u003e #include \u003cSDL2/SDL_image.h\u003e #include \u003ciostream\u003e using namespace std; 包含了每次使用SDL都必须的头文件SDL.h。以及SDL2拓展库SDL_image.h。SDL_image.h不属于标准SDL里面。但是因为标准SDL的图像读取函数Load_Image只能读取bmp,jpeg。所以使用SDL_image.h的IMG_Load()来读取。还包含了C++的iostream，并且使用了命名空间std。\n变量的声明 声明了一些变量：\n1 2 3 4 5 6 7 8 9 10 const int WIDTH=700; const int HEIGHT=700; const int DELAYTIME=30; SDL_Window* mainwindow = nullptr; SDL_Renderer* render = nullptr; SDL_Surface* surface = nullptr; SDL_Texture* texture = nullptr; SDL_Event event; SDL_Rect imgRect,destRect; bool isquit=false; WIDTH和HEIGHT是生产窗体的大小，DEKAYTIME表示游戏一帧的延时时间。接下来以SDL开头的就是SDL自己的结构体，分别代表窗口，渲染器，表面，纹理，事件和矩形结构。最后声明一个bool变量来判断游戏是否结束。\n接下来是一些函数的前置声明：\n1 2 3 4 5 bool init(); void renderScreen(); void handleEvent(); void update(); void clean(); init()函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 bool init(){ if(SDL_Init(SDL_INIT_EVERYTHING)\u003c0){ cerr\u003c\u003c\"SDL2 can't be init!\"; return -1; } mainwindow=SDL_CreateWindow(\"hello world\",SDL_WINDOWPOS_CENTERED,SDL_WINDOWPOS_CENTERED,WIDTH,HEIGHT,SDL_WINDOW_RESIZABLE); if(mainwindow==nullptr){ cerr\u003c\u003c\"can't create window!\"; return -1; } render = SDL_CreateRenderer(mainwindow,-1,0); if(render == nullptr){ cerr\u003c\u003c\"can't create renderer!\"; return -1; } surface = IMG_Load(\"1.jpeg\"); if(surface==nullptr){ cerr\u003c\u003c\"1.jpeg is not found\"; SDL_Log(\"img is not loaded\"); }else{ texture = SDL_CreateTextureFromSurface(render,surface); SDL_QueryTexture(texture,nullptr,nullptr,\u0026imgRect.w,\u0026imgRect.h); destRect=imgRect; imgRect.x=imgRect.y=0; SDL_Log(\"the image width and height is:%d,%d\",imgRect.w,imgRect.h); } return 1; } 首先是初始化函数init。里面发生了以下的事情：\nSDL_Init()。每次使用SDL的时候都必须调用这个函数来进行初始化，这样才可以使用SDL引擎。这里传入SDL_INIT_EVERYTHING来表示初始化SDL的每个部分。如果初始化失败会返回小于0的数值。 SDL_CreateWindow()。用于创建以个窗体，返回一个SDL_Window*的指针。其中的参数分别表示窗体的标题，初始x，y坐标，初始大小（宽度和高度）以及窗体类型。这里入的参数说明是一个700x700，显示在屏幕中央的可变大小的窗体。 SDL_CreateRenderer()。创建一个渲染器，返回一个SDL_Renderer*。每个窗体都需要一个渲染器用于渲染图像。这个函数的第一个参数是为哪个窗体创建渲染器。后面的-1和0默认。 IMG_Load()。这个是SDL_image.h头文件里的函数，用于读入一个图像并且放在surface里面。这个函数可以读取几乎任何的图像格式，而不像SDL2自带的Load_Image()只能够读取bmp和jpg。 SDL_Log()。存在在if语句里面的日志函数，用法和printf()函数一样，用于在控制台输出格式化的日志。 SDL_CreateTextureFromSurface()。从surface创建一个texture。返回SDL_Texture*。参数分别是对应的渲染器和surface。 Surface和Texture的区别 Surface是表面，是SDL1的产物，用于绘制图像，但是其占用的是内存，完全由CPU绘制。Texture是纹理，是SDL2新增的结构体，放在显存里面，用GPU加速。SDL2推荐的是Texture。但是目前Texture只可以通过Surface来进行构造。 SDL_QueryTexture()。查询Texture。这个函数可以或者Texture的一些信息。这里获得了其大小。 renderScreen()函数 这个函数用于渲染窗体\n1 2 3 4 void renderScreen(){ SDL_RenderClear(render); SDL_SetRenderDrawColor(render,0,200,0,255); } SDL_RenderClear()。用Renderer的颜色来清空窗口。 SDL_SetRenderDrawColor()。设置Render的颜色。这里给了绿色。这个颜色带有第四个参数alpha值。 handleEvent()函数 用于事件循环\n1 2 3 4 5 6 void handleEvent(){ while(SDL_PollEvent(\u0026event)){ if(event.type == SDL_QUIT) isquit=true; } } 使用了SDL_PollEvent()函数来获得事件。如果是SDL_QUIT（退出）事件，就置isquit=true来退出循环。\nupdate 用于更新游戏状态\n1 2 3 4 5 6 void update(){ handleEvent(); destRect.x=destRect.y=100; SDL_RenderCopy(render,texture,\u0026imgRect,\u0026destRect); SDL_RenderPresent(render); } 首先调用了handleEvent()函数来进行事件处理 83行置图像最终要绘制的x，y坐标为(100，100) SDL_RenderCopy()。用于将Texture绘制到窗体上，但是不可以旋转和翻转图像（如果想要旋转和翻转需要使用SDL_RenderCopyEx()）。参数分别为渲染器，纹理，要绘制的图像区域和目的地。 SDL_RenderPresent()。将当前窗体绘制出来。 clean() 游戏结束后的清除。\n1 2 3 4 5 6 void clean(){ SDL_FreeSurface(surface); SDL_DestroyTexture(texture); SDL_DestroyWindow(mainwindow); SDL_Quit(); } 这个函数里面清除了一些游戏资源，包括surface，texture，window。并且调用SDL_Quit()退出了SDL引擎。\n","description":"","tags":["SDL2"],"title":"SDL2-HelloWorld","uri":"/posts/sdl2-helloworld/"},{"categories":null,"content":"初始化并非只有SDL_Init一个函数。让我们来看看还有其他什么函数\nSDL_Init SDL_Init函数很简单，其参数为要初始化的模块（SDL有很多模块，像是时间模块SDL_INIT_TIMER,声音模块SDL_INIT_AUDIO,显示模块SDL_INIT_VIDEO等）。你也可以通过SDL_INIT_EVERYTHING来初始化所有模块。具体模块如下：\nSDL_INIT_TIMER SDL_INIT_AUDIO SDL_INIT_VIDEO SDL_INIT_JOYSTICK 摇杆模块 SDL_INIT_HAPTIC 压力模块，用于移动端 SDL_INIT_GAMECONTROLLER 游戏手柄模块 SDL_INIT_EVENTS 事件模块 有了这些控制符，你可以在节省资源的情况下使用任意模块。 这个函数成功会返回0，失败返回一个小于0的数。\nSDL_InitSubSystem 这个函数和SDL_Init()函数差不多，可以在你使用SDL_Init()之后再次初始化你要的模块。\nSDL_QuitSubSystem 这个函数是对应SDL_InitSubSystem, SDL_Init函数的，用于关闭已经初始化的模块。\nSDL_WasInit 判断模块是否初始化。其参数为一个flag（从SDL_INIT_xx中选择）表示你想要知道哪个模块的信息。如果你传入0回返回所有初始化模块的按位或运算的结果，那么你可以这样得到模块初始化信息：\n1 2 3 4 5 6 7 Uint32 subsystem_init = SDL_WasInit(SDL_INIT_EVERYTHING); if (subsystem_init \u0026 SDL_INIT_VIDEO) { printf(\"Video is initialized.\\n\"); } else { printf(\"Video is not initialized.\\n\"); } 或者直接传入模块，那样如果初始化回返回非0值：\n1 2 3 4 5 if (SDL_WasInit(SDL_INIT_VIDEO) != 0) { printf(\"Video is initialized.\\n\"); } else { printf(\"Video is not initialized.\\n\"); } SDL_Quit SDL_Quit会强制退出所有的模块。\n接下来要说的是一些模块独立的初始化函数。这些初始化函数初始化的模块不能够被SDL_Quit或者SDL_QuitSubSystem函数关闭，必须调用相应的函数来关闭：\nSDL_VideoInit(const char* driver_name)初始化Video模块，传入驱动名称，NULL为默认驱动。对应关闭函数SDL_VideoQuit int SDL_AudioInit(const char* driver_name)初始化Audio模块（用法同SDL_VideoInit），关闭函数SDL_AudioQuit ","description":"","tags":["SDL2"],"title":"SDL2-初始化","uri":"/posts/sdl2-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":null,"content":"一个游戏，如果想要开始的话，必须得先有一个窗口。这里我们先来创造一个窗口。\nSDL_Window结构体 由于SDL2是C语言写的，所以他没有对象什么的，只有结构体。窗体的结构体是SDL_Window。如果你查阅的是SDL2的官方文档，那么如果他的结构体有提供给你操作的属性，他会直接给你。但是SDL_Window的结构体没有给出任何的属性，所以只能使用函数来操控了。 每一个SDL_Window都代表着一个窗口，如果被正确构造的话。\nSDL_CreateWindow 这个函数会创建一个窗口，他的用法如下：\n1 2 3 4 5 6 SDL_Window* SDL_CreateWindow(const char* title, int x, int y, int w, int h, Uint32 flags) 参数说明如下：\ntitle。一个字符串，为窗体的标题。 x，y。表示以整个屏幕为坐标系的窗体位置。 w，h。表示窗体的大小 flags。表示窗体的样式，其为SDL_WindowFlags。这个枚举的取值在这里 这个函数返回一个SDL_Window*的结构体指针。 于是我们就可以使用这个函数来创造一个窗口了：\n1 SDL_Window* win = SDL_CreateWindow(\"Hello World\",SDL_WINDOWPOS_CENTERED,SDL_WINDOWPOS_CENTERED,700,700,SDL_WINDOW_SHOWN); 这里的flags我们给的是SDL_WINDOW_SHOWN，表示创建的之后直接显示窗口。你也可以使用按位或运算来组合多个值，比如SDL_WINOW_FULLSCREEN可以全屏窗口之类的。\n窗口动不了或者一闪而过？？？ 如果你的代码仅仅是：\n1 2 3 4 int main(int argc,char** argv){ SDL_Window* win = SDL_CreateWindow(\"Hello World\",SDL_WINDOWPOS_CENTERED,SDL_WINDOWPOS_CENTERED,700,700,SDL_WINDOW_SHOWN); return 0; } 那么即使创建完成窗口了，由于程序结束了，所以也会一闪而过。 如果你加上了while循环，那么可以保证窗体显示出来，但是会移动不了：\n1 2 3 4 5 int main(int argc,char** argv){ SDL_Window* win = SDL_CreateWindow(\"Hello World\",SDL_WINDOWPOS_CENTERED,SDL_WINDOWPOS_CENTERED,700,700,SDL_WINDOW_SHOWN); while(1); return 0; } 这是因为还没有事件处理，所以没有办法去移动或者操作。 我们这里仅仅只是创建了一个窗口而已，要怎么显示这个窗口还要到渲染器那一章再说。\n获得窗口的状态 这里还有一些函数来获得窗口的状态：\nSDL_GetWindowFlags()用于获得你设置的flags。你可以使用按位或运算来判断这个窗口的样式:Uint32 SDL_GetWindowFlags(SDL_Window* window) SDL_GetWindowSize()这个函数获得窗体的大小：void SDL_GetWindowSize(SDL_Window* window, int* w, int* h) SDL_GetRendererOutputSize()用于获得渲染器渲染的大小： int SDL_GetRendererOutputSize(SDL_Renderer* renderer, int* w, int* h) 想必你已经发现了，每个关于窗口的函数都需要SDL_Window*参数，这是因为这些函数需要知道是对哪个窗体进行操作。 销毁窗体 由于SDL_CreateWindow()返回的是一个指针，而参数又没有传入指针，所以很明显SDL_CreateWindow()再内部malloc了一个指针，然后返回他。既然是malloc的指针，就必须free掉。但是这里你不可以直接使用free()函数，而需要使用SDL_DestroyWindow()来销毁窗体（其实SDL_DestroyWindow()内部也是使用的free，但是你不要直接用free）：\n1 void SDL_DestroyWindow(SDL_Window* window) 这样这个窗口就被我们销毁了。\n由于SDL2是C语言编写的，所以会有很多的创造和销毁函数，这些函数最好成对出现（你也可以等着程序结束自动释放资源，但是我极度不建议你这样做），因为程序员产出的内存，程序员要对其负责。\n","description":"","tags":["SDL2"],"title":"SDL2-创建窗口","uri":"/posts/sdl2-%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3/"},{"categories":null,"content":"​\tSDL2(Simple Direct Media Player 2) 是一个用于多媒体技术，游戏编程，计算机辅助设计的，一个用于绘图和事件处理的库。大多数人将其看作游戏引擎，包括其官网也是在大力宣传其在游戏编程方面的成果。但是正如DirectX一样，SDL的也被用来制作多媒体或者数据展示等。 SDL2比起SDL1来说改变的幅度很大，所以我们这里介绍的是SDL2而不是SDL1.最新的SDL应该是2.0.9版本。你可以从这里下载。 SDL2是一个跨平台的(Windows, Mac OS X, Linux, iOS, and Android)，由C编写的程序库。也可以使用C++来编写，同时也给出了很多其他语言的支持，比如python的pygame和pygame-SDL。具体的支持见这里。 和OpenGL不一样，SDL2大部分用来处理2D游戏，但是其内置对OpenGL的原生支持，你也可以用它来编写3D游戏。SDL2是个底层的游戏引擎，这意味着它包含着绘图，时间与事件处理等基本操作，但是不提供帧动画，场景和几何变换等高级的功能，这些功能需要程序员自己利用SDL，数学知识和编程知识进行编写。SDL十分底层，可以用来在其上进行二次开发来制作新的游戏引擎（比如OGRE就是基于SDL2的）。 如果你想使用高级的游戏引擎，请参阅cocos2dx，Unity3D，Unreal Engine等知名的游戏引擎。这些引擎将大多数游戏编程的元素封装好了便于程序员使用。但是如果你想要从底层开发的话，SDL仍然是一个不错的选择。 SDL也提供了自身的API文档，你可以参阅这里\n","description":"","tags":["SDL2"],"title":"SDL2是个啥","uri":"/posts/sdl2%E6%98%AF%E4%B8%AA%E5%95%A5/"},{"categories":null,"content":"这里是本书第一章的笔记，第一章主要强调了一些数值计算方面的问题。\n数值计算问题 底层问题 因为计算机存储浮点数的原因，导致存储的数字和实际数字之间可能存在偏差，将 $r$ 记作纯数学意义上的数字， $f(r)$ 记为r在计算机中存储的实际数字。\n误差 绝对误差(absolute error)记作： $$ \\abs{f(r) - r} $$ 相对误差(relative error)记作： $$ \\frac{\\abs{f(r) - r}}{\\abs{r}} $$\n不精准的浮点数带来的精度问题 在数学上，$s + r \\ne r(s \\ne 0)$，但在计算机中可能存在$f(s)+f(r) = f(r)(f(s) \\ne 0)$，这往往是因为$f(r) $要远大于$f(s)$。\n计算顺序的不一致也会导致结果不一样，也就是说存在 $$ (f(r)+f(s))+ f(t) \\ne f(r)+(f(s)+f(t)) $$ 比如说，$f(r)$远大于$f(s)$和$f(t)$时，会导致 $$ f(r)+f(t) = f(r) \\ f(r) + f(s) = f(r) $$ 这样，$(f(r) + f(t))+f(s) = f(r)$。\n但是，如果先求$f(s)+f(t)$，则可能导致其结果足够大，以至于$f(r)+(f(s)+f(t)) \\ne f(r)$。\n所以，求和的一般顺序是按照数字从小到大依次求和。\n更高层次的问题 浮点数所带来的的误差会直接影响到算法。比如判断某个点$p$是否在四边形$\u003cV1,V2,V3,V4\u003e$中，满足如下任意条件即为在四边形中：\n$p$在三角形$\u003cV1,V2,V4\u003e$中 $p$在三角形$\u003cV2,V3,V4\u003e$中 $p$在线段$\u003cV1, V3\u003e$上 但是由于误差，可能存在$p$点离四边形某条边特别近，以至于算法误判$p$位于边上，从而导致结果为false。这在德劳内三角化算法有体现。\n因为这些误差的存在，导致我们在写算法时不能完全相信数学推导的结果，而要考虑误差所带来的影响。\n","description":"","tags":["图形学"],"title":"《Geometric Tools For Computer Graphics》读书笔记1","uri":"/posts/geomentric-tools-for-computer-graphics%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/"},{"categories":null,"content":"这里是2~4章的读书笔记，主要是回顾了线性代数知识，有些知识我已经接触很多遍了就没记。\n线性代数和变换 矩阵和线性系统 线性代数中的变换(Transformation)可以通过如下三种方式理解：\n变换坐标系：这种情况下只是变换了坐标系而没有变换坐标系中的点 变换点：变换了点本身的信息，但是坐标系没有变动 从一个平面到另一个平面的变换：点和坐标系信息都变动 从不同角度理解会导致推导过程的不同，进而影响代码编写。\n本书从向量几何学角度讨论变换，即直接关注点本身，并且用几何运算直接操作（而不是从一开始就考虑矩阵和坐标系），向量几何学和线性代数变换的关系有点类似于平面几何和解析几何的关系。\n多元组 定义 本质上就是一个元素的有序序列，用圆括号表示： $$ a = (1, 2, 9) \\ b = (\\pi, 3.78, 8, 15) $$ 有两个元素的叫做有序对(ordered pair)，三个元素的叫做三元组(ordered triple)，四个元素叫做四元组。不管怎么说，通用说法是多元组(tuple)（没错就是你！std::tuple!）\n矩阵，向量代数和变换 运算 $$ a = (a_1, a_2, \\cdots, a_n) \\ b = (b_1, b_2, \\cdots, b_n) \\ a \\pm b = (a_1 \\pm b_1, a_2 \\pm b_2, \\cdots, a_n \\pm b_n)\\ ka = (ka_1, ka_2, \\cdots, ka_n) $$\n当多元组内全是实数时，其实就构成了向量，那么对于多元组的乘法就有两种：\n数量积/点积： $$ a \\cdot b = a_1b_1 + a_2b_2 + \\cdots a_nb_b $$ 向量积/叉积：$a \\times b$（根据不同维度的向量有不同算法）.\n矩阵 本书中将矩阵视为一组多元组（但其实并没有什么卵用，运算还是那些运算，只是为了更好地导入矩阵概念）。\n线性系统 线性方程 指方程的各项不是线性项就是常数： $$ a_1x_1 + a_2x_2 + \\cdots + a_nx_n = c $$ 之所以被称为线性方程，是因为n元线性方程的解在n维空间中总是一条直线。\n线性系统 **线性系统(linear system)其实就是线性方程组。**比如二元线性方程组： $$ \\begin{cases} a_1x_1 + a_2x_2 = c_1 \\ b_1x_1 + b_2x_2 = c_2 \\end{cases} $$ 这两个线性方程其实代表着二维空间中的两个直线，那么两个直线有三种可能：\n两直线相交，这时方程组有解 两直线平行，即$\\frac{a_1}{b_1}=\\frac{a_2}{b_2}\\ne \\frac{c_1}{c_2}$，这时方程组无解 两直线重合，即$\\frac{a_1}{b_1}=\\frac{a_2}{b_2}= \\frac{c_1}{c_2}$，这时有无数个解 一般线性系统就是指线性系统的一般形式： $$ \\begin{cases} a_{1,1}x_1 + a_{1,2}x_2 + \\cdots + a_{1,n}x_n = c_1 \\ a_{2,1}x_1 + a_{2,2}x_2 + \\cdots + a_{2,n}x_n = c_2 \\ \u0026 \u0026 \\vdots \u0026 \\ a_{m,1}x_1 + a_{m,2}x_2 + \\cdots + a_{m,n}x_n= c_m \\ \\end{cases} $$ 这种形式可以写成矩阵： $$ AX=C $$ 那么这里$A$就是系数矩阵： $$ \\begin{bmatrix} a_{1,1} \u0026 a_{1,2} \u0026 \\cdots \u0026 a_{1,n}x_n \\ a_{2,1}x_1 \u0026 a_{2,2}x_2 \u0026 \\cdots \u0026 a_{2,n}x_n \\ \u0026 \u0026 \\vdots \u0026 \\ a_{m,1}x_1 \u0026 a_{m,2}x_2 \u0026 \\cdots \u0026 a_{m,n}x_n \\ \\end{bmatrix} $$ C是常数项矩阵（或者常数向量）： $$ \\begin{bmatrix} c_1 \\ c_2 \\ \\vdots \\ c_m \\end{bmatrix} $$ 那么由线性系统组成的变换就叫做线性变换。\n行列式的计算方法 就是教科书上说的子行列式展开方法，只不过他有正式的名字，叫拉普拉斯展开(Laplacian expansion)\n线性空间 数域(Field) 表示一个代数系统，其含有：\n封闭性：对其中的元素进行加减乘除（除0除外）后的结果仍属于该系统 对加法和乘法拥有交换律和结合律 存在加法单位元：$\\exists 0 \\in F\\Rightarrow \\exists a \\in F \\Rightarrow \\forall a \\in F, a + 0 = 0 + a = a$ 存在乘法单位元：$\\exists 1 \\in F \\Rightarrow \\forall a \\in F, a1 = 1a = a$ 存在加法逆元：$\\forall a \\in F, \\exists -a \\in F \\Rightarrow a + (-a) = (-a) + a = 0$ 存在乘法逆元：$\\forall a \\in F, \\exists a^{-1} \\in F \\Rightarrow a * a^{-1} = a^{-1} * a = 1$ 线性空间就是一个包含了向量，实数和两种向量运算（点乘和叉乘）的数域:\n封闭性：对于任意的向量和实数相乘，结果为向量 任意的向量和标量的乘法，向量和向量的加法分别拥有交换律和结合律 存在加法单位元$\\vec{0}$使得$\\vec{a} + \\vec{0} = \\vec{a}$ 存在乘法单位元1，使得$1 * \\vec{a} = \\vec{a}$ 存在加法逆元$-\\vec{a}$，使得$-\\vec{a} + \\vec{a} = \\vec{0}$ 存在乘法逆元$\\frac{1}{k}$使得$k * \\frac{1}{k} = 1$（$k=0$时的逆元为0） 子空间 给定$\\R$上的线性空间$\\Upsilon$，设$S$为$\\Upsilon$的子集，并设$S$和$\\Upsilon$的运算相同。如果$S$也是$\\R$上的线性空间，那么$S$就是$\\Upsilon$的子空间。\n注意线性空间的子空间不一定是线性空间。但一定是$\\R$上的线性空间(根据定义)。\n线性组合，线性无关和生成","description":"","tags":["图形学"],"title":"《Geometric Tools For Computer Graphics》读书笔记2","uri":"/posts/geomentric-tools-for-computer-graphics%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02/"}]